/**
 * skylark-pako - A skylark wrapper for pako.
 * @author Hudaokeji Co.,Ltd
 * @version v0.9.0
 * @link www.skylarkjs.org
 * @license MIT
 */
define(["./adler32","./crc32","./inffast","./inftrees","./constants"],function(e,t,a,i,s){"use strict";const{Z_FINISH:n,Z_BLOCK:r,Z_TREES:o,Z_OK:l,Z_STREAM_END:d,Z_NEED_DICT:c,Z_STREAM_ERROR:f,Z_DATA_ERROR:h,Z_MEM_ERROR:b,Z_BUF_ERROR:k,Z_DEFLATED:m}=s,w=e=>(e>>>24&255)+(e>>>8&65280)+((65280&e)<<8)+((255&e)<<24);const g=e=>{if(!e||!e.state)return f;const t=e.state;return e.total_in=e.total_out=t.total=0,e.msg="",t.wrap&&(e.adler=1&t.wrap),t.mode=1,t.last=0,t.havedict=0,t.dmax=32768,t.head=null,t.hold=0,t.bits=0,t.lencode=t.lendyn=new Int32Array(852),t.distcode=t.distdyn=new Int32Array(592),t.sane=1,t.back=-1,l},u=e=>{if(!e||!e.state)return f;const t=e.state;return t.wsize=0,t.whave=0,t.wnext=0,g(e)},x=(e,t)=>{let a;if(!e||!e.state)return f;const i=e.state;return t<0?(a=0,t=-t):(a=1+(t>>4),t<48&&(t&=15)),t&&(t<8||t>15)?f:(null!==i.window&&i.wbits!==t&&(i.window=null),i.wrap=a,i.wbits=t,u(e))},_=(e,t)=>{if(!e)return f;const a=new function(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0};e.state=a,a.window=null;const i=x(e,t);return i!==l&&(e.state=null),i};let v,p,y=!0;const R=e=>{if(y){v=new Int32Array(512),p=new Int32Array(32);let t=0;for(;t<144;)e.lens[t++]=8;for(;t<256;)e.lens[t++]=9;for(;t<280;)e.lens[t++]=7;for(;t<288;)e.lens[t++]=8;for(i(1,e.lens,0,288,v,0,e.work,{bits:9}),t=0;t<32;)e.lens[t++]=5;i(2,e.lens,0,32,p,0,e.work,{bits:5}),y=!1}e.lencode=v,e.lenbits=9,e.distcode=p,e.distbits=5},A=(e,t,a,i)=>{let s;const n=e.state;return null===n.window&&(n.wsize=1<<n.wbits,n.wnext=0,n.whave=0,n.window=new Uint8Array(n.wsize)),i>=n.wsize?(n.window.set(t.subarray(a-n.wsize,a),0),n.wnext=0,n.whave=n.wsize):((s=n.wsize-n.wnext)>i&&(s=i),n.window.set(t.subarray(a-i,a-i+s),n.wnext),(i-=s)?(n.window.set(t.subarray(a-i,a),0),n.wnext=i,n.whave=n.wsize):(n.wnext+=s,n.wnext===n.wsize&&(n.wnext=0),n.whave<n.wsize&&(n.whave+=s))),0};return{inflateReset:u,inflateReset2:x,inflateResetKeep:g,inflateInit:e=>_(e,15),inflateInit2:_,inflate:(s,g)=>{let u,x,_,v,p,y,E,z,Z,I,D,S,U,C,O,T,M,N,F,K,B,H,L=0;const j=new Uint8Array(4);let G,q;const J=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(!s||!s.state||!s.output||!s.input&&0!==s.avail_in)return f;12===(u=s.state).mode&&(u.mode=13),p=s.next_out,_=s.output,E=s.avail_out,v=s.next_in,x=s.input,y=s.avail_in,z=u.hold,Z=u.bits,I=y,D=E,H=l;e:for(;;)switch(u.mode){case 1:if(0===u.wrap){u.mode=13;break}for(;Z<16;){if(0===y)break e;y--,z+=x[v++]<<Z,Z+=8}if(2&u.wrap&&35615===z){u.check=0,j[0]=255&z,j[1]=z>>>8&255,u.check=t(u.check,j,2,0),z=0,Z=0,u.mode=2;break}if(u.flags=0,u.head&&(u.head.done=!1),!(1&u.wrap)||(((255&z)<<8)+(z>>8))%31){s.msg="incorrect header check",u.mode=30;break}if((15&z)!==m){s.msg="unknown compression method",u.mode=30;break}if(Z-=4,B=8+(15&(z>>>=4)),0===u.wbits)u.wbits=B;else if(B>u.wbits){s.msg="invalid window size",u.mode=30;break}u.dmax=1<<u.wbits,s.adler=u.check=1,u.mode=512&z?10:12,z=0,Z=0;break;case 2:for(;Z<16;){if(0===y)break e;y--,z+=x[v++]<<Z,Z+=8}if(u.flags=z,(255&u.flags)!==m){s.msg="unknown compression method",u.mode=30;break}if(57344&u.flags){s.msg="unknown header flags set",u.mode=30;break}u.head&&(u.head.text=z>>8&1),512&u.flags&&(j[0]=255&z,j[1]=z>>>8&255,u.check=t(u.check,j,2,0)),z=0,Z=0,u.mode=3;case 3:for(;Z<32;){if(0===y)break e;y--,z+=x[v++]<<Z,Z+=8}u.head&&(u.head.time=z),512&u.flags&&(j[0]=255&z,j[1]=z>>>8&255,j[2]=z>>>16&255,j[3]=z>>>24&255,u.check=t(u.check,j,4,0)),z=0,Z=0,u.mode=4;case 4:for(;Z<16;){if(0===y)break e;y--,z+=x[v++]<<Z,Z+=8}u.head&&(u.head.xflags=255&z,u.head.os=z>>8),512&u.flags&&(j[0]=255&z,j[1]=z>>>8&255,u.check=t(u.check,j,2,0)),z=0,Z=0,u.mode=5;case 5:if(1024&u.flags){for(;Z<16;){if(0===y)break e;y--,z+=x[v++]<<Z,Z+=8}u.length=z,u.head&&(u.head.extra_len=z),512&u.flags&&(j[0]=255&z,j[1]=z>>>8&255,u.check=t(u.check,j,2,0)),z=0,Z=0}else u.head&&(u.head.extra=null);u.mode=6;case 6:if(1024&u.flags&&((S=u.length)>y&&(S=y),S&&(u.head&&(B=u.head.extra_len-u.length,u.head.extra||(u.head.extra=new Uint8Array(u.head.extra_len)),u.head.extra.set(x.subarray(v,v+S),B)),512&u.flags&&(u.check=t(u.check,x,S,v)),y-=S,v+=S,u.length-=S),u.length))break e;u.length=0,u.mode=7;case 7:if(2048&u.flags){if(0===y)break e;S=0;do{B=x[v+S++],u.head&&B&&u.length<65536&&(u.head.name+=String.fromCharCode(B))}while(B&&S<y);if(512&u.flags&&(u.check=t(u.check,x,S,v)),y-=S,v+=S,B)break e}else u.head&&(u.head.name=null);u.length=0,u.mode=8;case 8:if(4096&u.flags){if(0===y)break e;S=0;do{B=x[v+S++],u.head&&B&&u.length<65536&&(u.head.comment+=String.fromCharCode(B))}while(B&&S<y);if(512&u.flags&&(u.check=t(u.check,x,S,v)),y-=S,v+=S,B)break e}else u.head&&(u.head.comment=null);u.mode=9;case 9:if(512&u.flags){for(;Z<16;){if(0===y)break e;y--,z+=x[v++]<<Z,Z+=8}if(z!==(65535&u.check)){s.msg="header crc mismatch",u.mode=30;break}z=0,Z=0}u.head&&(u.head.hcrc=u.flags>>9&1,u.head.done=!0),s.adler=u.check=0,u.mode=12;break;case 10:for(;Z<32;){if(0===y)break e;y--,z+=x[v++]<<Z,Z+=8}s.adler=u.check=w(z),z=0,Z=0,u.mode=11;case 11:if(0===u.havedict)return s.next_out=p,s.avail_out=E,s.next_in=v,s.avail_in=y,u.hold=z,u.bits=Z,c;s.adler=u.check=1,u.mode=12;case 12:if(g===r||g===o)break e;case 13:if(u.last){z>>>=7&Z,Z-=7&Z,u.mode=27;break}for(;Z<3;){if(0===y)break e;y--,z+=x[v++]<<Z,Z+=8}switch(u.last=1&z,Z-=1,3&(z>>>=1)){case 0:u.mode=14;break;case 1:if(R(u),u.mode=20,g===o){z>>>=2,Z-=2;break e}break;case 2:u.mode=17;break;case 3:s.msg="invalid block type",u.mode=30}z>>>=2,Z-=2;break;case 14:for(z>>>=7&Z,Z-=7&Z;Z<32;){if(0===y)break e;y--,z+=x[v++]<<Z,Z+=8}if((65535&z)!=(z>>>16^65535)){s.msg="invalid stored block lengths",u.mode=30;break}if(u.length=65535&z,z=0,Z=0,u.mode=15,g===o)break e;case 15:u.mode=16;case 16:if(S=u.length){if(S>y&&(S=y),S>E&&(S=E),0===S)break e;_.set(x.subarray(v,v+S),p),y-=S,v+=S,E-=S,p+=S,u.length-=S;break}u.mode=12;break;case 17:for(;Z<14;){if(0===y)break e;y--,z+=x[v++]<<Z,Z+=8}if(u.nlen=257+(31&z),z>>>=5,Z-=5,u.ndist=1+(31&z),z>>>=5,Z-=5,u.ncode=4+(15&z),z>>>=4,Z-=4,u.nlen>286||u.ndist>30){s.msg="too many length or distance symbols",u.mode=30;break}u.have=0,u.mode=18;case 18:for(;u.have<u.ncode;){for(;Z<3;){if(0===y)break e;y--,z+=x[v++]<<Z,Z+=8}u.lens[J[u.have++]]=7&z,z>>>=3,Z-=3}for(;u.have<19;)u.lens[J[u.have++]]=0;if(u.lencode=u.lendyn,u.lenbits=7,G={bits:u.lenbits},H=i(0,u.lens,0,19,u.lencode,0,u.work,G),u.lenbits=G.bits,H){s.msg="invalid code lengths set",u.mode=30;break}u.have=0,u.mode=19;case 19:for(;u.have<u.nlen+u.ndist;){for(;T=(L=u.lencode[z&(1<<u.lenbits)-1])>>>16&255,M=65535&L,!((O=L>>>24)<=Z);){if(0===y)break e;y--,z+=x[v++]<<Z,Z+=8}if(M<16)z>>>=O,Z-=O,u.lens[u.have++]=M;else{if(16===M){for(q=O+2;Z<q;){if(0===y)break e;y--,z+=x[v++]<<Z,Z+=8}if(z>>>=O,Z-=O,0===u.have){s.msg="invalid bit length repeat",u.mode=30;break}B=u.lens[u.have-1],S=3+(3&z),z>>>=2,Z-=2}else if(17===M){for(q=O+3;Z<q;){if(0===y)break e;y--,z+=x[v++]<<Z,Z+=8}Z-=O,B=0,S=3+(7&(z>>>=O)),z>>>=3,Z-=3}else{for(q=O+7;Z<q;){if(0===y)break e;y--,z+=x[v++]<<Z,Z+=8}Z-=O,B=0,S=11+(127&(z>>>=O)),z>>>=7,Z-=7}if(u.have+S>u.nlen+u.ndist){s.msg="invalid bit length repeat",u.mode=30;break}for(;S--;)u.lens[u.have++]=B}}if(30===u.mode)break;if(0===u.lens[256]){s.msg="invalid code -- missing end-of-block",u.mode=30;break}if(u.lenbits=9,G={bits:u.lenbits},H=i(1,u.lens,0,u.nlen,u.lencode,0,u.work,G),u.lenbits=G.bits,H){s.msg="invalid literal/lengths set",u.mode=30;break}if(u.distbits=6,u.distcode=u.distdyn,G={bits:u.distbits},H=i(2,u.lens,u.nlen,u.ndist,u.distcode,0,u.work,G),u.distbits=G.bits,H){s.msg="invalid distances set",u.mode=30;break}if(u.mode=20,g===o)break e;case 20:u.mode=21;case 21:if(y>=6&&E>=258){s.next_out=p,s.avail_out=E,s.next_in=v,s.avail_in=y,u.hold=z,u.bits=Z,a(s,D),p=s.next_out,_=s.output,E=s.avail_out,v=s.next_in,x=s.input,y=s.avail_in,z=u.hold,Z=u.bits,12===u.mode&&(u.back=-1);break}for(u.back=0;T=(L=u.lencode[z&(1<<u.lenbits)-1])>>>16&255,M=65535&L,!((O=L>>>24)<=Z);){if(0===y)break e;y--,z+=x[v++]<<Z,Z+=8}if(T&&0==(240&T)){for(N=O,F=T,K=M;T=(L=u.lencode[K+((z&(1<<N+F)-1)>>N)])>>>16&255,M=65535&L,!(N+(O=L>>>24)<=Z);){if(0===y)break e;y--,z+=x[v++]<<Z,Z+=8}z>>>=N,Z-=N,u.back+=N}if(z>>>=O,Z-=O,u.back+=O,u.length=M,0===T){u.mode=26;break}if(32&T){u.back=-1,u.mode=12;break}if(64&T){s.msg="invalid literal/length code",u.mode=30;break}u.extra=15&T,u.mode=22;case 22:if(u.extra){for(q=u.extra;Z<q;){if(0===y)break e;y--,z+=x[v++]<<Z,Z+=8}u.length+=z&(1<<u.extra)-1,z>>>=u.extra,Z-=u.extra,u.back+=u.extra}u.was=u.length,u.mode=23;case 23:for(;T=(L=u.distcode[z&(1<<u.distbits)-1])>>>16&255,M=65535&L,!((O=L>>>24)<=Z);){if(0===y)break e;y--,z+=x[v++]<<Z,Z+=8}if(0==(240&T)){for(N=O,F=T,K=M;T=(L=u.distcode[K+((z&(1<<N+F)-1)>>N)])>>>16&255,M=65535&L,!(N+(O=L>>>24)<=Z);){if(0===y)break e;y--,z+=x[v++]<<Z,Z+=8}z>>>=N,Z-=N,u.back+=N}if(z>>>=O,Z-=O,u.back+=O,64&T){s.msg="invalid distance code",u.mode=30;break}u.offset=M,u.extra=15&T,u.mode=24;case 24:if(u.extra){for(q=u.extra;Z<q;){if(0===y)break e;y--,z+=x[v++]<<Z,Z+=8}u.offset+=z&(1<<u.extra)-1,z>>>=u.extra,Z-=u.extra,u.back+=u.extra}if(u.offset>u.dmax){s.msg="invalid distance too far back",u.mode=30;break}u.mode=25;case 25:if(0===E)break e;if(S=D-E,u.offset>S){if((S=u.offset-S)>u.whave&&u.sane){s.msg="invalid distance too far back",u.mode=30;break}S>u.wnext?(S-=u.wnext,U=u.wsize-S):U=u.wnext-S,S>u.length&&(S=u.length),C=u.window}else C=_,U=p-u.offset,S=u.length;S>E&&(S=E),E-=S,u.length-=S;do{_[p++]=C[U++]}while(--S);0===u.length&&(u.mode=21);break;case 26:if(0===E)break e;_[p++]=u.length,E--,u.mode=21;break;case 27:if(u.wrap){for(;Z<32;){if(0===y)break e;y--,z|=x[v++]<<Z,Z+=8}if(D-=E,s.total_out+=D,u.total+=D,D&&(s.adler=u.check=u.flags?t(u.check,_,D,p-D):e(u.check,_,D,p-D)),D=E,(u.flags?z:w(z))!==u.check){s.msg="incorrect data check",u.mode=30;break}z=0,Z=0}u.mode=28;case 28:if(u.wrap&&u.flags){for(;Z<32;){if(0===y)break e;y--,z+=x[v++]<<Z,Z+=8}if(z!==(4294967295&u.total)){s.msg="incorrect length check",u.mode=30;break}z=0,Z=0}u.mode=29;case 29:H=d;break e;case 30:H=h;break e;case 31:return b;case 32:default:return f}return s.next_out=p,s.avail_out=E,s.next_in=v,s.avail_in=y,u.hold=z,u.bits=Z,(u.wsize||D!==s.avail_out&&u.mode<30&&(u.mode<27||g!==n))&&A(s,s.output,s.next_out,D-s.avail_out)?(u.mode=31,b):(I-=s.avail_in,D-=s.avail_out,s.total_in+=I,s.total_out+=D,u.total+=D,u.wrap&&D&&(s.adler=u.check=u.flags?t(u.check,_,D,s.next_out-D):e(u.check,_,D,s.next_out-D)),s.data_type=u.bits+(u.last?64:0)+(12===u.mode?128:0)+(20===u.mode||15===u.mode?256:0),(0===I&&0===D||g===n)&&H===l&&(H=k),H)},inflateEnd:e=>{if(!e||!e.state)return f;let t=e.state;return t.window&&(t.window=null),e.state=null,l},inflateGetHeader:(e,t)=>{if(!e||!e.state)return f;const a=e.state;return 0==(2&a.wrap)?f:(a.head=t,t.done=!1,l)},inflateSetDictionary:(t,a)=>{const i=a.length;let s,n,r;return t&&t.state?0!==(s=t.state).wrap&&11!==s.mode?f:11===s.mode&&(n=e(n=1,a,i,0))!==s.check?h:(r=A(t,a,i,i))?(s.mode=31,b):(s.havedict=1,l):f},inflateInfo:"pako inflate (from Nodeca project)"}});
//# sourceMappingURL=../sourcemaps/zlib/inflate.js.map
