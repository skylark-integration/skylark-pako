{"version":3,"sources":["inflates.js"],"names":["define","zlib_inflate","utils","strings","msg","ZStream","GZheader","constants","toString","Object","prototype","Z_NO_FLUSH","Z_FINISH","Z_OK","Z_STREAM_END","Z_NEED_DICT","Z_STREAM_ERROR","Z_DATA_ERROR","Z_MEM_ERROR","Inflate","options","this","assign","chunkSize","windowBits","to","opt","raw","err","ended","chunks","strm","avail_out","status","inflateInit2","Error","header","inflateGetHeader","dictionary","string2buf","call","Uint8Array","inflateSetDictionary","inflate","input","inflator","push","result","data","flush_mode","_flush_mode","last_avail_out","next_in","avail_in","length","output","next_out","state","wrap","inflateReset","onEnd","next_out_utf8","utf8border","tail","utf8str","buf2string","set","subarray","onData","inflateEnd","chunk","join","flattenChunks","inflateRaw","ungzip"],"mappings":"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","file":"../inflates.js","sourcesContent":["define([\n    './zlib/inflate',\n    './utils/common',\n    './utils/strings',\n    './zlib/messages',\n    './zlib/zstream',\n    './zlib/gzheader',\n    './zlib/constants'\n], function (zlib_inflate, utils, strings, msg, ZStream, GZheader, constants) {\n    'use strict';\n\n\n    const toString = Object.prototype.toString;\n    const {Z_NO_FLUSH, Z_FINISH, Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR} = constants;\n    function Inflate(options) {\n        this.options = utils.assign({\n            chunkSize: 1024 * 64,\n            windowBits: 15,\n            to: ''\n        }, options || {});\n        const opt = this.options;\n        if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {\n            opt.windowBits = -opt.windowBits;\n            if (opt.windowBits === 0) {\n                opt.windowBits = -15;\n            }\n        }\n        if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {\n            opt.windowBits += 32;\n        }\n        if (opt.windowBits > 15 && opt.windowBits < 48) {\n            if ((opt.windowBits & 15) === 0) {\n                opt.windowBits |= 15;\n            }\n        }\n        this.err = 0;\n        this.msg = '';\n        this.ended = false;\n        this.chunks = [];\n        this.strm = new ZStream();\n        this.strm.avail_out = 0;\n        let status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);\n        if (status !== Z_OK) {\n            throw new Error(msg[status]);\n        }\n        this.header = new GZheader();\n        zlib_inflate.inflateGetHeader(this.strm, this.header);\n        if (opt.dictionary) {\n            if (typeof opt.dictionary === 'string') {\n                opt.dictionary = strings.string2buf(opt.dictionary);\n            } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n                opt.dictionary = new Uint8Array(opt.dictionary);\n            }\n            if (opt.raw) {\n                status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);\n                if (status !== Z_OK) {\n                    throw new Error(msg[status]);\n                }\n            }\n        }\n    }\n    Inflate.prototype.push = function (data, flush_mode) {\n        const strm = this.strm;\n        const chunkSize = this.options.chunkSize;\n        const dictionary = this.options.dictionary;\n        let status, _flush_mode, last_avail_out;\n        if (this.ended)\n            return false;\n        if (flush_mode === ~~flush_mode)\n            _flush_mode = flush_mode;\n        else\n            _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;\n        if (toString.call(data) === '[object ArrayBuffer]') {\n            strm.input = new Uint8Array(data);\n        } else {\n            strm.input = data;\n        }\n        strm.next_in = 0;\n        strm.avail_in = strm.input.length;\n        for (;;) {\n            if (strm.avail_out === 0) {\n                strm.output = new Uint8Array(chunkSize);\n                strm.next_out = 0;\n                strm.avail_out = chunkSize;\n            }\n            status = zlib_inflate.inflate(strm, _flush_mode);\n            if (status === Z_NEED_DICT && dictionary) {\n                status = zlib_inflate.inflateSetDictionary(strm, dictionary);\n                if (status === Z_OK) {\n                    status = zlib_inflate.inflate(strm, _flush_mode);\n                } else if (status === Z_DATA_ERROR) {\n                    status = Z_NEED_DICT;\n                }\n            }\n            while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {\n                zlib_inflate.inflateReset(strm);\n                status = zlib_inflate.inflate(strm, _flush_mode);\n            }\n            switch (status) {\n            case Z_STREAM_ERROR:\n            case Z_DATA_ERROR:\n            case Z_NEED_DICT:\n            case Z_MEM_ERROR:\n                this.onEnd(status);\n                this.ended = true;\n                return false;\n            }\n            last_avail_out = strm.avail_out;\n            if (strm.next_out) {\n                if (strm.avail_out === 0 || status === Z_STREAM_END) {\n                    if (this.options.to === 'string') {\n                        let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);\n                        let tail = strm.next_out - next_out_utf8;\n                        let utf8str = strings.buf2string(strm.output, next_out_utf8);\n                        strm.next_out = tail;\n                        strm.avail_out = chunkSize - tail;\n                        if (tail)\n                            strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);\n                        this.onData(utf8str);\n                    } else {\n                        this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));\n                    }\n                }\n            }\n            if (status === Z_OK && last_avail_out === 0)\n                continue;\n            if (status === Z_STREAM_END) {\n                status = zlib_inflate.inflateEnd(this.strm);\n                this.onEnd(status);\n                this.ended = true;\n                return true;\n            }\n            if (strm.avail_in === 0)\n                break;\n        }\n        return true;\n    };\n    Inflate.prototype.onData = function (chunk) {\n        this.chunks.push(chunk);\n    };\n    Inflate.prototype.onEnd = function (status) {\n        if (status === Z_OK) {\n            if (this.options.to === 'string') {\n                this.result = this.chunks.join('');\n            } else {\n                this.result = utils.flattenChunks(this.chunks);\n            }\n        }\n        this.chunks = [];\n        this.err = status;\n        this.msg = this.strm.msg;\n    };\n    function inflate(input, options) {\n        const inflator = new Inflate(options);\n        inflator.push(input);\n        if (inflator.err)\n            throw inflator.msg || msg[inflator.err];\n        return inflator.result;\n    }\n    function inflateRaw(input, options) {\n        options = options || {};\n        options.raw = true;\n        return inflate(input, options);\n    }\n\n\n    return {\n        Inflate,\n        inflate,\n        inflateRaw,\n        ungzip : inflate,\n        constants\n    };\n  \n});"]}