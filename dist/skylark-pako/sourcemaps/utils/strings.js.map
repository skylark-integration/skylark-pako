{"version":3,"sources":["utils/strings.js"],"names":["define","STR_APPLY_UIA_OK","String","fromCharCode","apply","Uint8Array","__","_utf8len","q","buf2binstring","buf","len","subarray","length","result","i","string2buf","str","TextEncoder","prototype","encode","c","c2","m_pos","str_len","buf_len","charCodeAt","buf2string","max","TextDecoder","decode","out","utf16buf","Array","c_len","utf8border","pos"],"mappings":"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","file":"../../utils/strings.js","sourcesContent":["define([], function () {\n    'use strict';\n    var exports = {};\n\n    let STR_APPLY_UIA_OK = true;\n    try {\n        String.fromCharCode.apply(null, new Uint8Array(1));\n    } catch (__) {\n        STR_APPLY_UIA_OK = false;\n    }\n\n    const _utf8len = new Uint8Array(256);\n    for (let q = 0; q < 256; q++) {\n        _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;\n    }\n    _utf8len[254] = _utf8len[254] = 1;\n\n    function string2buf(str){\n        if (typeof TextEncoder === 'function' && TextEncoder.prototype.encode) {\n            return new TextEncoder().encode(str);\n        }\n        let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n        for (m_pos = 0; m_pos < str_len; m_pos++) {\n            c = str.charCodeAt(m_pos);\n            if ((c & 64512) === 55296 && m_pos + 1 < str_len) {\n                c2 = str.charCodeAt(m_pos + 1);\n                if ((c2 & 64512) === 56320) {\n                    c = 65536 + (c - 55296 << 10) + (c2 - 56320);\n                    m_pos++;\n                }\n            }\n            buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;\n        }\n        buf = new Uint8Array(buf_len);\n        for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n            c = str.charCodeAt(m_pos);\n            if ((c & 64512) === 55296 && m_pos + 1 < str_len) {\n                c2 = str.charCodeAt(m_pos + 1);\n                if ((c2 & 64512) === 56320) {\n                    c = 65536 + (c - 55296 << 10) + (c2 - 56320);\n                    m_pos++;\n                }\n            }\n            if (c < 128) {\n                buf[i++] = c;\n            } else if (c < 2048) {\n                buf[i++] = 192 | c >>> 6;\n                buf[i++] = 128 | c & 63;\n            } else if (c < 65536) {\n                buf[i++] = 224 | c >>> 12;\n                buf[i++] = 128 | c >>> 6 & 63;\n                buf[i++] = 128 | c & 63;\n            } else {\n                buf[i++] = 240 | c >>> 18;\n                buf[i++] = 128 | c >>> 12 & 63;\n                buf[i++] = 128 | c >>> 6 & 63;\n                buf[i++] = 128 | c & 63;\n            }\n        }\n        return buf;\n    }\n\n    const buf2binstring = (buf, len) => {\n        if (len < 65534) {\n            if (buf.subarray && STR_APPLY_UIA_OK) {\n                return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));\n            }\n        }\n        let result = '';\n        for (let i = 0; i < len; i++) {\n            result += String.fromCharCode(buf[i]);\n        }\n        return result;\n    };\n    \n    function buf2string (buf, max) {\n        const len = max || buf.length;\n        if (typeof TextDecoder === 'function' && TextDecoder.prototype.decode) {\n            return new TextDecoder().decode(buf.subarray(0, max));\n        }\n        let i, out;\n        const utf16buf = new Array(len * 2);\n        for (out = 0, i = 0; i < len;) {\n            let c = buf[i++];\n            if (c < 128) {\n                utf16buf[out++] = c;\n                continue;\n            }\n            let c_len = _utf8len[c];\n            if (c_len > 4) {\n                utf16buf[out++] = 65533;\n                i += c_len - 1;\n                continue;\n            }\n            c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;\n            while (c_len > 1 && i < len) {\n                c = c << 6 | buf[i++] & 63;\n                c_len--;\n            }\n            if (c_len > 1) {\n                utf16buf[out++] = 65533;\n                continue;\n            }\n            if (c < 65536) {\n                utf16buf[out++] = c;\n            } else {\n                c -= 65536;\n                utf16buf[out++] = 55296 | c >> 10 & 1023;\n                utf16buf[out++] = 56320 | c & 1023;\n            }\n        }\n        return buf2binstring(utf16buf, out);\n    }\n\n    function utf8border(buf, max) {\n        max = max || buf.length;\n        if (max > buf.length) {\n            max = buf.length;\n        }\n        let pos = max - 1;\n        while (pos >= 0 && (buf[pos] & 192) === 128) {\n            pos--;\n        }\n        if (pos < 0) {\n            return max;\n        }\n        if (pos === 0) {\n            return max;\n        }\n        return pos + _utf8len[buf[pos]] > max ? pos : max;\n    }\n\n    return {\n      string2buf,\n      buf2string,\n      utf8border\n    };\n});"]}