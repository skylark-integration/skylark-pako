{"version":3,"sources":["utils/strings.js"],"names":["define","STR_APPLY_UIA_OK","String","fromCharCode","apply","Uint8Array","__","_utf8len","q","string2buf","str","TextEncoder","prototype","encode","buf","c","c2","m_pos","i","str_len","length","buf_len","charCodeAt","buf2string","max","len","TextDecoder","decode","subarray","out","utf16buf","Array","c_len","result","buf2binstring","utf8border","pos"],"mappings":";;;;;;;AAAAA,UAAW,WACP,aAOA,IAAIC,GAAmB,EAEvB,IAAMC,OAAOC,aAAaC,MAAM,KAAM,IAAIC,WAAW,IAAO,MAAOC,GAAML,GAAmB,EAM5F,MAAMM,EAAW,IAAIF,WAAW,KAChC,IAAK,IAAIG,EAAI,EAAGA,EAAI,IAAKA,IACvBD,EAASC,GAAMA,GAAK,IAAM,EAAIA,GAAK,IAAM,EAAIA,GAAK,IAAM,EAAIA,GAAK,IAAM,EAAIA,GAAK,IAAM,EAAI,EAE5FD,EAAS,KAAOA,EAAS,KAAO,EA2JhC,OACEE,WAxJkBC,IAClB,GAA2B,mBAAhBC,aAA8BA,YAAYC,UAAUC,OAC7D,OAAO,IAAIF,aAAcE,OAAOH,GAGlC,IAAII,EAAKC,EAAGC,EAAIC,EAAOC,EAAGC,EAAUT,EAAIU,OAAQC,EAAU,EAG1D,IAAKJ,EAAQ,EAAGA,EAAQE,EAASF,IAEV,QAAZ,OADTF,EAAIL,EAAIY,WAAWL,MACaA,EAAQ,EAAIE,GAEpB,QAAZ,OADVH,EAAKN,EAAIY,WAAWL,EAAQ,OAE1BF,EAAI,OAAYA,EAAI,OAAW,KAAOC,EAAK,OAC3CC,KAGJI,GAAWN,EAAI,IAAO,EAAIA,EAAI,KAAQ,EAAIA,EAAI,MAAU,EAAI,EAO9D,IAHAD,EAAM,IAAIT,WAAWgB,GAGhBH,EAAI,EAAGD,EAAQ,EAAGC,EAAIG,EAASJ,IAEb,QAAZ,OADTF,EAAIL,EAAIY,WAAWL,MACaA,EAAQ,EAAIE,GAEpB,QAAZ,OADVH,EAAKN,EAAIY,WAAWL,EAAQ,OAE1BF,EAAI,OAAYA,EAAI,OAAW,KAAOC,EAAK,OAC3CC,KAGAF,EAAI,IAEND,EAAII,KAAOH,EACFA,EAAI,MAEbD,EAAII,KAAO,IAAQH,IAAM,EACzBD,EAAII,KAAO,IAAY,GAAJH,GACVA,EAAI,OAEbD,EAAII,KAAO,IAAQH,IAAM,GACzBD,EAAII,KAAO,IAAQH,IAAM,EAAI,GAC7BD,EAAII,KAAO,IAAY,GAAJH,IAGnBD,EAAII,KAAO,IAAQH,IAAM,GACzBD,EAAII,KAAO,IAAQH,IAAM,GAAK,GAC9BD,EAAII,KAAO,IAAQH,IAAM,EAAI,GAC7BD,EAAII,KAAO,IAAY,GAAJH,GAIvB,OAAOD,GAmGPS,WA5EiB,CAACT,EAAKU,KACvB,MAAMC,EAAMD,GAAOV,EAAIM,OAEvB,GAA2B,mBAAhBM,aAA8BA,YAAYd,UAAUe,OAC7D,OAAO,IAAID,aAAcC,OAAOb,EAAIc,SAAS,EAAGJ,IAGlD,IAAIN,EAAGW,EAKP,MAAMC,EAAW,IAAIC,MAAY,EAANN,GAE3B,IAAKI,EAAM,EAAGX,EAAI,EAAGA,EAAIO,GAAM,CAC7B,IAAIV,EAAID,EAAII,KAEZ,GAAIH,EAAI,IAAM,CAAEe,EAASD,KAASd,EAAG,SAErC,IAAIiB,EAAQzB,EAASQ,GAErB,GAAIiB,EAAQ,EAAKF,EAASD,KAAS,MAAQX,GAAKc,EAAQ,MAAxD,CAKA,IAFAjB,GAAe,IAAViB,EAAc,GAAiB,IAAVA,EAAc,GAAO,EAExCA,EAAQ,GAAKd,EAAIO,GACtBV,EAAKA,GAAK,EAAiB,GAAXD,EAAII,KACpBc,IAIEA,EAAQ,EAAKF,EAASD,KAAS,MAE/Bd,EAAI,MACNe,EAASD,KAASd,GAElBA,GAAK,MACLe,EAASD,KAAS,MAAWd,GAAK,GAAM,KACxCe,EAASD,KAAS,MAAc,KAAJd,IAIhC,MA9DoB,EAACD,EAAKW,KAI1B,GAAIA,EAAM,OACJX,EAAIc,UAAY3B,EAClB,OAAOC,OAAOC,aAAaC,MAAM,KAAMU,EAAIM,SAAWK,EAAMX,EAAMA,EAAIc,SAAS,EAAGH,IAItF,IAAIQ,EAAS,GACb,IAAK,IAAIf,EAAI,EAAGA,EAAIO,EAAKP,IACvBe,GAAU/B,OAAOC,aAAaW,EAAII,IAEpC,OAAOe,GAgDAC,CAAcJ,EAAUD,IAkC/BM,WAxBiB,CAACrB,EAAKU,MAEvBA,EAAMA,GAAOV,EAAIM,QACPN,EAAIM,SAAUI,EAAMV,EAAIM,QAGlC,IAAIgB,EAAMZ,EAAM,EAChB,KAAOY,GAAO,GAA2B,MAAV,IAAXtB,EAAIsB,KAAyBA,IAIjD,OAAIA,EAAM,EAAYZ,EAIV,IAARY,EAAoBZ,EAEhBY,EAAM7B,EAASO,EAAIsB,IAAQZ,EAAOY,EAAMZ","file":"../../utils/strings.js","sourcesContent":["define([], function () {\n    'use strict';\n\n    // Quick check if we can use fast array to bin string conversion\n    //\n    // - apply(Array) can fail on Android 2.2\n    // - apply(Uint8Array) can fail on iOS 5.1 Safari\n    //\n    let STR_APPLY_UIA_OK = true;\n\n    try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }\n\n\n    // Table with utf8 lengths (calculated by first byte of sequence)\n    // Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n    // because max possible codepoint is 0x10ffff\n    const _utf8len = new Uint8Array(256);\n    for (let q = 0; q < 256; q++) {\n      _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);\n    }\n    _utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n\n\n    // convert string to array (typed, when possible)\n    const string2buf = (str) => {\n      if (typeof TextEncoder === 'function' && TextEncoder.prototype.encode) {\n        return new TextEncoder().encode(str);\n      }\n\n      let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n      // count binary size\n      for (m_pos = 0; m_pos < str_len; m_pos++) {\n        c = str.charCodeAt(m_pos);\n        if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n          c2 = str.charCodeAt(m_pos + 1);\n          if ((c2 & 0xfc00) === 0xdc00) {\n            c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n            m_pos++;\n          }\n        }\n        buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n      }\n\n      // allocate buffer\n      buf = new Uint8Array(buf_len);\n\n      // convert\n      for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n        c = str.charCodeAt(m_pos);\n        if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n          c2 = str.charCodeAt(m_pos + 1);\n          if ((c2 & 0xfc00) === 0xdc00) {\n            c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n            m_pos++;\n          }\n        }\n        if (c < 0x80) {\n          /* one byte */\n          buf[i++] = c;\n        } else if (c < 0x800) {\n          /* two bytes */\n          buf[i++] = 0xC0 | (c >>> 6);\n          buf[i++] = 0x80 | (c & 0x3f);\n        } else if (c < 0x10000) {\n          /* three bytes */\n          buf[i++] = 0xE0 | (c >>> 12);\n          buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n          buf[i++] = 0x80 | (c & 0x3f);\n        } else {\n          /* four bytes */\n          buf[i++] = 0xf0 | (c >>> 18);\n          buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n          buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n          buf[i++] = 0x80 | (c & 0x3f);\n        }\n      }\n\n      return buf;\n    };\n\n    // Helper\n    const buf2binstring = (buf, len) => {\n      // On Chrome, the arguments in a function call that are allowed is `65534`.\n      // If the length of the buffer is smaller than that, we can use this optimization,\n      // otherwise we will take a slower path.\n      if (len < 65534) {\n        if (buf.subarray && STR_APPLY_UIA_OK) {\n          return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));\n        }\n      }\n\n      let result = '';\n      for (let i = 0; i < len; i++) {\n        result += String.fromCharCode(buf[i]);\n      }\n      return result;\n    };\n\n\n    // convert array to string\n    const buf2string = (buf, max) => {\n      const len = max || buf.length;\n\n      if (typeof TextDecoder === 'function' && TextDecoder.prototype.decode) {\n        return new TextDecoder().decode(buf.subarray(0, max));\n      }\n\n      let i, out;\n\n      // Reserve max possible length (2 words per char)\n      // NB: by unknown reasons, Array is significantly faster for\n      //     String.fromCharCode.apply than Uint16Array.\n      const utf16buf = new Array(len * 2);\n\n      for (out = 0, i = 0; i < len;) {\n        let c = buf[i++];\n        // quick process ascii\n        if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n        let c_len = _utf8len[c];\n        // skip 5 & 6 byte codes\n        if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }\n\n        // apply mask on first byte\n        c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n        // join the rest\n        while (c_len > 1 && i < len) {\n          c = (c << 6) | (buf[i++] & 0x3f);\n          c_len--;\n        }\n\n        // terminated by end of string?\n        if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n        if (c < 0x10000) {\n          utf16buf[out++] = c;\n        } else {\n          c -= 0x10000;\n          utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n          utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n        }\n      }\n\n      return buf2binstring(utf16buf, out);\n    };\n\n\n    // Calculate max possible position in utf8 buffer,\n    // that will not break sequence. If that's not possible\n    // - (very small limits) return max size as is.\n    //\n    // buf[] - utf8 bytes array\n    // max   - length limit (mandatory);\n    const utf8border = (buf, max) => {\n\n      max = max || buf.length;\n      if (max > buf.length) { max = buf.length; }\n\n      // go back from last position, until start of sequence found\n      let pos = max - 1;\n      while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n      // Very small and broken sequence,\n      // return max, because we should return something anyway.\n      if (pos < 0) { return max; }\n\n      // If we came to start of buffer - that means buffer is too small,\n      // return max too.\n      if (pos === 0) { return max; }\n\n      return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n    };\n\n\n    return {\n      string2buf,\n      buf2string,\n      utf8border\n    };\n});"]}