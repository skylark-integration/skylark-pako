{"version":3,"sources":["zlib/trees.js"],"names":["define","zero","buf","len","length","extra_lbits","Uint8Array","extra_dbits","extra_blbits","bl_order","static_ltree","Array","static_dtree","D_CODES","_dist_code","_length_code","MAX_MATCH","base_length","base_dist","StaticTreeDesc","static_tree","extra_bits","extra_base","elems","max_length","this","has_stree","static_l_desc","static_d_desc","static_bl_desc","TreeDesc","dyn_tree","stat_desc","max_code","d_code","dist","put_short","s","w","pending_buf","pending","send_bits","value","bi_valid","bi_buf","send_code","c","tree","bi_reverse","code","res","gen_codes","bl_count","next_code","MAX_BITS","bits","n","init_block","LITERALS","dyn_ltree","dyn_dtree","bl_tree","END_BLOCK","opt_len","static_len","last_lit","matches","bi_windup","smaller","m","depth","_n2","_m2","pqdownheap","k","v","heap","j","heap_len","compress_block","ltree","dtree","lc","extra","lx","d_buf","l_buf","build_tree","desc","stree","node","heap_max","base","h","xbits","f","overflow","gen_bitlen","scan_tree","curlen","prevlen","nextlen","count","max_count","min_count","REP_3_6","REPZ_3_10","REPZ_11_138","send_tree","static_init_done","_tr_stored_block","stored_len","last","header","set","window","subarray","_tr_init","LENGTH_CODES","L_CODES","tr_static_init","l_desc","d_desc","bl_desc","_tr_flush_block","opt_lenb","static_lenb","max_blindex","level","strm","data_type","black_mask","detect_data_type","BL_CODES","build_bl_tree","strategy","lcodes","dcodes","blcodes","rank","send_all_trees","_tr_tally","lit_bufsize","_tr_align","STATIC_TREES","bi_flush"],"mappings":"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","file":"../../zlib/trees.js","sourcesContent":["define([], function () {\n    'use strict';\n    // Original version : zlib 1.2.8\n    // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n\n    //const Z_FILTERED          = 1;\n    //const Z_HUFFMAN_ONLY      = 2;\n    //const Z_RLE               = 3;\n    const Z_FIXED               = 4;\n    //const Z_DEFAULT_STRATEGY  = 0;\n\n    /* Possible values of the data_type field (though see inflate()) */\n    const Z_BINARY              = 0;\n    const Z_TEXT                = 1;\n    //const Z_ASCII             = 1; // = Z_TEXT\n    const Z_UNKNOWN             = 2;\n\n    /*============================================================================*/\n\n\n    function zero(buf) { let len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n    // From zutil.h\n\n    const STORED_BLOCK = 0;\n    const STATIC_TREES = 1;\n    const DYN_TREES    = 2;\n    /* The three kinds of block type */\n\n    const MIN_MATCH    = 3;\n    const MAX_MATCH    = 258;\n    /* The minimum and maximum match lengths */\n\n    // From deflate.h\n    /* ===========================================================================\n     * Internal compression state.\n     */\n\n    const LENGTH_CODES  = 29;\n    /* number of length codes, not counting the special END_BLOCK code */\n\n    const LITERALS      = 256;\n    /* number of literal bytes 0..255 */\n\n    const L_CODES       = LITERALS + 1 + LENGTH_CODES;\n    /* number of Literal or Length codes, including the END_BLOCK code */\n\n    const D_CODES       = 30;\n    /* number of distance codes */\n\n    const BL_CODES      = 19;\n    /* number of codes used to transfer the bit lengths */\n\n    const HEAP_SIZE     = 2 * L_CODES + 1;\n    /* maximum heap size */\n\n    const MAX_BITS      = 15;\n    /* All codes must not exceed MAX_BITS bits */\n\n    const Buf_size      = 16;\n    /* size of bit buffer in bi_buf */\n\n\n    /* ===========================================================================\n     * Constants\n     */\n\n    const MAX_BL_BITS = 7;\n    /* Bit length codes must not exceed MAX_BL_BITS bits */\n\n    const END_BLOCK   = 256;\n    /* end of block literal code */\n\n    const REP_3_6     = 16;\n    /* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\n    const REPZ_3_10   = 17;\n    /* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\n    const REPZ_11_138 = 18;\n    /* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n    /* eslint-disable comma-spacing,array-bracket-spacing */\n    const extra_lbits =   /* extra bits for each length code */\n      new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]);\n\n    const extra_dbits =   /* extra bits for each distance code */\n      new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]);\n\n    const extra_blbits =  /* extra bits for each bit length code */\n      new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]);\n\n    const bl_order =\n      new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);\n    /* eslint-enable comma-spacing,array-bracket-spacing */\n\n    /* The lengths of the bit length codes are sent in order of decreasing\n     * probability, to avoid transmitting the lengths for unused bit length codes.\n     */\n\n    /* ===========================================================================\n     * Local data. These are initialized only once.\n     */\n\n    // We pre-fill arrays with 0 to avoid uninitialized gaps\n\n    const DIST_CODE_LEN = 512; /* see definition of array dist_code below */\n\n    // !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\n    const static_ltree  = new Array((L_CODES + 2) * 2);\n    zero(static_ltree);\n    /* The static literal tree. Since the bit lengths are imposed, there is no\n     * need for the L_CODES extra codes used during heap construction. However\n     * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n     * below).\n     */\n\n    const static_dtree  = new Array(D_CODES * 2);\n    zero(static_dtree);\n    /* The static distance tree. (Actually a trivial tree since all codes use\n     * 5 bits.)\n     */\n\n    const _dist_code    = new Array(DIST_CODE_LEN);\n    zero(_dist_code);\n    /* Distance codes. The first 256 values correspond to the distances\n     * 3 .. 258, the last 256 values correspond to the top 8 bits of\n     * the 15 bit distances.\n     */\n\n    const _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);\n    zero(_length_code);\n    /* length code for each normalized match length (0 == MIN_MATCH) */\n\n    const base_length   = new Array(LENGTH_CODES);\n    zero(base_length);\n    /* First normalized length for each code (0 = MIN_MATCH) */\n\n    const base_dist     = new Array(D_CODES);\n    zero(base_dist);\n    /* First normalized distance for each code (0 = distance of 1) */\n\n\n    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n\n      this.static_tree  = static_tree;  /* static tree or NULL */\n      this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */\n      this.extra_base   = extra_base;   /* base index for extra_bits */\n      this.elems        = elems;        /* max number of elements in the tree */\n      this.max_length   = max_length;   /* max bit length for the codes */\n\n      // show if `static_tree` has data or dummy - needed for monomorphic objects\n      this.has_stree    = static_tree && static_tree.length;\n    }\n\n\n    let static_l_desc;\n    let static_d_desc;\n    let static_bl_desc;\n\n\n    function TreeDesc(dyn_tree, stat_desc) {\n      this.dyn_tree = dyn_tree;     /* the dynamic tree */\n      this.max_code = 0;            /* largest code with non zero frequency */\n      this.stat_desc = stat_desc;   /* the corresponding static tree */\n    }\n\n\n\n    const d_code = (dist) => {\n\n      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n    };\n\n\n    /* ===========================================================================\n     * Output a short LSB first on the stream.\n     * IN assertion: there is enough room in pendingBuf.\n     */\n    const put_short = (s, w) => {\n    //    put_byte(s, (uch)((w) & 0xff));\n    //    put_byte(s, (uch)((ush)(w) >> 8));\n      s.pending_buf[s.pending++] = (w) & 0xff;\n      s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n    };\n\n\n    /* ===========================================================================\n     * Send a value on a given number of bits.\n     * IN assertion: length <= 16 and value fits in length bits.\n     */\n    const send_bits = (s, value, length) => {\n\n      if (s.bi_valid > (Buf_size - length)) {\n        s.bi_buf |= (value << s.bi_valid) & 0xffff;\n        put_short(s, s.bi_buf);\n        s.bi_buf = value >> (Buf_size - s.bi_valid);\n        s.bi_valid += length - Buf_size;\n      } else {\n        s.bi_buf |= (value << s.bi_valid) & 0xffff;\n        s.bi_valid += length;\n      }\n    };\n\n\n    const send_code = (s, c, tree) => {\n\n      send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);\n    };\n\n\n    /* ===========================================================================\n     * Reverse the first len bits of a code, using straightforward code (a faster\n     * method would use a table)\n     * IN assertion: 1 <= len <= 15\n     */\n    const bi_reverse = (code, len) => {\n\n      let res = 0;\n      do {\n        res |= code & 1;\n        code >>>= 1;\n        res <<= 1;\n      } while (--len > 0);\n      return res >>> 1;\n    };\n\n\n    /* ===========================================================================\n     * Flush the bit buffer, keeping at most 7 bits in it.\n     */\n    const bi_flush = (s) => {\n\n      if (s.bi_valid === 16) {\n        put_short(s, s.bi_buf);\n        s.bi_buf = 0;\n        s.bi_valid = 0;\n\n      } else if (s.bi_valid >= 8) {\n        s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n        s.bi_buf >>= 8;\n        s.bi_valid -= 8;\n      }\n    };\n\n\n    /* ===========================================================================\n     * Compute the optimal bit lengths for a tree and update the total bit length\n     * for the current block.\n     * IN assertion: the fields freq and dad are set, heap[heap_max] and\n     *    above are the tree nodes sorted by increasing frequency.\n     * OUT assertions: the field len is set to the optimal bit length, the\n     *     array bl_count contains the frequencies for each bit length.\n     *     The length opt_len is updated; static_len is also updated if stree is\n     *     not null.\n     */\n    const gen_bitlen = (s, desc) =>\n    //    deflate_state *s;\n    //    tree_desc *desc;    /* the tree descriptor */\n    {\n      const tree            = desc.dyn_tree;\n      const max_code        = desc.max_code;\n      const stree           = desc.stat_desc.static_tree;\n      const has_stree       = desc.stat_desc.has_stree;\n      const extra           = desc.stat_desc.extra_bits;\n      const base            = desc.stat_desc.extra_base;\n      const max_length      = desc.stat_desc.max_length;\n      let h;              /* heap index */\n      let n, m;           /* iterate over the tree elements */\n      let bits;           /* bit length */\n      let xbits;          /* extra bits */\n      let f;              /* frequency */\n      let overflow = 0;   /* number of elements with bit length too large */\n\n      for (bits = 0; bits <= MAX_BITS; bits++) {\n        s.bl_count[bits] = 0;\n      }\n\n      /* In a first pass, compute the optimal bit lengths (which may\n       * overflow in the case of the bit length tree).\n       */\n      tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */\n\n      for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n        n = s.heap[h];\n        bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;\n        if (bits > max_length) {\n          bits = max_length;\n          overflow++;\n        }\n        tree[n * 2 + 1]/*.Len*/ = bits;\n        /* We overwrite tree[n].Dad which is no longer needed */\n\n        if (n > max_code) { continue; } /* not a leaf node */\n\n        s.bl_count[bits]++;\n        xbits = 0;\n        if (n >= base) {\n          xbits = extra[n - base];\n        }\n        f = tree[n * 2]/*.Freq*/;\n        s.opt_len += f * (bits + xbits);\n        if (has_stree) {\n          s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);\n        }\n      }\n      if (overflow === 0) { return; }\n\n      // Trace((stderr,\"\\nbit length overflow\\n\"));\n      /* This happens for example on obj2 and pic of the Calgary corpus */\n\n      /* Find the first bit length which could increase: */\n      do {\n        bits = max_length - 1;\n        while (s.bl_count[bits] === 0) { bits--; }\n        s.bl_count[bits]--;      /* move one leaf down the tree */\n        s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */\n        s.bl_count[max_length]--;\n        /* The brother of the overflow item also moves one step up,\n         * but this does not affect bl_count[max_length]\n         */\n        overflow -= 2;\n      } while (overflow > 0);\n\n      /* Now recompute all bit lengths, scanning in increasing frequency.\n       * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n       * lengths instead of fixing only the wrong ones. This idea is taken\n       * from 'ar' written by Haruhiko Okumura.)\n       */\n      for (bits = max_length; bits !== 0; bits--) {\n        n = s.bl_count[bits];\n        while (n !== 0) {\n          m = s.heap[--h];\n          if (m > max_code) { continue; }\n          if (tree[m * 2 + 1]/*.Len*/ !== bits) {\n            // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n            s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;\n            tree[m * 2 + 1]/*.Len*/ = bits;\n          }\n          n--;\n        }\n      }\n    };\n\n\n    /* ===========================================================================\n     * Generate the codes for a given tree and bit counts (which need not be\n     * optimal).\n     * IN assertion: the array bl_count contains the bit length statistics for\n     * the given tree and the field len is set for all tree elements.\n     * OUT assertion: the field code is set for all tree elements of non\n     *     zero code length.\n     */\n    const gen_codes = (tree, max_code, bl_count) =>\n    //    ct_data *tree;             /* the tree to decorate */\n    //    int max_code;              /* largest code with non zero frequency */\n    //    ushf *bl_count;            /* number of codes at each bit length */\n    {\n      const next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */\n      let code = 0;              /* running code value */\n      let bits;                  /* bit index */\n      let n;                     /* code index */\n\n      /* The distribution counts are first used to generate the code values\n       * without bit reversal.\n       */\n      for (bits = 1; bits <= MAX_BITS; bits++) {\n        next_code[bits] = code = (code + bl_count[bits - 1]) << 1;\n      }\n      /* Check that the bit counts in bl_count are consistent. The last code\n       * must be all ones.\n       */\n      //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n      //        \"inconsistent bit counts\");\n      //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n      for (n = 0;  n <= max_code; n++) {\n        let len = tree[n * 2 + 1]/*.Len*/;\n        if (len === 0) { continue; }\n        /* Now reverse the bits */\n        tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);\n\n        //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n        //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n      }\n    };\n\n\n    /* ===========================================================================\n     * Initialize the various 'constant' tables.\n     */\n    const tr_static_init = () => {\n\n      let n;        /* iterates over tree elements */\n      let bits;     /* bit counter */\n      let length;   /* length value */\n      let code;     /* code value */\n      let dist;     /* distance index */\n      const bl_count = new Array(MAX_BITS + 1);\n      /* number of codes at each bit length for an optimal tree */\n\n      // do check in _tr_init()\n      //if (static_init_done) return;\n\n      /* For some embedded targets, global variables are not initialized: */\n    /*#ifdef NO_INIT_GLOBAL_POINTERS\n      static_l_desc.static_tree = static_ltree;\n      static_l_desc.extra_bits = extra_lbits;\n      static_d_desc.static_tree = static_dtree;\n      static_d_desc.extra_bits = extra_dbits;\n      static_bl_desc.extra_bits = extra_blbits;\n    #endif*/\n\n      /* Initialize the mapping length (0..255) -> length code (0..28) */\n      length = 0;\n      for (code = 0; code < LENGTH_CODES - 1; code++) {\n        base_length[code] = length;\n        for (n = 0; n < (1 << extra_lbits[code]); n++) {\n          _length_code[length++] = code;\n        }\n      }\n      //Assert (length == 256, \"tr_static_init: length != 256\");\n      /* Note that the length 255 (match length 258) can be represented\n       * in two different ways: code 284 + 5 bits or code 285, so we\n       * overwrite length_code[255] to use the best encoding:\n       */\n      _length_code[length - 1] = code;\n\n      /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n      dist = 0;\n      for (code = 0; code < 16; code++) {\n        base_dist[code] = dist;\n        for (n = 0; n < (1 << extra_dbits[code]); n++) {\n          _dist_code[dist++] = code;\n        }\n      }\n      //Assert (dist == 256, \"tr_static_init: dist != 256\");\n      dist >>= 7; /* from now on, all distances are divided by 128 */\n      for (; code < D_CODES; code++) {\n        base_dist[code] = dist << 7;\n        for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n          _dist_code[256 + dist++] = code;\n        }\n      }\n      //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n      /* Construct the codes of the static literal tree */\n      for (bits = 0; bits <= MAX_BITS; bits++) {\n        bl_count[bits] = 0;\n      }\n\n      n = 0;\n      while (n <= 143) {\n        static_ltree[n * 2 + 1]/*.Len*/ = 8;\n        n++;\n        bl_count[8]++;\n      }\n      while (n <= 255) {\n        static_ltree[n * 2 + 1]/*.Len*/ = 9;\n        n++;\n        bl_count[9]++;\n      }\n      while (n <= 279) {\n        static_ltree[n * 2 + 1]/*.Len*/ = 7;\n        n++;\n        bl_count[7]++;\n      }\n      while (n <= 287) {\n        static_ltree[n * 2 + 1]/*.Len*/ = 8;\n        n++;\n        bl_count[8]++;\n      }\n      /* Codes 286 and 287 do not exist, but we must include them in the\n       * tree construction to get a canonical Huffman tree (longest code\n       * all ones)\n       */\n      gen_codes(static_ltree, L_CODES + 1, bl_count);\n\n      /* The static distance tree is trivial: */\n      for (n = 0; n < D_CODES; n++) {\n        static_dtree[n * 2 + 1]/*.Len*/ = 5;\n        static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);\n      }\n\n      // Now data ready and we can init static trees\n      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);\n      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);\n\n      //static_init_done = true;\n    };\n\n\n    /* ===========================================================================\n     * Initialize a new block.\n     */\n    const init_block = (s) => {\n\n      let n; /* iterates over tree elements */\n\n      /* Initialize the trees. */\n      for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }\n      for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }\n      for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }\n\n      s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;\n      s.opt_len = s.static_len = 0;\n      s.last_lit = s.matches = 0;\n    };\n\n\n    /* ===========================================================================\n     * Flush the bit buffer and align the output on a byte boundary\n     */\n    const bi_windup = (s) =>\n    {\n      if (s.bi_valid > 8) {\n        put_short(s, s.bi_buf);\n      } else if (s.bi_valid > 0) {\n        //put_byte(s, (Byte)s->bi_buf);\n        s.pending_buf[s.pending++] = s.bi_buf;\n      }\n      s.bi_buf = 0;\n      s.bi_valid = 0;\n    };\n\n    /* ===========================================================================\n     * Copy a stored block, storing first the length and its\n     * one's complement if requested.\n     */\n    const copy_block = (s, buf, len, header) =>\n    //DeflateState *s;\n    //charf    *buf;    /* the input data */\n    //unsigned len;     /* its length */\n    //int      header;  /* true if block header must be written */\n    {\n      bi_windup(s);        /* align on byte boundary */\n\n      if (header) {\n        put_short(s, len);\n        put_short(s, ~len);\n      }\n    //  while (len--) {\n    //    put_byte(s, *buf++);\n    //  }\n      s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);\n      s.pending += len;\n    };\n\n    /* ===========================================================================\n     * Compares to subtrees, using the tree depth as tie breaker when\n     * the subtrees have equal frequency. This minimizes the worst case length.\n     */\n    const smaller = (tree, n, m, depth) => {\n\n      const _n2 = n * 2;\n      const _m2 = m * 2;\n      return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||\n             (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));\n    };\n\n    /* ===========================================================================\n     * Restore the heap property by moving down the tree starting at node k,\n     * exchanging a node with the smallest of its two sons if necessary, stopping\n     * when the heap property is re-established (each father smaller than its\n     * two sons).\n     */\n    const pqdownheap = (s, tree, k) =>\n    //    deflate_state *s;\n    //    ct_data *tree;  /* the tree to restore */\n    //    int k;               /* node to move down */\n    {\n      const v = s.heap[k];\n      let j = k << 1;  /* left son of k */\n      while (j <= s.heap_len) {\n        /* Set j to the smallest of the two sons: */\n        if (j < s.heap_len &&\n          smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n          j++;\n        }\n        /* Exit if v is smaller than both sons */\n        if (smaller(tree, v, s.heap[j], s.depth)) { break; }\n\n        /* Exchange v with the smallest son */\n        s.heap[k] = s.heap[j];\n        k = j;\n\n        /* And continue down the tree, setting j to the left son of k */\n        j <<= 1;\n      }\n      s.heap[k] = v;\n    };\n\n\n    // inlined manually\n    // const SMALLEST = 1;\n\n    /* ===========================================================================\n     * Send the block data compressed using the given Huffman trees\n     */\n    const compress_block = (s, ltree, dtree) =>\n    //    deflate_state *s;\n    //    const ct_data *ltree; /* literal tree */\n    //    const ct_data *dtree; /* distance tree */\n    {\n      let dist;           /* distance of matched string */\n      let lc;             /* match length or unmatched char (if dist == 0) */\n      let lx = 0;         /* running index in l_buf */\n      let code;           /* the code to send */\n      let extra;          /* number of extra bits to send */\n\n      if (s.last_lit !== 0) {\n        do {\n          dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);\n          lc = s.pending_buf[s.l_buf + lx];\n          lx++;\n\n          if (dist === 0) {\n            send_code(s, lc, ltree); /* send a literal byte */\n            //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n          } else {\n            /* Here, lc is the match length - MIN_MATCH */\n            code = _length_code[lc];\n            send_code(s, code + LITERALS + 1, ltree); /* send the length code */\n            extra = extra_lbits[code];\n            if (extra !== 0) {\n              lc -= base_length[code];\n              send_bits(s, lc, extra);       /* send the extra length bits */\n            }\n            dist--; /* dist is now the match distance - 1 */\n            code = d_code(dist);\n            //Assert (code < D_CODES, \"bad d_code\");\n\n            send_code(s, code, dtree);       /* send the distance code */\n            extra = extra_dbits[code];\n            if (extra !== 0) {\n              dist -= base_dist[code];\n              send_bits(s, dist, extra);   /* send the extra distance bits */\n            }\n          } /* literal or match pair ? */\n\n          /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n          //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n          //       \"pendingBuf overflow\");\n\n        } while (lx < s.last_lit);\n      }\n\n      send_code(s, END_BLOCK, ltree);\n    };\n\n\n    /* ===========================================================================\n     * Construct one Huffman tree and assigns the code bit strings and lengths.\n     * Update the total bit length for the current block.\n     * IN assertion: the field freq is set for all tree elements.\n     * OUT assertions: the fields len and code are set to the optimal bit length\n     *     and corresponding code. The length opt_len is updated; static_len is\n     *     also updated if stree is not null. The field max_code is set.\n     */\n    const build_tree = (s, desc) =>\n    //    deflate_state *s;\n    //    tree_desc *desc; /* the tree descriptor */\n    {\n      const tree     = desc.dyn_tree;\n      const stree    = desc.stat_desc.static_tree;\n      const has_stree = desc.stat_desc.has_stree;\n      const elems    = desc.stat_desc.elems;\n      let n, m;          /* iterate over heap elements */\n      let max_code = -1; /* largest code with non zero frequency */\n      let node;          /* new node being created */\n\n      /* Construct the initial heap, with least frequent element in\n       * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n       * heap[0] is not used.\n       */\n      s.heap_len = 0;\n      s.heap_max = HEAP_SIZE;\n\n      for (n = 0; n < elems; n++) {\n        if (tree[n * 2]/*.Freq*/ !== 0) {\n          s.heap[++s.heap_len] = max_code = n;\n          s.depth[n] = 0;\n\n        } else {\n          tree[n * 2 + 1]/*.Len*/ = 0;\n        }\n      }\n\n      /* The pkzip format requires that at least one distance code exists,\n       * and that at least one bit should be sent even if there is only one\n       * possible code. So to avoid special checks later on we force at least\n       * two codes of non zero frequency.\n       */\n      while (s.heap_len < 2) {\n        node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\n        tree[node * 2]/*.Freq*/ = 1;\n        s.depth[node] = 0;\n        s.opt_len--;\n\n        if (has_stree) {\n          s.static_len -= stree[node * 2 + 1]/*.Len*/;\n        }\n        /* node is 0 or 1 so it does not have extra bits */\n      }\n      desc.max_code = max_code;\n\n      /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n       * establish sub-heaps of increasing lengths:\n       */\n      for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }\n\n      /* Construct the Huffman tree by repeatedly combining the least two\n       * frequent nodes.\n       */\n      node = elems;              /* next internal node of the tree */\n      do {\n        //pqremove(s, tree, n);  /* n = node of least frequency */\n        /*** pqremove ***/\n        n = s.heap[1/*SMALLEST*/];\n        s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];\n        pqdownheap(s, tree, 1/*SMALLEST*/);\n        /***/\n\n        m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */\n\n        s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\n        s.heap[--s.heap_max] = m;\n\n        /* Create a new node father of n and m */\n        tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;\n        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n        tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;\n\n        /* and insert the new node in the heap */\n        s.heap[1/*SMALLEST*/] = node++;\n        pqdownheap(s, tree, 1/*SMALLEST*/);\n\n      } while (s.heap_len >= 2);\n\n      s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];\n\n      /* At this point, the fields freq and dad are set. We can now\n       * generate the bit lengths.\n       */\n      gen_bitlen(s, desc);\n\n      /* The field len is now set, we can generate the bit codes */\n      gen_codes(tree, max_code, s.bl_count);\n    };\n\n\n    /* ===========================================================================\n     * Scan a literal or distance tree to determine the frequencies of the codes\n     * in the bit length tree.\n     */\n    const scan_tree = (s, tree, max_code) =>\n    //    deflate_state *s;\n    //    ct_data *tree;   /* the tree to be scanned */\n    //    int max_code;    /* and its largest code of non zero frequency */\n    {\n      let n;                     /* iterates over all tree elements */\n      let prevlen = -1;          /* last emitted length */\n      let curlen;                /* length of current code */\n\n      let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n      let count = 0;             /* repeat count of the current code */\n      let max_count = 7;         /* max repeat count */\n      let min_count = 4;         /* min repeat count */\n\n      if (nextlen === 0) {\n        max_count = 138;\n        min_count = 3;\n      }\n      tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */\n\n      for (n = 0; n <= max_code; n++) {\n        curlen = nextlen;\n        nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n        if (++count < max_count && curlen === nextlen) {\n          continue;\n\n        } else if (count < min_count) {\n          s.bl_tree[curlen * 2]/*.Freq*/ += count;\n\n        } else if (curlen !== 0) {\n\n          if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }\n          s.bl_tree[REP_3_6 * 2]/*.Freq*/++;\n\n        } else if (count <= 10) {\n          s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;\n\n        } else {\n          s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;\n        }\n\n        count = 0;\n        prevlen = curlen;\n\n        if (nextlen === 0) {\n          max_count = 138;\n          min_count = 3;\n\n        } else if (curlen === nextlen) {\n          max_count = 6;\n          min_count = 3;\n\n        } else {\n          max_count = 7;\n          min_count = 4;\n        }\n      }\n    };\n\n\n    /* ===========================================================================\n     * Send a literal or distance tree in compressed form, using the codes in\n     * bl_tree.\n     */\n    const send_tree = (s, tree, max_code) =>\n    //    deflate_state *s;\n    //    ct_data *tree; /* the tree to be scanned */\n    //    int max_code;       /* and its largest code of non zero frequency */\n    {\n      let n;                     /* iterates over all tree elements */\n      let prevlen = -1;          /* last emitted length */\n      let curlen;                /* length of current code */\n\n      let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n      let count = 0;             /* repeat count of the current code */\n      let max_count = 7;         /* max repeat count */\n      let min_count = 4;         /* min repeat count */\n\n      /* tree[max_code+1].Len = -1; */  /* guard already set */\n      if (nextlen === 0) {\n        max_count = 138;\n        min_count = 3;\n      }\n\n      for (n = 0; n <= max_code; n++) {\n        curlen = nextlen;\n        nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n        if (++count < max_count && curlen === nextlen) {\n          continue;\n\n        } else if (count < min_count) {\n          do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\n\n        } else if (curlen !== 0) {\n          if (curlen !== prevlen) {\n            send_code(s, curlen, s.bl_tree);\n            count--;\n          }\n          //Assert(count >= 3 && count <= 6, \" 3_6?\");\n          send_code(s, REP_3_6, s.bl_tree);\n          send_bits(s, count - 3, 2);\n\n        } else if (count <= 10) {\n          send_code(s, REPZ_3_10, s.bl_tree);\n          send_bits(s, count - 3, 3);\n\n        } else {\n          send_code(s, REPZ_11_138, s.bl_tree);\n          send_bits(s, count - 11, 7);\n        }\n\n        count = 0;\n        prevlen = curlen;\n        if (nextlen === 0) {\n          max_count = 138;\n          min_count = 3;\n\n        } else if (curlen === nextlen) {\n          max_count = 6;\n          min_count = 3;\n\n        } else {\n          max_count = 7;\n          min_count = 4;\n        }\n      }\n    };\n\n\n    /* ===========================================================================\n     * Construct the Huffman tree for the bit lengths and return the index in\n     * bl_order of the last bit length code to send.\n     */\n    const build_bl_tree = (s) => {\n\n      let max_blindex;  /* index of last bit length code of non zero freq */\n\n      /* Determine the bit length frequencies for literal and distance trees */\n      scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n      scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n\n      /* Build the bit length tree: */\n      build_tree(s, s.bl_desc);\n      /* opt_len now includes the length of the tree representations, except\n       * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n       */\n\n      /* Determine the number of bit length codes to send. The pkzip format\n       * requires that at least 4 bit length codes be sent. (appnote.txt says\n       * 3 but the actual value used is 4.)\n       */\n      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n        if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {\n          break;\n        }\n      }\n      /* Update opt_len to include the bit length tree and counts */\n      s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n      //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n      //        s->opt_len, s->static_len));\n\n      return max_blindex;\n    };\n\n\n    /* ===========================================================================\n     * Send the header for a block using dynamic Huffman trees: the counts, the\n     * lengths of the bit length codes, the literal tree and the distance tree.\n     * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n     */\n    const send_all_trees = (s, lcodes, dcodes, blcodes) =>\n    //    deflate_state *s;\n    //    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n    {\n      let rank;                    /* index in bl_order */\n\n      //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n      //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n      //        \"too many codes\");\n      //Tracev((stderr, \"\\nbl counts: \"));\n      send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */\n      send_bits(s, dcodes - 1,   5);\n      send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */\n      for (rank = 0; rank < blcodes; rank++) {\n        //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);\n      }\n      //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n      send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */\n      //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n      send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */\n      //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n    };\n\n\n    /* ===========================================================================\n     * Check if the data type is TEXT or BINARY, using the following algorithm:\n     * - TEXT if the two conditions below are satisfied:\n     *    a) There are no non-portable control characters belonging to the\n     *       \"black list\" (0..6, 14..25, 28..31).\n     *    b) There is at least one printable character belonging to the\n     *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n     * - BINARY otherwise.\n     * - The following partially-portable control characters form a\n     *   \"gray list\" that is ignored in this detection algorithm:\n     *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n     * IN assertion: the fields Freq of dyn_ltree are set.\n     */\n    const detect_data_type = (s) => {\n      /* black_mask is the bit mask of black-listed bytes\n       * set bits 0..6, 14..25, and 28..31\n       * 0xf3ffc07f = binary 11110011111111111100000001111111\n       */\n      let black_mask = 0xf3ffc07f;\n      let n;\n\n      /* Check for non-textual (\"black-listed\") bytes. */\n      for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n        if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {\n          return Z_BINARY;\n        }\n      }\n\n      /* Check for textual (\"white-listed\") bytes. */\n      if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||\n          s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {\n        return Z_TEXT;\n      }\n      for (n = 32; n < LITERALS; n++) {\n        if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {\n          return Z_TEXT;\n        }\n      }\n\n      /* There are no \"black-listed\" or \"white-listed\" bytes:\n       * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n       */\n      return Z_BINARY;\n    };\n\n\n    let static_init_done = false;\n\n    /* ===========================================================================\n     * Initialize the tree data structures for a new zlib stream.\n     */\n    const _tr_init = (s) =>\n    {\n\n      if (!static_init_done) {\n        tr_static_init();\n        static_init_done = true;\n      }\n\n      s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\n      s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\n      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n\n      s.bi_buf = 0;\n      s.bi_valid = 0;\n\n      /* Initialize the first block of the first file: */\n      init_block(s);\n    };\n\n\n    /* ===========================================================================\n     * Send a stored block\n     */\n    const _tr_stored_block = (s, buf, stored_len, last) =>\n    //DeflateState *s;\n    //charf *buf;       /* input block */\n    //ulg stored_len;   /* length of input block */\n    //int last;         /* one if this is the last block for a file */\n    {\n      send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */\n      copy_block(s, buf, stored_len, true); /* with header */\n    };\n\n\n    /* ===========================================================================\n     * Send one empty static block to give enough lookahead for inflate.\n     * This takes 10 bits, of which 7 may remain in the bit buffer.\n     */\n    const _tr_align = (s) => {\n      send_bits(s, STATIC_TREES << 1, 3);\n      send_code(s, END_BLOCK, static_ltree);\n      bi_flush(s);\n    };\n\n\n    /* ===========================================================================\n     * Determine the best encoding for the current block: dynamic trees, static\n     * trees or store, and output the encoded block to the zip file.\n     */\n    const _tr_flush_block = (s, buf, stored_len, last) =>\n    //DeflateState *s;\n    //charf *buf;       /* input block, or NULL if too old */\n    //ulg stored_len;   /* length of input block */\n    //int last;         /* one if this is the last block for a file */\n    {\n      let opt_lenb, static_lenb;  /* opt_len and static_len in bytes */\n      let max_blindex = 0;        /* index of last bit length code of non zero freq */\n\n      /* Build the Huffman trees unless a stored block is forced */\n      if (s.level > 0) {\n\n        /* Check if the file is binary or text */\n        if (s.strm.data_type === Z_UNKNOWN) {\n          s.strm.data_type = detect_data_type(s);\n        }\n\n        /* Construct the literal and distance trees */\n        build_tree(s, s.l_desc);\n        // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n        //        s->static_len));\n\n        build_tree(s, s.d_desc);\n        // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n        //        s->static_len));\n        /* At this point, opt_len and static_len are the total bit lengths of\n         * the compressed block data, excluding the tree representations.\n         */\n\n        /* Build the bit length tree for the above two trees, and get the index\n         * in bl_order of the last bit length code to send.\n         */\n        max_blindex = build_bl_tree(s);\n\n        /* Determine the best encoding. Compute the block lengths in bytes. */\n        opt_lenb = (s.opt_len + 3 + 7) >>> 3;\n        static_lenb = (s.static_len + 3 + 7) >>> 3;\n\n        // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n        //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n        //        s->last_lit));\n\n        if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\n\n      } else {\n        // Assert(buf != (char*)0, \"lost buf\");\n        opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n      }\n\n      if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {\n        /* 4: two words for the lengths */\n\n        /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n         * Otherwise we can't have processed more than WSIZE input bytes since\n         * the last block flush, because compression would have been\n         * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n         * transform a block into a stored block.\n         */\n        _tr_stored_block(s, buf, stored_len, last);\n\n      } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n\n        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n        compress_block(s, static_ltree, static_dtree);\n\n      } else {\n        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n        compress_block(s, s.dyn_ltree, s.dyn_dtree);\n      }\n      // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n      /* The above check is made mod 2^32, for files larger than 512 MB\n       * and uLong implemented on 32 bits.\n       */\n      init_block(s);\n\n      if (last) {\n        bi_windup(s);\n      }\n      // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n      //       s->compressed_len-7*last));\n    };\n\n    /* ===========================================================================\n     * Save the match info and tally the frequency counts. Return true if\n     * the current block must be flushed.\n     */\n    const _tr_tally = (s, dist, lc) =>\n    //    deflate_state *s;\n    //    unsigned dist;  /* distance of matched string */\n    //    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n    {\n      //let out_length, in_length, dcode;\n\n      s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;\n      s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n\n      s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n      s.last_lit++;\n\n      if (dist === 0) {\n        /* lc is the unmatched char */\n        s.dyn_ltree[lc * 2]/*.Freq*/++;\n      } else {\n        s.matches++;\n        /* Here, lc is the match length - MIN_MATCH */\n        dist--;             /* dist = match distance - 1 */\n        //Assert((ush)dist < (ush)MAX_DIST(s) &&\n        //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n        //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;\n        s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;\n      }\n\n    // (!) This block is disabled in zlib defaults,\n    // don't enable it for binary compatibility\n\n    //#ifdef TRUNCATE_BLOCK\n    //  /* Try to guess if it is profitable to stop the current block here */\n    //  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n    //    /* Compute an upper bound for the compressed length */\n    //    out_length = s.last_lit*8;\n    //    in_length = s.strstart - s.block_start;\n    //\n    //    for (dcode = 0; dcode < D_CODES; dcode++) {\n    //      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n    //    }\n    //    out_length >>>= 3;\n    //    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n    //    //       s->last_lit, in_length, out_length,\n    //    //       100L - out_length*100L/in_length));\n    //    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n    //      return true;\n    //    }\n    //  }\n    //#endif\n\n      return (s.last_lit === s.lit_bufsize - 1);\n      /* We avoid equality with lit_bufsize because of wraparound at 64K\n       * on 16 bit machines and because stored blocks are restricted to\n       * 64K-1 bytes.\n       */\n    };\n\n\n    return {\n        _tr_init,\n        _tr_stored_block,\n        _tr_flush_block,\n        _tr_tally,\n        _tr_align\n    };\n\n\n});"]}