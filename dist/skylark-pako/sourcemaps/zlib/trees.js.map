{"version":3,"sources":["zlib/trees.js"],"names":["define","zero","buf","len","length","extra_lbits","Uint8Array","extra_dbits","extra_blbits","bl_order","static_ltree","Array","static_dtree","D_CODES","_dist_code","_length_code","MAX_MATCH","base_length","base_dist","StaticTreeDesc","static_tree","extra_bits","extra_base","elems","max_length","this","has_stree","static_l_desc","static_d_desc","static_bl_desc","TreeDesc","dyn_tree","stat_desc","max_code","d_code","dist","put_short","s","w","pending_buf","pending","send_bits","value","bi_valid","bi_buf","send_code","c","tree","bi_reverse","code","res","gen_codes","bl_count","next_code","MAX_BITS","bits","n","init_block","LITERALS","dyn_ltree","dyn_dtree","bl_tree","END_BLOCK","opt_len","static_len","last_lit","matches","bi_windup","smaller","m","depth","_n2","_m2","pqdownheap","k","v","heap","j","heap_len","compress_block","ltree","dtree","lc","extra","lx","d_buf","l_buf","build_tree","desc","stree","node","heap_max","base","h","xbits","f","overflow","gen_bitlen","scan_tree","curlen","prevlen","nextlen","count","max_count","min_count","REP_3_6","REPZ_3_10","REPZ_11_138","send_tree","static_init_done","_tr_stored_block","stored_len","last","header","set","window","subarray","_tr_init","LENGTH_CODES","L_CODES","tr_static_init","l_desc","d_desc","bl_desc","_tr_flush_block","opt_lenb","static_lenb","max_blindex","level","strm","data_type","black_mask","detect_data_type","BL_CODES","build_bl_tree","strategy","lcodes","dcodes","blcodes","rank","send_all_trees","_tr_tally","lit_bufsize","_tr_align","STATIC_TREES","bi_flush"],"mappings":";;;;;;;AAAAA,UAAW,WACP,aAMA,SAASC,EAAKC,GACV,IAAIC,EAAMD,EAAIE,OACd,OAASD,GAAO,GACZD,EAAIC,GAAO,EAGnB,MAkBME,EAAc,IAAIC,YACpB,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IAEEC,EAAc,IAAID,YACpB,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,KAEEE,EAAe,IAAIF,YACrB,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IAEEG,EAAW,IAAIH,YACjB,GACA,GACA,GACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,GACA,EACA,GACA,EACA,GACA,EACA,GACA,EACA,KAGEI,EAAe,IAAIC,MAAM,KAC/BV,EAAKS,GACL,MAAME,EAAe,IAAID,MAAME,IAC/BZ,EAAKW,GACL,MAAME,EAAa,IAAIH,MALD,KAMtBV,EAAKa,GACL,MAAMC,EAAe,IAAIJ,MAAMK,KAC/Bf,EAAKc,GACL,MAAME,EAAc,IAAIN,MA/HH,IAgIrBV,EAAKgB,GACL,MAAMC,EAAY,IAAIP,MA9HN,IAgIhB,SAASQ,EAAeC,EAAaC,EAAYC,EAAYC,EAAOC,GAChEC,KAAKL,YAAcA,EACnBK,KAAKJ,WAAaA,EAClBI,KAAKH,WAAaA,EAClBG,KAAKF,MAAQA,EACbE,KAAKD,WAAaA,EAClBC,KAAKC,UAAYN,GAAeA,EAAYhB,OAEhD,IAAIuB,EACAC,EACAC,EACJ,SAASC,EAASC,EAAUC,GACxBP,KAAKM,SAAWA,EAChBN,KAAKQ,SAAW,EAChBR,KAAKO,UAAYA,EAfrB/B,EAAKiB,GAiBL,MAAMgB,EAASC,GACJA,EAAO,IAAMrB,EAAWqB,GAAQrB,EAAW,KAAOqB,IAAS,IAEhEC,EAAY,CAACC,EAAGC,KAClBD,EAAEE,YAAYF,EAAEG,WAAiB,IAAJF,EAC7BD,EAAEE,YAAYF,EAAEG,WAAaF,IAAM,EAAI,KAErCG,EAAY,CAACJ,EAAGK,EAAOtC,KACrBiC,EAAEM,SApJO,GAoJevC,GACxBiC,EAAEO,QAAUF,GAASL,EAAEM,SAAW,MAClCP,EAAUC,EAAGA,EAAEO,QACfP,EAAEO,OAASF,GAvJF,GAuJsBL,EAAEM,SACjCN,EAAEM,UAAYvC,EAxJL,KA0JTiC,EAAEO,QAAUF,GAASL,EAAEM,SAAW,MAClCN,EAAEM,UAAYvC,IAGhByC,EAAY,CAACR,EAAGS,EAAGC,KACrBN,EAAUJ,EAAGU,EAAS,EAAJD,GAAQC,EAAS,EAAJD,EAAQ,KAErCE,EAAa,CAACC,EAAM9C,KACtB,IAAI+C,EAAM,EACV,GACIA,GAAc,EAAPD,EACPA,KAAU,EACVC,IAAQ,UACD/C,EAAM,GACjB,OAAO+C,IAAQ,GAiFbC,EAAY,CAACJ,EAAMd,EAAUmB,KAC/B,MAAMC,EAAY,IAAI1C,MAAM2C,IAC5B,IACIC,EACAC,EAFAP,EAAO,EAGX,IAAKM,EAAO,EAAGA,GA/PF,GA+PoBA,IAC7BF,EAAUE,GAAQN,EAAOA,EAAOG,EAASG,EAAO,IAAM,EAE1D,IAAKC,EAAI,EAAGA,GAAKvB,EAAUuB,IAAK,CAC5B,IAAIrD,EAAM4C,EAAS,EAAJS,EAAQ,GACX,IAARrD,IAGJ4C,EAAS,EAAJS,GAASR,EAAWK,EAAUlD,KAAQA,MAiE7CsD,EAAapB,IACf,IAAImB,EACJ,IAAKA,EAAI,EAAGA,EA9UAE,IA8UaF,IACrBnB,EAAEsB,UAAc,EAAJH,GAAS,EAEzB,IAAKA,EAAI,EAAGA,EAhVA,GAgVaA,IACrBnB,EAAEuB,UAAc,EAAJJ,GAAS,EAEzB,IAAKA,EAAI,EAAGA,EAlVC,GAkVaA,IACtBnB,EAAEwB,QAAY,EAAJL,GAAS,EAEvBnB,EAAEsB,UAAUG,KAAiB,EAC7BzB,EAAE0B,QAAU1B,EAAE2B,WAAa,EAC3B3B,EAAE4B,SAAW5B,EAAE6B,QAAU,GAEvBC,EAAY9B,IACVA,EAAEM,SAAW,EACbP,EAAUC,EAAGA,EAAEO,QACRP,EAAEM,SAAW,IACpBN,EAAEE,YAAYF,EAAEG,WAAaH,EAAEO,QAEnCP,EAAEO,OAAS,EACXP,EAAEM,SAAW,GAWXyB,EAAU,CAACrB,EAAMS,EAAGa,EAAGC,KACzB,MAAMC,EAAU,EAAJf,EACNgB,EAAU,EAAJH,EACZ,OAAOtB,EAAKwB,GAAOxB,EAAKyB,IAAQzB,EAAKwB,KAASxB,EAAKyB,IAAQF,EAAMd,IAAMc,EAAMD,IAE3EI,EAAa,CAACpC,EAAGU,EAAM2B,KACzB,MAAMC,EAAItC,EAAEuC,KAAKF,GACjB,IAAIG,EAAIH,GAAK,EACb,KAAOG,GAAKxC,EAAEyC,WACND,EAAIxC,EAAEyC,UAAYV,EAAQrB,EAAMV,EAAEuC,KAAKC,EAAI,GAAIxC,EAAEuC,KAAKC,GAAIxC,EAAEiC,QAC5DO,KAEAT,EAAQrB,EAAM4B,EAAGtC,EAAEuC,KAAKC,GAAIxC,EAAEiC,SAGlCjC,EAAEuC,KAAKF,GAAKrC,EAAEuC,KAAKC,GACnBH,EAAIG,EACJA,IAAM,EAEVxC,EAAEuC,KAAKF,GAAKC,GAEVI,EAAiB,CAAC1C,EAAG2C,EAAOC,KAC9B,IAAI9C,EACA+C,EAEAjC,EACAkC,EAFAC,EAAK,EAGT,GAAmB,IAAf/C,EAAE4B,SACF,GACI9B,EAAOE,EAAEE,YAAYF,EAAEgD,MAAa,EAALD,IAAW,EAAI/C,EAAEE,YAAYF,EAAEgD,MAAa,EAALD,EAAS,GAC/EF,EAAK7C,EAAEE,YAAYF,EAAEiD,MAAQF,GAC7BA,IACa,IAATjD,EACAU,EAAUR,EAAG6C,EAAIF,IAEjB/B,EAAOlC,EAAamE,GACpBrC,EAAUR,EAAGY,EAlZZ,IAkZ8B,EAAG+B,GAEpB,KADdG,EAAQ9E,EAAY4C,MAEhBiC,GAAMjE,EAAYgC,GAClBR,EAAUJ,EAAG6C,EAAIC,IAGrBlC,EAAOf,IADPC,GAEAU,EAAUR,EAAGY,EAAMgC,GAEL,KADdE,EAAQ5E,EAAY0C,MAEhBd,GAAQjB,EAAU+B,GAClBR,EAAUJ,EAAGF,EAAMgD,WAGtBC,EAAK/C,EAAE4B,UAEpBpB,EAAUR,EA3ZI,IA2ZU2C,IAEtBO,EAAa,CAAClD,EAAGmD,KACnB,MAAMzC,EAAOyC,EAAKzD,SACZ0D,EAAQD,EAAKxD,UAAUZ,YACvBM,EAAY8D,EAAKxD,UAAUN,UAC3BH,EAAQiE,EAAKxD,UAAUT,MAC7B,IAAIiC,EAAGa,EAEHqB,EADAzD,GAAY,EAIhB,IAFAI,EAAEyC,SAAW,EACbzC,EAAEsD,SA1aY,IA2aTnC,EAAI,EAAGA,EAAIjC,EAAOiC,IACC,IAAhBT,EAAS,EAAJS,IACLnB,EAAEuC,OAAOvC,EAAEyC,UAAY7C,EAAWuB,EAClCnB,EAAEiC,MAAMd,GAAK,GAEbT,EAAS,EAAJS,EAAQ,GAAK,EAG1B,KAAOnB,EAAEyC,SAAW,GAEhB/B,EAAY,GADZ2C,EAAOrD,EAAEuC,OAAOvC,EAAEyC,UAAY7C,EAAW,IAAMA,EAAW,IACzC,EACjBI,EAAEiC,MAAMoB,GAAQ,EAChBrD,EAAE0B,UACErC,IACAW,EAAE2B,YAAcyB,EAAa,EAAPC,EAAW,IAIzC,IADAF,EAAKvD,SAAWA,EACXuB,EAAInB,EAAEyC,UAAY,EAAGtB,GAAK,EAAGA,IAC9BiB,EAAWpC,EAAGU,EAAMS,GAExBkC,EAAOnE,EACP,GACIiC,EAAInB,EAAEuC,KAAK,GACXvC,EAAEuC,KAAK,GAAKvC,EAAEuC,KAAKvC,EAAEyC,YACrBL,EAAWpC,EAAGU,EAAM,GACpBsB,EAAIhC,EAAEuC,KAAK,GACXvC,EAAEuC,OAAOvC,EAAEsD,UAAYnC,EACvBnB,EAAEuC,OAAOvC,EAAEsD,UAAYtB,EACvBtB,EAAY,EAAP2C,GAAY3C,EAAS,EAAJS,GAAST,EAAS,EAAJsB,GACpChC,EAAEiC,MAAMoB,IAASrD,EAAEiC,MAAMd,IAAMnB,EAAEiC,MAAMD,GAAKhC,EAAEiC,MAAMd,GAAKnB,EAAEiC,MAAMD,IAAM,EACvEtB,EAAS,EAAJS,EAAQ,GAAKT,EAAS,EAAJsB,EAAQ,GAAKqB,EACpCrD,EAAEuC,KAAK,GAAKc,IACZjB,EAAWpC,EAAGU,EAAM,SACfV,EAAEyC,UAAY,GACvBzC,EAAEuC,OAAOvC,EAAEsD,UAAYtD,EAAEuC,KAAK,GAvRf,EAACvC,EAAGmD,KACnB,MAAMzC,EAAOyC,EAAKzD,SACZE,EAAWuD,EAAKvD,SAChBwD,EAAQD,EAAKxD,UAAUZ,YACvBM,EAAY8D,EAAKxD,UAAUN,UAC3ByD,EAAQK,EAAKxD,UAAUX,WACvBuE,EAAOJ,EAAKxD,UAAUV,WACtBE,EAAagE,EAAKxD,UAAUR,WAClC,IAAIqE,EACArC,EAAGa,EACHd,EACAuC,EACAC,EACAC,EAAW,EACf,IAAKzC,EAAO,EAAGA,GApMF,GAoMoBA,IAC7BlB,EAAEe,SAASG,GAAQ,EAGvB,IADAR,EAA0B,EAArBV,EAAEuC,KAAKvC,EAAEsD,UAAgB,GAAK,EAC9BE,EAAIxD,EAAEsD,SAAW,EAAGE,EAzMX,IAyM0BA,KAEpCtC,EAAOR,EAAuB,EAAlBA,EAAS,GADrBS,EAAInB,EAAEuC,KAAKiB,IACc,GAAS,GAAK,GAC5BrE,IACP+B,EAAO/B,EACPwE,KAEJjD,EAAS,EAAJS,EAAQ,GAAKD,EACdC,EAAIvB,IAGRI,EAAEe,SAASG,KACXuC,EAAQ,EACJtC,GAAKoC,IACLE,EAAQX,EAAM3B,EAAIoC,IAEtBG,EAAIhD,EAAS,EAAJS,GACTnB,EAAE0B,SAAWgC,GAAKxC,EAAOuC,GACrBpE,IACAW,EAAE2B,YAAc+B,GAAKN,EAAU,EAAJjC,EAAQ,GAAKsC,KAGhD,GAAiB,IAAbE,EAAJ,CAGA,EAAG,CAEC,IADAzC,EAAO/B,EAAa,EACQ,IAArBa,EAAEe,SAASG,IACdA,IAEJlB,EAAEe,SAASG,KACXlB,EAAEe,SAASG,EAAO,IAAM,EACxBlB,EAAEe,SAAS5B,KACXwE,GAAY,QACPA,EAAW,GACpB,IAAKzC,EAAO/B,EAAqB,IAAT+B,EAAYA,IAEhC,IADAC,EAAInB,EAAEe,SAASG,GACF,IAANC,IACHa,EAAIhC,EAAEuC,OAAOiB,IACL5D,IAGJc,EAAS,EAAJsB,EAAQ,KAAOd,IACpBlB,EAAE0B,UAAYR,EAAOR,EAAS,EAAJsB,EAAQ,IAAMtB,EAAS,EAAJsB,GAC7CtB,EAAS,EAAJsB,EAAQ,GAAKd,GAEtBC,OAwNRyC,CAAW5D,EAAGmD,GACdrC,EAAUJ,EAAMd,EAAUI,EAAEe,WAE1B8C,EAAY,CAAC7D,EAAGU,EAAMd,KACxB,IAAIuB,EAEA2C,EADAC,GAAW,EAEXC,EAAUtD,EAAK,GACfuD,EAAQ,EACRC,EAAY,EACZC,EAAY,EAMhB,IALgB,IAAZH,IACAE,EAAY,IACZC,EAAY,GAEhBzD,EAAsB,GAAhBd,EAAW,GAAS,GAAK,MAC1BuB,EAAI,EAAGA,GAAKvB,EAAUuB,IACvB2C,EAASE,EACTA,EAAUtD,EAAe,GAATS,EAAI,GAAS,KACvB8C,EAAQC,GAAaJ,IAAWE,IAE3BC,EAAQE,EACfnE,EAAEwB,QAAiB,EAATsC,IAAeG,EACP,IAAXH,GACHA,IAAWC,GACX/D,EAAEwB,QAAiB,EAATsC,KAEd9D,EAAEwB,QAAQ4C,OACHH,GAAS,GAChBjE,EAAEwB,QAAQ6C,MAEVrE,EAAEwB,QAAQ8C,MAEdL,EAAQ,EACRF,EAAUD,EACM,IAAZE,GACAE,EAAY,IACZC,EAAY,GACLL,IAAWE,GAClBE,EAAY,EACZC,EAAY,IAEZD,EAAY,EACZC,EAAY,KAIlBI,EAAY,CAACvE,EAAGU,EAAMd,KACxB,IAAIuB,EAEA2C,EADAC,GAAW,EAEXC,EAAUtD,EAAK,GACfuD,EAAQ,EACRC,EAAY,EACZC,EAAY,EAKhB,IAJgB,IAAZH,IACAE,EAAY,IACZC,EAAY,GAEXhD,EAAI,EAAGA,GAAKvB,EAAUuB,IAGvB,GAFA2C,EAASE,EACTA,EAAUtD,EAAe,GAATS,EAAI,GAAS,OACvB8C,EAAQC,GAAaJ,IAAWE,GAAtC,CAEO,GAAIC,EAAQE,EACf,GACI3D,EAAUR,EAAG8D,EAAQ9D,EAAEwB,eACN,KAAVyC,QACO,IAAXH,GACHA,IAAWC,IACXvD,EAAUR,EAAG8D,EAAQ9D,EAAEwB,SACvByC,KAEJzD,EAAUR,EAnhBN,GAmhBkBA,EAAEwB,SACxBpB,EAAUJ,EAAGiE,EAAQ,EAAG,IACjBA,GAAS,IAChBzD,EAAUR,EArhBJ,GAqhBkBA,EAAEwB,SAC1BpB,EAAUJ,EAAGiE,EAAQ,EAAG,KAExBzD,EAAUR,EAvhBF,GAuhBkBA,EAAEwB,SAC5BpB,EAAUJ,EAAGiE,EAAQ,GAAI,IAE7BA,EAAQ,EACRF,EAAUD,EACM,IAAZE,GACAE,EAAY,IACZC,EAAY,GACLL,IAAWE,GAClBE,EAAY,EACZC,EAAY,IAEZD,EAAY,EACZC,EAAY,KA8CxB,IAAIK,GAAmB,EACvB,MAYMC,EAAmB,CAACzE,EAAGnC,EAAK6G,EAAYC,KAC1CvE,EAAUJ,EAAG,GAAuB2E,EAAO,EAAI,GAAI,GAtQhC9G,EAuQLA,EAvQUC,EAuQL4G,EAvQUE,GAuQE,EAtQ/B9C,EADgB9B,EAuQLA,GArQP4E,IACA7E,EAAUC,EAAGlC,GACbiC,EAAUC,GAAIlC,IAElBkC,EAAEE,YAAY2E,IAAI7E,EAAE8E,OAAOC,SAASlH,EAAKA,EAAMC,GAAMkC,EAAEG,SACvDH,EAAEG,SAAWrC,GAPE,IAACkC,EAAGnC,EAAKC,EAAK8G,EAgUjC,OACII,SAxEahF,IACRwE,IAhVc,MACnB,IAAIrD,EACAD,EACAnD,EACA6C,EACAd,EACJ,MAAMiB,EAAW,IAAIzC,MAAM2C,IAE3B,IADAlD,EAAS,EACJ6C,EAAO,EAAGA,EAAOqE,GAAkBrE,IAEpC,IADAhC,EAAYgC,GAAQ7C,EACfoD,EAAI,EAAGA,EAAI,GAAKnD,EAAY4C,GAAOO,IACpCzC,EAAaX,KAAY6C,EAKjC,IAFAlC,EAAaX,EAAS,GAAK6C,EAC3Bd,EAAO,EACFc,EAAO,EAAGA,EAAO,GAAIA,IAEtB,IADA/B,EAAU+B,GAAQd,EACbqB,EAAI,EAAGA,EAAI,GAAKjD,EAAY0C,GAAOO,IACpC1C,EAAWqB,KAAUc,EAI7B,IADAd,IAAS,EACFc,EApSK,GAoSWA,IAEnB,IADA/B,EAAU+B,GAAQd,GAAQ,EACrBqB,EAAI,EAAGA,EAAI,GAAKjD,EAAY0C,GAAQ,EAAGO,IACxC1C,EAAW,IAAMqB,KAAUc,EAGnC,IAAKM,EAAO,EAAGA,GAvSF,GAuSoBA,IAC7BH,EAASG,GAAQ,EAGrB,IADAC,EAAI,EACGA,GAAK,KACR9C,EAAiB,EAAJ8C,EAAQ,GAAK,EAC1BA,IACAJ,EAAS,KAEb,KAAOI,GAAK,KACR9C,EAAiB,EAAJ8C,EAAQ,GAAK,EAC1BA,IACAJ,EAAS,KAEb,KAAOI,GAAK,KACR9C,EAAiB,EAAJ8C,EAAQ,GAAK,EAC1BA,IACAJ,EAAS,KAEb,KAAOI,GAAK,KACR9C,EAAiB,EAAJ8C,EAAQ,GAAK,EAC1BA,IACAJ,EAAS,KAGb,IADAD,EAAUzC,EAAc6G,IAAanE,GAChCI,EAAI,EAAGA,EAnUA,GAmUaA,IACrB5C,EAAiB,EAAJ4C,EAAQ,GAAK,EAC1B5C,EAAiB,EAAJ4C,GAASR,EAAWQ,EAAG,GAExC7B,EAAgB,IAAIR,EAAeT,EAAcL,EAAaqD,IAxUlDA,IAIC,IAqUb9B,EAAgB,IAAIT,EAAeP,EAAcL,EAAa,EAxUlD,GAGC,IAsUbsB,EAAiB,IAAIV,EAAe,IAAIR,MAAM,GAAIH,EAAc,EAxUnD,GAIG,IAylBZgH,GACAX,GAAmB,GAEvBxE,EAAEoF,OAAS,IAAI3F,EAASO,EAAEsB,UAAWhC,GACrCU,EAAEqF,OAAS,IAAI5F,EAASO,EAAEuB,UAAWhC,GACrCS,EAAEsF,QAAU,IAAI7F,EAASO,EAAEwB,QAAShC,GACpCQ,EAAEO,OAAS,EACXP,EAAEM,SAAW,EACbc,EAAWpB,IA+DXyE,iBAAAA,EACAc,gBArDoB,CAACvF,EAAGnC,EAAK6G,EAAYC,KACzC,IAAIa,EAAUC,EACVC,EAAc,EACd1F,EAAE2F,MAAQ,GAnoBA,IAooBN3F,EAAE4F,KAAKC,YACP7F,EAAE4F,KAAKC,UA7CM7F,CAAAA,IACrB,IACImB,EADA2E,EAAa,WAEjB,IAAK3E,EAAI,EAAGA,GAAK,GAAIA,IAAK2E,KAAgB,EACtC,GAAiB,EAAbA,GAAyC,IAAvB9F,EAAEsB,UAAc,EAAJH,GAC9B,OA/lBK,EAkmBb,GAA2B,IAAvBnB,EAAEsB,UAAU,KAAwC,IAAxBtB,EAAEsB,UAAU,KAAyC,IAAxBtB,EAAEsB,UAAU,IACrE,OAlmBO,EAomBX,IAAKH,EAAI,GAAIA,EAtlBA,IAslBcA,IACvB,GAA2B,IAAvBnB,EAAEsB,UAAc,EAAJH,GACZ,OAtmBG,EAymBX,OA1mBa,GAuoBc4E,CAAiB/F,IAExCkD,EAAWlD,EAAGA,EAAEoF,QAChBlC,EAAWlD,EAAGA,EAAEqF,QAChBK,EAzEc1F,CAAAA,IAClB,IAAI0F,EAIJ,IAHA7B,EAAU7D,EAAGA,EAAEsB,UAAWtB,EAAEoF,OAAOxF,UACnCiE,EAAU7D,EAAGA,EAAEuB,UAAWvB,EAAEqF,OAAOzF,UACnCsD,EAAWlD,EAAGA,EAAEsF,SACXI,EAAcM,GAAcN,GAAe,GACK,IAA7C1F,EAAEwB,QAAgC,EAAxBpD,EAASsH,GAAmB,GADKA,KAMnD,OADA1F,EAAE0B,SAAW,GAAKgE,EAAc,GAAK,EAAI,EAAI,EACtCA,GA8DWO,CAAcjG,GAC5BwF,EAAWxF,EAAE0B,QAAU,EAAI,IAAM,GACjC+D,EAAczF,EAAE2B,WAAa,EAAI,IAAM,IACpB6D,IACfA,EAAWC,IAGfD,EAAWC,EAAcf,EAAa,EAEtCA,EAAa,GAAKc,IAAqB,IAAT3H,EAC9B4G,EAAiBzE,EAAGnC,EAAK6G,EAAYC,GAtpB7B,IAupBD3E,EAAEkG,UAAwBT,IAAgBD,GACjDpF,EAAUJ,EAAG,GAAuB2E,EAAO,EAAI,GAAI,GACnDjC,EAAe1C,EAAG3B,EAAcE,KAEhC6B,EAAUJ,EAAG,GAAoB2E,EAAO,EAAI,GAAI,GA3EjC,EAAC3E,EAAGmG,EAAQC,EAAQC,KACvC,IAAIC,EAIJ,IAHAlG,EAAUJ,EAAGmG,EAAS,IAAK,GAC3B/F,EAAUJ,EAAGoG,EAAS,EAAG,GACzBhG,EAAUJ,EAAGqG,EAAU,EAAG,GACrBC,EAAO,EAAGA,EAAOD,EAASC,IAC3BlG,EAAUJ,EAAGA,EAAEwB,QAAyB,EAAjBpD,EAASkI,GAAY,GAAI,GAEpD/B,EAAUvE,EAAGA,EAAEsB,UAAW6E,EAAS,GACnC5B,EAAUvE,EAAGA,EAAEuB,UAAW6E,EAAS,IAmE/BG,CAAevG,EAAGA,EAAEoF,OAAOxF,SAAW,EAAGI,EAAEqF,OAAOzF,SAAW,EAAG8F,EAAc,GAC9EhD,EAAe1C,EAAGA,EAAEsB,UAAWtB,EAAEuB,YAErCH,EAAWpB,GACP2E,GACA7C,EAAU9B,IAwBdwG,UArBc,CAACxG,EAAGF,EAAM+C,KACxB7C,EAAEE,YAAYF,EAAEgD,MAAqB,EAAbhD,EAAE4B,UAAgB9B,IAAS,EAAI,IACvDE,EAAEE,YAAYF,EAAEgD,MAAqB,EAAbhD,EAAE4B,SAAe,GAAY,IAAP9B,EAC9CE,EAAEE,YAAYF,EAAEiD,MAAQjD,EAAE4B,UAAiB,IAALiB,EACtC7C,EAAE4B,WACW,IAAT9B,EACAE,EAAEsB,UAAe,EAALuB,MAEZ7C,EAAE6B,UACF/B,IACAE,EAAEsB,UAA8C,GAAnC5C,EAAamE,GA9pBjB,IA8pBkC,MAC3C7C,EAAEuB,UAAyB,EAAf1B,EAAOC,OAEhBE,EAAE4B,WAAa5B,EAAEyG,YAAc,GAStCC,UA5Dc1G,IACdI,EAAUJ,EAAG2G,EAAmB,GAChCnG,EAAUR,EAxmBI,IAwmBU3B,GAhcX2B,CAAAA,IACM,KAAfA,EAAEM,UACFP,EAAUC,EAAGA,EAAEO,QACfP,EAAEO,OAAS,EACXP,EAAEM,SAAW,GACNN,EAAEM,UAAY,IACrBN,EAAEE,YAAYF,EAAEG,WAAwB,IAAXH,EAAEO,OAC/BP,EAAEO,SAAW,EACbP,EAAEM,UAAY,IAyblBsG,CAAS5G","file":"../../zlib/trees.js","sourcesContent":["define([], function () {\n    'use strict';\n\n    const Z_FIXED = 4;\n    const Z_BINARY = 0;\n    const Z_TEXT = 1;\n    const Z_UNKNOWN = 2;\n    function zero(buf) {\n        let len = buf.length;\n        while (--len >= 0) {\n            buf[len] = 0;\n        }\n    }\n    const STORED_BLOCK = 0;\n    const STATIC_TREES = 1;\n    const DYN_TREES = 2;\n    const MIN_MATCH = 3;\n    const MAX_MATCH = 258;\n    const LENGTH_CODES = 29;\n    const LITERALS = 256;\n    const L_CODES = LITERALS + 1 + LENGTH_CODES;\n    const D_CODES = 30;\n    const BL_CODES = 19;\n    const HEAP_SIZE = 2 * L_CODES + 1;\n    const MAX_BITS = 15;\n    const Buf_size = 16;\n    const MAX_BL_BITS = 7;\n    const END_BLOCK = 256;\n    const REP_3_6 = 16;\n    const REPZ_3_10 = 17;\n    const REPZ_11_138 = 18;\n    const extra_lbits = new Uint8Array([\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        1,\n        1,\n        1,\n        2,\n        2,\n        2,\n        2,\n        3,\n        3,\n        3,\n        3,\n        4,\n        4,\n        4,\n        4,\n        5,\n        5,\n        5,\n        5,\n        0\n    ]);\n    const extra_dbits = new Uint8Array([\n        0,\n        0,\n        0,\n        0,\n        1,\n        1,\n        2,\n        2,\n        3,\n        3,\n        4,\n        4,\n        5,\n        5,\n        6,\n        6,\n        7,\n        7,\n        8,\n        8,\n        9,\n        9,\n        10,\n        10,\n        11,\n        11,\n        12,\n        12,\n        13,\n        13\n    ]);\n    const extra_blbits = new Uint8Array([\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        2,\n        3,\n        7\n    ]);\n    const bl_order = new Uint8Array([\n        16,\n        17,\n        18,\n        0,\n        8,\n        7,\n        9,\n        6,\n        10,\n        5,\n        11,\n        4,\n        12,\n        3,\n        13,\n        2,\n        14,\n        1,\n        15\n    ]);\n    const DIST_CODE_LEN = 512;\n    const static_ltree = new Array((L_CODES + 2) * 2);\n    zero(static_ltree);\n    const static_dtree = new Array(D_CODES * 2);\n    zero(static_dtree);\n    const _dist_code = new Array(DIST_CODE_LEN);\n    zero(_dist_code);\n    const _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);\n    zero(_length_code);\n    const base_length = new Array(LENGTH_CODES);\n    zero(base_length);\n    const base_dist = new Array(D_CODES);\n    zero(base_dist);\n    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n        this.static_tree = static_tree;\n        this.extra_bits = extra_bits;\n        this.extra_base = extra_base;\n        this.elems = elems;\n        this.max_length = max_length;\n        this.has_stree = static_tree && static_tree.length;\n    }\n    let static_l_desc;\n    let static_d_desc;\n    let static_bl_desc;\n    function TreeDesc(dyn_tree, stat_desc) {\n        this.dyn_tree = dyn_tree;\n        this.max_code = 0;\n        this.stat_desc = stat_desc;\n    }\n    const d_code = dist => {\n        return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n    };\n    const put_short = (s, w) => {\n        s.pending_buf[s.pending++] = w & 255;\n        s.pending_buf[s.pending++] = w >>> 8 & 255;\n    };\n    const send_bits = (s, value, length) => {\n        if (s.bi_valid > Buf_size - length) {\n            s.bi_buf |= value << s.bi_valid & 65535;\n            put_short(s, s.bi_buf);\n            s.bi_buf = value >> Buf_size - s.bi_valid;\n            s.bi_valid += length - Buf_size;\n        } else {\n            s.bi_buf |= value << s.bi_valid & 65535;\n            s.bi_valid += length;\n        }\n    };\n    const send_code = (s, c, tree) => {\n        send_bits(s, tree[c * 2], tree[c * 2 + 1]);\n    };\n    const bi_reverse = (code, len) => {\n        let res = 0;\n        do {\n            res |= code & 1;\n            code >>>= 1;\n            res <<= 1;\n        } while (--len > 0);\n        return res >>> 1;\n    };\n    const bi_flush = s => {\n        if (s.bi_valid === 16) {\n            put_short(s, s.bi_buf);\n            s.bi_buf = 0;\n            s.bi_valid = 0;\n        } else if (s.bi_valid >= 8) {\n            s.pending_buf[s.pending++] = s.bi_buf & 255;\n            s.bi_buf >>= 8;\n            s.bi_valid -= 8;\n        }\n    };\n    const gen_bitlen = (s, desc) => {\n        const tree = desc.dyn_tree;\n        const max_code = desc.max_code;\n        const stree = desc.stat_desc.static_tree;\n        const has_stree = desc.stat_desc.has_stree;\n        const extra = desc.stat_desc.extra_bits;\n        const base = desc.stat_desc.extra_base;\n        const max_length = desc.stat_desc.max_length;\n        let h;\n        let n, m;\n        let bits;\n        let xbits;\n        let f;\n        let overflow = 0;\n        for (bits = 0; bits <= MAX_BITS; bits++) {\n            s.bl_count[bits] = 0;\n        }\n        tree[s.heap[s.heap_max] * 2 + 1] = 0;\n        for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n            n = s.heap[h];\n            bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;\n            if (bits > max_length) {\n                bits = max_length;\n                overflow++;\n            }\n            tree[n * 2 + 1] = bits;\n            if (n > max_code) {\n                continue;\n            }\n            s.bl_count[bits]++;\n            xbits = 0;\n            if (n >= base) {\n                xbits = extra[n - base];\n            }\n            f = tree[n * 2];\n            s.opt_len += f * (bits + xbits);\n            if (has_stree) {\n                s.static_len += f * (stree[n * 2 + 1] + xbits);\n            }\n        }\n        if (overflow === 0) {\n            return;\n        }\n        do {\n            bits = max_length - 1;\n            while (s.bl_count[bits] === 0) {\n                bits--;\n            }\n            s.bl_count[bits]--;\n            s.bl_count[bits + 1] += 2;\n            s.bl_count[max_length]--;\n            overflow -= 2;\n        } while (overflow > 0);\n        for (bits = max_length; bits !== 0; bits--) {\n            n = s.bl_count[bits];\n            while (n !== 0) {\n                m = s.heap[--h];\n                if (m > max_code) {\n                    continue;\n                }\n                if (tree[m * 2 + 1] !== bits) {\n                    s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];\n                    tree[m * 2 + 1] = bits;\n                }\n                n--;\n            }\n        }\n    };\n    const gen_codes = (tree, max_code, bl_count) => {\n        const next_code = new Array(MAX_BITS + 1);\n        let code = 0;\n        let bits;\n        let n;\n        for (bits = 1; bits <= MAX_BITS; bits++) {\n            next_code[bits] = code = code + bl_count[bits - 1] << 1;\n        }\n        for (n = 0; n <= max_code; n++) {\n            let len = tree[n * 2 + 1];\n            if (len === 0) {\n                continue;\n            }\n            tree[n * 2] = bi_reverse(next_code[len]++, len);\n        }\n    };\n    const tr_static_init = () => {\n        let n;\n        let bits;\n        let length;\n        let code;\n        let dist;\n        const bl_count = new Array(MAX_BITS + 1);\n        length = 0;\n        for (code = 0; code < LENGTH_CODES - 1; code++) {\n            base_length[code] = length;\n            for (n = 0; n < 1 << extra_lbits[code]; n++) {\n                _length_code[length++] = code;\n            }\n        }\n        _length_code[length - 1] = code;\n        dist = 0;\n        for (code = 0; code < 16; code++) {\n            base_dist[code] = dist;\n            for (n = 0; n < 1 << extra_dbits[code]; n++) {\n                _dist_code[dist++] = code;\n            }\n        }\n        dist >>= 7;\n        for (; code < D_CODES; code++) {\n            base_dist[code] = dist << 7;\n            for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {\n                _dist_code[256 + dist++] = code;\n            }\n        }\n        for (bits = 0; bits <= MAX_BITS; bits++) {\n            bl_count[bits] = 0;\n        }\n        n = 0;\n        while (n <= 143) {\n            static_ltree[n * 2 + 1] = 8;\n            n++;\n            bl_count[8]++;\n        }\n        while (n <= 255) {\n            static_ltree[n * 2 + 1] = 9;\n            n++;\n            bl_count[9]++;\n        }\n        while (n <= 279) {\n            static_ltree[n * 2 + 1] = 7;\n            n++;\n            bl_count[7]++;\n        }\n        while (n <= 287) {\n            static_ltree[n * 2 + 1] = 8;\n            n++;\n            bl_count[8]++;\n        }\n        gen_codes(static_ltree, L_CODES + 1, bl_count);\n        for (n = 0; n < D_CODES; n++) {\n            static_dtree[n * 2 + 1] = 5;\n            static_dtree[n * 2] = bi_reverse(n, 5);\n        }\n        static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n        static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);\n        static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);\n    };\n    const init_block = s => {\n        let n;\n        for (n = 0; n < L_CODES; n++) {\n            s.dyn_ltree[n * 2] = 0;\n        }\n        for (n = 0; n < D_CODES; n++) {\n            s.dyn_dtree[n * 2] = 0;\n        }\n        for (n = 0; n < BL_CODES; n++) {\n            s.bl_tree[n * 2] = 0;\n        }\n        s.dyn_ltree[END_BLOCK * 2] = 1;\n        s.opt_len = s.static_len = 0;\n        s.last_lit = s.matches = 0;\n    };\n    const bi_windup = s => {\n        if (s.bi_valid > 8) {\n            put_short(s, s.bi_buf);\n        } else if (s.bi_valid > 0) {\n            s.pending_buf[s.pending++] = s.bi_buf;\n        }\n        s.bi_buf = 0;\n        s.bi_valid = 0;\n    };\n    const copy_block = (s, buf, len, header) => {\n        bi_windup(s);\n        if (header) {\n            put_short(s, len);\n            put_short(s, ~len);\n        }\n        s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);\n        s.pending += len;\n    };\n    const smaller = (tree, n, m, depth) => {\n        const _n2 = n * 2;\n        const _m2 = m * 2;\n        return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];\n    };\n    const pqdownheap = (s, tree, k) => {\n        const v = s.heap[k];\n        let j = k << 1;\n        while (j <= s.heap_len) {\n            if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n                j++;\n            }\n            if (smaller(tree, v, s.heap[j], s.depth)) {\n                break;\n            }\n            s.heap[k] = s.heap[j];\n            k = j;\n            j <<= 1;\n        }\n        s.heap[k] = v;\n    };\n    const compress_block = (s, ltree, dtree) => {\n        let dist;\n        let lc;\n        let lx = 0;\n        let code;\n        let extra;\n        if (s.last_lit !== 0) {\n            do {\n                dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];\n                lc = s.pending_buf[s.l_buf + lx];\n                lx++;\n                if (dist === 0) {\n                    send_code(s, lc, ltree);\n                } else {\n                    code = _length_code[lc];\n                    send_code(s, code + LITERALS + 1, ltree);\n                    extra = extra_lbits[code];\n                    if (extra !== 0) {\n                        lc -= base_length[code];\n                        send_bits(s, lc, extra);\n                    }\n                    dist--;\n                    code = d_code(dist);\n                    send_code(s, code, dtree);\n                    extra = extra_dbits[code];\n                    if (extra !== 0) {\n                        dist -= base_dist[code];\n                        send_bits(s, dist, extra);\n                    }\n                }\n            } while (lx < s.last_lit);\n        }\n        send_code(s, END_BLOCK, ltree);\n    };\n    const build_tree = (s, desc) => {\n        const tree = desc.dyn_tree;\n        const stree = desc.stat_desc.static_tree;\n        const has_stree = desc.stat_desc.has_stree;\n        const elems = desc.stat_desc.elems;\n        let n, m;\n        let max_code = -1;\n        let node;\n        s.heap_len = 0;\n        s.heap_max = HEAP_SIZE;\n        for (n = 0; n < elems; n++) {\n            if (tree[n * 2] !== 0) {\n                s.heap[++s.heap_len] = max_code = n;\n                s.depth[n] = 0;\n            } else {\n                tree[n * 2 + 1] = 0;\n            }\n        }\n        while (s.heap_len < 2) {\n            node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;\n            tree[node * 2] = 1;\n            s.depth[node] = 0;\n            s.opt_len--;\n            if (has_stree) {\n                s.static_len -= stree[node * 2 + 1];\n            }\n        }\n        desc.max_code = max_code;\n        for (n = s.heap_len >> 1; n >= 1; n--) {\n            pqdownheap(s, tree, n);\n        }\n        node = elems;\n        do {\n            n = s.heap[1];\n            s.heap[1] = s.heap[s.heap_len--];\n            pqdownheap(s, tree, 1);\n            m = s.heap[1];\n            s.heap[--s.heap_max] = n;\n            s.heap[--s.heap_max] = m;\n            tree[node * 2] = tree[n * 2] + tree[m * 2];\n            s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n            tree[n * 2 + 1] = tree[m * 2 + 1] = node;\n            s.heap[1] = node++;\n            pqdownheap(s, tree, 1);\n        } while (s.heap_len >= 2);\n        s.heap[--s.heap_max] = s.heap[1];\n        gen_bitlen(s, desc);\n        gen_codes(tree, max_code, s.bl_count);\n    };\n    const scan_tree = (s, tree, max_code) => {\n        let n;\n        let prevlen = -1;\n        let curlen;\n        let nextlen = tree[0 * 2 + 1];\n        let count = 0;\n        let max_count = 7;\n        let min_count = 4;\n        if (nextlen === 0) {\n            max_count = 138;\n            min_count = 3;\n        }\n        tree[(max_code + 1) * 2 + 1] = 65535;\n        for (n = 0; n <= max_code; n++) {\n            curlen = nextlen;\n            nextlen = tree[(n + 1) * 2 + 1];\n            if (++count < max_count && curlen === nextlen) {\n                continue;\n            } else if (count < min_count) {\n                s.bl_tree[curlen * 2] += count;\n            } else if (curlen !== 0) {\n                if (curlen !== prevlen) {\n                    s.bl_tree[curlen * 2]++;\n                }\n                s.bl_tree[REP_3_6 * 2]++;\n            } else if (count <= 10) {\n                s.bl_tree[REPZ_3_10 * 2]++;\n            } else {\n                s.bl_tree[REPZ_11_138 * 2]++;\n            }\n            count = 0;\n            prevlen = curlen;\n            if (nextlen === 0) {\n                max_count = 138;\n                min_count = 3;\n            } else if (curlen === nextlen) {\n                max_count = 6;\n                min_count = 3;\n            } else {\n                max_count = 7;\n                min_count = 4;\n            }\n        }\n    };\n    const send_tree = (s, tree, max_code) => {\n        let n;\n        let prevlen = -1;\n        let curlen;\n        let nextlen = tree[0 * 2 + 1];\n        let count = 0;\n        let max_count = 7;\n        let min_count = 4;\n        if (nextlen === 0) {\n            max_count = 138;\n            min_count = 3;\n        }\n        for (n = 0; n <= max_code; n++) {\n            curlen = nextlen;\n            nextlen = tree[(n + 1) * 2 + 1];\n            if (++count < max_count && curlen === nextlen) {\n                continue;\n            } else if (count < min_count) {\n                do {\n                    send_code(s, curlen, s.bl_tree);\n                } while (--count !== 0);\n            } else if (curlen !== 0) {\n                if (curlen !== prevlen) {\n                    send_code(s, curlen, s.bl_tree);\n                    count--;\n                }\n                send_code(s, REP_3_6, s.bl_tree);\n                send_bits(s, count - 3, 2);\n            } else if (count <= 10) {\n                send_code(s, REPZ_3_10, s.bl_tree);\n                send_bits(s, count - 3, 3);\n            } else {\n                send_code(s, REPZ_11_138, s.bl_tree);\n                send_bits(s, count - 11, 7);\n            }\n            count = 0;\n            prevlen = curlen;\n            if (nextlen === 0) {\n                max_count = 138;\n                min_count = 3;\n            } else if (curlen === nextlen) {\n                max_count = 6;\n                min_count = 3;\n            } else {\n                max_count = 7;\n                min_count = 4;\n            }\n        }\n    };\n    const build_bl_tree = s => {\n        let max_blindex;\n        scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n        scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n        build_tree(s, s.bl_desc);\n        for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n            if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {\n                break;\n            }\n        }\n        s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n        return max_blindex;\n    };\n    const send_all_trees = (s, lcodes, dcodes, blcodes) => {\n        let rank;\n        send_bits(s, lcodes - 257, 5);\n        send_bits(s, dcodes - 1, 5);\n        send_bits(s, blcodes - 4, 4);\n        for (rank = 0; rank < blcodes; rank++) {\n            send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);\n        }\n        send_tree(s, s.dyn_ltree, lcodes - 1);\n        send_tree(s, s.dyn_dtree, dcodes - 1);\n    };\n    const detect_data_type = s => {\n        let black_mask = 4093624447;\n        let n;\n        for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n            if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {\n                return Z_BINARY;\n            }\n        }\n        if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {\n            return Z_TEXT;\n        }\n        for (n = 32; n < LITERALS; n++) {\n            if (s.dyn_ltree[n * 2] !== 0) {\n                return Z_TEXT;\n            }\n        }\n        return Z_BINARY;\n    };\n    let static_init_done = false;\n    const _tr_init = s => {\n        if (!static_init_done) {\n            tr_static_init();\n            static_init_done = true;\n        }\n        s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);\n        s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);\n        s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n        s.bi_buf = 0;\n        s.bi_valid = 0;\n        init_block(s);\n    };\n    const _tr_stored_block = (s, buf, stored_len, last) => {\n        send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);\n        copy_block(s, buf, stored_len, true);\n    };\n    const _tr_align = s => {\n        send_bits(s, STATIC_TREES << 1, 3);\n        send_code(s, END_BLOCK, static_ltree);\n        bi_flush(s);\n    };\n    const _tr_flush_block = (s, buf, stored_len, last) => {\n        let opt_lenb, static_lenb;\n        let max_blindex = 0;\n        if (s.level > 0) {\n            if (s.strm.data_type === Z_UNKNOWN) {\n                s.strm.data_type = detect_data_type(s);\n            }\n            build_tree(s, s.l_desc);\n            build_tree(s, s.d_desc);\n            max_blindex = build_bl_tree(s);\n            opt_lenb = s.opt_len + 3 + 7 >>> 3;\n            static_lenb = s.static_len + 3 + 7 >>> 3;\n            if (static_lenb <= opt_lenb) {\n                opt_lenb = static_lenb;\n            }\n        } else {\n            opt_lenb = static_lenb = stored_len + 5;\n        }\n        if (stored_len + 4 <= opt_lenb && buf !== -1) {\n            _tr_stored_block(s, buf, stored_len, last);\n        } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n            send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n            compress_block(s, static_ltree, static_dtree);\n        } else {\n            send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n            send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n            compress_block(s, s.dyn_ltree, s.dyn_dtree);\n        }\n        init_block(s);\n        if (last) {\n            bi_windup(s);\n        }\n    };\n    const _tr_tally = (s, dist, lc) => {\n        s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;\n        s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;\n        s.pending_buf[s.l_buf + s.last_lit] = lc & 255;\n        s.last_lit++;\n        if (dist === 0) {\n            s.dyn_ltree[lc * 2]++;\n        } else {\n            s.matches++;\n            dist--;\n            s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;\n            s.dyn_dtree[d_code(dist) * 2]++;\n        }\n        return s.last_lit === s.lit_bufsize - 1;\n    };\n\n\n    return {\n        _tr_init,\n        _tr_stored_block,\n        _tr_flush_block,\n        _tr_tally,\n        _tr_align\n    };\n\n\n});"]}