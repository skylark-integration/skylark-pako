{"version":3,"sources":["zlib/deflate.js"],"names":["define","trees","adler32","crc32","msg","constants","_tr_init","_tr_stored_block","_tr_flush_block","_tr_tally","_tr_align","Z_NO_FLUSH","Z_PARTIAL_FLUSH","Z_FULL_FLUSH","Z_FINISH","Z_BLOCK","Z_OK","Z_STREAM_END","Z_STREAM_ERROR","Z_DATA_ERROR","Z_BUF_ERROR","Z_DEFAULT_COMPRESSION","Z_FILTERED","Z_HUFFMAN_ONLY","Z_RLE","Z_FIXED","Z_DEFAULT_STRATEGY","Z_UNKNOWN","Z_DEFLATED","L_CODES","LITERALS","D_CODES","BL_CODES","HEAP_SIZE","MAX_BITS","err","strm","errorCode","rank","f","zero","buf","len","length","HASH","s","prev","data","hash_shift","hash_mask","flush_pending","state","pending","avail_out","output","set","pending_buf","subarray","pending_out","next_out","total_out","flush_block_only","last","block_start","strstart","put_byte","b","putShortMSB","read_buf","start","size","avail_in","input","next_in","wrap","adler","total_in","longest_match","cur_match","match","chain_length","max_chain_length","scan","best_len","prev_length","nice_match","limit","w_size","_win","window","wmask","w_mask","strend","scan_end1","scan_end","good_match","lookahead","match_start","fill_window","_w_size","p","n","m","more","str","window_size","hash_size","head","insert","ins_h","deflate_fast","flush","hash_head","bflush","match_length","max_lazy_match","MIN_MATCH","last_lit","deflate_slow","max_insert","prev_match","strategy","match_available","Config","good_length","max_lazy","nice_length","max_chain","func","this","configuration_table","max_block_size","pending_buf_size","max_start","deflateResetKeep","data_type","status","last_flush","deflateReset","ret","level","deflateInit2","method","windowBits","memLevel","gzhead","gzindex","w_bits","hash_bits","dyn_ltree","Uint16Array","dyn_dtree","bl_tree","l_desc","d_desc","bl_desc","bl_count","heap","heap_len","heap_max","depth","l_buf","lit_bufsize","d_buf","opt_len","static_len","matches","bi_buf","bi_valid","Uint8Array","deflateInit","deflateSetHeader","deflate","beg","val","old_flush","text","hcrc","extra","name","comment","time","os","header","level_flags","charCodeAt","bstate","deflate_huff","deflate_rle","deflateEnd","deflateSetDictionary","dictionary","dictLength","tmpDict","avail","next","deflateInfo"],"mappings":"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","file":"../../zlib/deflate.js","sourcesContent":["define([\n    './trees',\n    './adler32',\n    './crc32',\n    './messages',\n    './constants'\n], function (trees, adler32, crc32, msg, constants) {\n    'use strict';\n    // Original version : zlib 1.2.8\n    // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n\n\n    const {\n        _tr_init, \n        _tr_stored_block, \n        _tr_flush_block, \n        _tr_tally, \n        _tr_align\n    } = trees;\n\n    /* Public constants ==========================================================*/\n    /* ===========================================================================*/\n    const {\n        Z_NO_FLUSH, \n        Z_PARTIAL_FLUSH, \n        Z_FULL_FLUSH, \n        Z_FINISH, \n        Z_BLOCK, \n        Z_OK, \n        Z_STREAM_END, \n        Z_STREAM_ERROR, \n        Z_DATA_ERROR, \n        Z_BUF_ERROR, \n        Z_DEFAULT_COMPRESSION, \n        Z_FILTERED, \n        Z_HUFFMAN_ONLY, \n        Z_RLE, Z_FIXED, \n        Z_DEFAULT_STRATEGY, \n        Z_UNKNOWN, \n        Z_DEFLATED\n    } = constants;\n    /*============================================================================*/\n\n\n    const MAX_MEM_LEVEL = 9;\n    /* Maximum value for memLevel in deflateInit2 */\n    const MAX_WBITS = 15;\n    /* 32K LZ77 window */\n    const DEF_MEM_LEVEL = 8;\n\n\n    const LENGTH_CODES  = 29;\n    /* number of length codes, not counting the special END_BLOCK code */\n    const LITERALS      = 256;\n    /* number of literal bytes 0..255 */\n    const L_CODES       = LITERALS + 1 + LENGTH_CODES;\n    /* number of Literal or Length codes, including the END_BLOCK code */\n    const D_CODES       = 30;\n    /* number of distance codes */\n    const BL_CODES      = 19;\n    /* number of codes used to transfer the bit lengths */\n    const HEAP_SIZE     = 2 * L_CODES + 1;\n    /* maximum heap size */\n    const MAX_BITS  = 15;\n    /* All codes must not exceed MAX_BITS bits */\n\n    const MIN_MATCH = 3;\n    const MAX_MATCH = 258;\n    const MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n\n    const PRESET_DICT = 0x20;\n\n    const INIT_STATE = 42;\n    const EXTRA_STATE = 69;\n    const NAME_STATE = 73;\n    const COMMENT_STATE = 91;\n    const HCRC_STATE = 103;\n    const BUSY_STATE = 113;\n    const FINISH_STATE = 666;\n\n    const BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\n    const BS_BLOCK_DONE     = 2; /* block flush performed */\n    const BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\n    const BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\n\n    const OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\n    const err = (strm, errorCode) => {\n      strm.msg = msg[errorCode];\n      return errorCode;\n    };\n\n    const rank = (f) => {\n      return ((f) << 1) - ((f) > 4 ? 9 : 0);\n    };\n\n    const zero = (buf) => {\n      let len = buf.length; while (--len >= 0) { buf[len] = 0; }\n    };\n\n\n    /* eslint-disable new-cap */\n    let HASH_ZLIB = (s, prev, data) => ((prev << s.hash_shift) ^ data) & s.hash_mask;\n    // This hash causes less collisions, https://github.com/nodeca/pako/issues/135\n    // But breaks binary compatibility\n    //let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;\n    let HASH = HASH_ZLIB;\n\n    /* =========================================================================\n     * Flush as much pending output as possible. All deflate() output goes\n     * through this function so some applications may wish to modify it\n     * to avoid allocating a large strm->output buffer and copying into it.\n     * (See also read_buf()).\n     */\n    const flush_pending = (strm) => {\n      const s = strm.state;\n\n      //_tr_flush_bits(s);\n      let len = s.pending;\n      if (len > strm.avail_out) {\n        len = strm.avail_out;\n      }\n      if (len === 0) { return; }\n\n      strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);\n      strm.next_out += len;\n      s.pending_out += len;\n      strm.total_out += len;\n      strm.avail_out -= len;\n      s.pending -= len;\n      if (s.pending === 0) {\n        s.pending_out = 0;\n      }\n    };\n\n\n    const flush_block_only = (s, last) => {\n      _tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\n      s.block_start = s.strstart;\n      flush_pending(s.strm);\n    };\n\n\n    const put_byte = (s, b) => {\n      s.pending_buf[s.pending++] = b;\n    };\n\n\n    /* =========================================================================\n     * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n     * IN assertion: the stream state is correct and there is enough room in\n     * pending_buf.\n     */\n    const putShortMSB = (s, b) => {\n\n      //  put_byte(s, (Byte)(b >> 8));\n    //  put_byte(s, (Byte)(b & 0xff));\n      s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n      s.pending_buf[s.pending++] = b & 0xff;\n    };\n\n\n    /* ===========================================================================\n     * Read a new buffer from the current input stream, update the adler32\n     * and total number of bytes read.  All deflate() input goes through\n     * this function so some applications may wish to modify it to avoid\n     * allocating a large strm->input buffer and copying from it.\n     * (See also flush_pending()).\n     */\n    const read_buf = (strm, buf, start, size) => {\n\n      let len = strm.avail_in;\n\n      if (len > size) { len = size; }\n      if (len === 0) { return 0; }\n\n      strm.avail_in -= len;\n\n      // zmemcpy(buf, strm->next_in, len);\n      buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);\n      if (strm.state.wrap === 1) {\n        strm.adler = adler32(strm.adler, buf, len, start);\n      }\n\n      else if (strm.state.wrap === 2) {\n        strm.adler = crc32(strm.adler, buf, len, start);\n      }\n\n      strm.next_in += len;\n      strm.total_in += len;\n\n      return len;\n    };\n\n\n    /* ===========================================================================\n     * Set match_start to the longest match starting at the given string and\n     * return its length. Matches shorter or equal to prev_length are discarded,\n     * in which case the result is equal to prev_length and match_start is\n     * garbage.\n     * IN assertions: cur_match is the head of the hash chain for the current\n     *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n     * OUT assertion: the match length is not greater than s->lookahead.\n     */\n    const longest_match = (s, cur_match) => {\n\n      let chain_length = s.max_chain_length;      /* max hash chain length */\n      let scan = s.strstart; /* current string */\n      let match;                       /* matched string */\n      let len;                           /* length of current match */\n      let best_len = s.prev_length;              /* best match length so far */\n      let nice_match = s.nice_match;             /* stop if match long enough */\n      const limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\n          s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\n\n      const _win = s.window; // shortcut\n\n      const wmask = s.w_mask;\n      const prev  = s.prev;\n\n      /* Stop when cur_match becomes <= limit. To simplify the code,\n       * we prevent matches with the string of window index 0.\n       */\n\n      const strend = s.strstart + MAX_MATCH;\n      let scan_end1  = _win[scan + best_len - 1];\n      let scan_end   = _win[scan + best_len];\n\n      /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n       * It is easy to get rid of this optimization if necessary.\n       */\n      // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n      /* Do not waste too much time if we already have a good match: */\n      if (s.prev_length >= s.good_match) {\n        chain_length >>= 2;\n      }\n      /* Do not look for matches beyond the end of the input. This is necessary\n       * to make deflate deterministic.\n       */\n      if (nice_match > s.lookahead) { nice_match = s.lookahead; }\n\n      // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n      do {\n        // Assert(cur_match < s->strstart, \"no future\");\n        match = cur_match;\n\n        /* Skip to next match if the match length cannot increase\n         * or if the match length is less than 2.  Note that the checks below\n         * for insufficient lookahead only occur occasionally for performance\n         * reasons.  Therefore uninitialized memory will be accessed, and\n         * conditional jumps will be made that depend on those values.\n         * However the length of the match is limited to the lookahead, so\n         * the output of deflate is not affected by the uninitialized values.\n         */\n\n        if (_win[match + best_len]     !== scan_end  ||\n            _win[match + best_len - 1] !== scan_end1 ||\n            _win[match]                !== _win[scan] ||\n            _win[++match]              !== _win[scan + 1]) {\n          continue;\n        }\n\n        /* The check at best_len-1 can be removed because it will be made\n         * again later. (This heuristic is not always a win.)\n         * It is not necessary to compare scan[2] and match[2] since they\n         * are always equal when the other bytes match, given that\n         * the hash keys are equal and that HASH_BITS >= 8.\n         */\n        scan += 2;\n        match++;\n        // Assert(*scan == *match, \"match[2]?\");\n\n        /* We check for insufficient lookahead only every 8th comparison;\n         * the 256th check will be made at strstart+258.\n         */\n        do {\n          /*jshint noempty:false*/\n        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n                 _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n                 _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n                 _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n                 scan < strend);\n\n        // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n        len = MAX_MATCH - (strend - scan);\n        scan = strend - MAX_MATCH;\n\n        if (len > best_len) {\n          s.match_start = cur_match;\n          best_len = len;\n          if (len >= nice_match) {\n            break;\n          }\n          scan_end1  = _win[scan + best_len - 1];\n          scan_end   = _win[scan + best_len];\n        }\n      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n      if (best_len <= s.lookahead) {\n        return best_len;\n      }\n      return s.lookahead;\n    };\n\n\n    /* ===========================================================================\n     * Fill the window when the lookahead becomes insufficient.\n     * Updates strstart and lookahead.\n     *\n     * IN assertion: lookahead < MIN_LOOKAHEAD\n     * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n     *    At least one byte has been read, or avail_in == 0; reads are\n     *    performed for at least two bytes (required for the zip translate_eol\n     *    option -- not supported here).\n     */\n    const fill_window = (s) => {\n\n      const _w_size = s.w_size;\n      let p, n, m, more, str;\n\n      //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n      do {\n        more = s.window_size - s.lookahead - s.strstart;\n\n        // JS ints have 32 bit, block below not needed\n        /* Deal with !@#$% 64K limit: */\n        //if (sizeof(int) <= 2) {\n        //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n        //        more = wsize;\n        //\n        //  } else if (more == (unsigned)(-1)) {\n        //        /* Very unlikely, but possible on 16 bit machine if\n        //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n        //         */\n        //        more--;\n        //    }\n        //}\n\n\n        /* If the window is almost full and there is insufficient lookahead,\n         * move the upper half to the lower one to make room in the upper half.\n         */\n        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n\n          s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);\n          s.match_start -= _w_size;\n          s.strstart -= _w_size;\n          /* we now have strstart >= MAX_DIST */\n          s.block_start -= _w_size;\n\n          /* Slide the hash table (could be avoided with 32 bit values\n           at the expense of memory usage). We slide even when level == 0\n           to keep the hash table consistent if we switch back to level > 0\n           later. (Using level 0 permanently is not an optimal usage of\n           zlib, so we don't care about this pathological case.)\n           */\n\n          n = s.hash_size;\n          p = n;\n\n          do {\n            m = s.head[--p];\n            s.head[p] = (m >= _w_size ? m - _w_size : 0);\n          } while (--n);\n\n          n = _w_size;\n          p = n;\n\n          do {\n            m = s.prev[--p];\n            s.prev[p] = (m >= _w_size ? m - _w_size : 0);\n            /* If n is not on any hash chain, prev[n] is garbage but\n             * its value will never be used.\n             */\n          } while (--n);\n\n          more += _w_size;\n        }\n        if (s.strm.avail_in === 0) {\n          break;\n        }\n\n        /* If there was no sliding:\n         *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n         *    more == window_size - lookahead - strstart\n         * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n         * => more >= window_size - 2*WSIZE + 2\n         * In the BIG_MEM or MMAP case (not yet supported),\n         *   window_size == input_size + MIN_LOOKAHEAD  &&\n         *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n         * Otherwise, window_size == 2*WSIZE so more >= 2.\n         * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n         */\n        //Assert(more >= 2, \"more < 2\");\n        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n        s.lookahead += n;\n\n        /* Initialize the hash value now that we have some input: */\n        if (s.lookahead + s.insert >= MIN_MATCH) {\n          str = s.strstart - s.insert;\n          s.ins_h = s.window[str];\n\n          /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n          s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);\n    //#if MIN_MATCH != 3\n    //        Call update_hash() MIN_MATCH-3 more times\n    //#endif\n          while (s.insert) {\n            /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n            s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);\n\n            s.prev[str & s.w_mask] = s.head[s.ins_h];\n            s.head[s.ins_h] = str;\n            str++;\n            s.insert--;\n            if (s.lookahead + s.insert < MIN_MATCH) {\n              break;\n            }\n          }\n        }\n        /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n         * but this is not important since only literal bytes will be emitted.\n         */\n\n      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n\n      /* If the WIN_INIT bytes after the end of the current data have never been\n       * written, then zero those bytes in order to avoid memory check reports of\n       * the use of uninitialized (or uninitialised as Julian writes) bytes by\n       * the longest match routines.  Update the high water mark for the next\n       * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n       * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n       */\n    //  if (s.high_water < s.window_size) {\n    //    const curr = s.strstart + s.lookahead;\n    //    let init = 0;\n    //\n    //    if (s.high_water < curr) {\n    //      /* Previous high water mark below current data -- zero WIN_INIT\n    //       * bytes or up to end of window, whichever is less.\n    //       */\n    //      init = s.window_size - curr;\n    //      if (init > WIN_INIT)\n    //        init = WIN_INIT;\n    //      zmemzero(s->window + curr, (unsigned)init);\n    //      s->high_water = curr + init;\n    //    }\n    //    else if (s->high_water < (ulg)curr + WIN_INIT) {\n    //      /* High water mark at or above current data, but below current data\n    //       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n    //       * to end of window, whichever is less.\n    //       */\n    //      init = (ulg)curr + WIN_INIT - s->high_water;\n    //      if (init > s->window_size - s->high_water)\n    //        init = s->window_size - s->high_water;\n    //      zmemzero(s->window + s->high_water, (unsigned)init);\n    //      s->high_water += init;\n    //    }\n    //  }\n    //\n    //  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n    //    \"not enough room for search\");\n    };\n\n    /* ===========================================================================\n     * Copy without compression as much as possible from the input stream, return\n     * the current block state.\n     * This function does not insert new strings in the dictionary since\n     * uncompressible data is probably not useful. This function is used\n     * only for the level=0 compression option.\n     * NOTE: this function should be optimized to avoid extra copying from\n     * window to pending_buf.\n     */\n    const deflate_stored = (s, flush) => {\n\n      /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n       * to pending_buf_size, and each stored block has a 5 byte header:\n       */\n      let max_block_size = 0xffff;\n\n      if (max_block_size > s.pending_buf_size - 5) {\n        max_block_size = s.pending_buf_size - 5;\n      }\n\n      /* Copy as much as possible from input to output: */\n      for (;;) {\n        /* Fill the window as much as possible: */\n        if (s.lookahead <= 1) {\n\n          //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n          //  s->block_start >= (long)s->w_size, \"slide too late\");\n    //      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n    //        s.block_start >= s.w_size)) {\n    //        throw  new Error(\"slide too late\");\n    //      }\n\n          fill_window(s);\n          if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n            return BS_NEED_MORE;\n          }\n\n          if (s.lookahead === 0) {\n            break;\n          }\n          /* flush the current block */\n        }\n        //Assert(s->block_start >= 0L, \"block gone\");\n    //    if (s.block_start < 0) throw new Error(\"block gone\");\n\n        s.strstart += s.lookahead;\n        s.lookahead = 0;\n\n        /* Emit a stored block if pending_buf will be full: */\n        const max_start = s.block_start + max_block_size;\n\n        if (s.strstart === 0 || s.strstart >= max_start) {\n          /* strstart == 0 is possible when wraparound on 16-bit machine */\n          s.lookahead = s.strstart - max_start;\n          s.strstart = max_start;\n          /*** FLUSH_BLOCK(s, 0); ***/\n          flush_block_only(s, false);\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n          /***/\n\n\n        }\n        /* Flush if we may have to slide, otherwise block_start may become\n         * negative and the data will be gone:\n         */\n        if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {\n          /*** FLUSH_BLOCK(s, 0); ***/\n          flush_block_only(s, false);\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n          /***/\n        }\n      }\n\n      s.insert = 0;\n\n      if (flush === Z_FINISH) {\n        /*** FLUSH_BLOCK(s, 1); ***/\n        flush_block_only(s, true);\n        if (s.strm.avail_out === 0) {\n          return BS_FINISH_STARTED;\n        }\n        /***/\n        return BS_FINISH_DONE;\n      }\n\n      if (s.strstart > s.block_start) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n\n      return BS_NEED_MORE;\n    };\n\n    /* ===========================================================================\n     * Compress as much as possible from the input stream, return the current\n     * block state.\n     * This function does not perform lazy evaluation of matches and inserts\n     * new strings in the dictionary only for unmatched strings or for short\n     * matches. It is used only for the fast compression options.\n     */\n    const deflate_fast = (s, flush) => {\n\n      let hash_head;        /* head of the hash chain */\n      let bflush;           /* set if current block must be flushed */\n\n      for (;;) {\n        /* Make sure that we always have enough lookahead, except\n         * at the end of the input file. We need MAX_MATCH bytes\n         * for the next match, plus MIN_MATCH bytes to insert the\n         * string following the next match.\n         */\n        if (s.lookahead < MIN_LOOKAHEAD) {\n          fill_window(s);\n          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n            return BS_NEED_MORE;\n          }\n          if (s.lookahead === 0) {\n            break; /* flush the current block */\n          }\n        }\n\n        /* Insert the string window[strstart .. strstart+2] in the\n         * dictionary, and set hash_head to the head of the hash chain:\n         */\n        hash_head = 0/*NIL*/;\n        if (s.lookahead >= MIN_MATCH) {\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n\n        /* Find the longest match, discarding those <= prev_length.\n         * At this point we have always match_length < MIN_MATCH\n         */\n        if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\n          /* To simplify the code, we prevent matches with the string\n           * of window index 0 (in particular we have to avoid a match\n           * of the string with itself at the start of the input file).\n           */\n          s.match_length = longest_match(s, hash_head);\n          /* longest_match() sets match_start */\n        }\n        if (s.match_length >= MIN_MATCH) {\n          // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n          /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                         s.match_length - MIN_MATCH, bflush); ***/\n          bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n\n          s.lookahead -= s.match_length;\n\n          /* Insert new strings in the hash table only if the match length\n           * is not too large. This saves time but degrades compression.\n           */\n          if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\n            s.match_length--; /* string at strstart already in table */\n            do {\n              s.strstart++;\n              /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n              s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n              s.head[s.ins_h] = s.strstart;\n              /***/\n              /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n               * always MIN_MATCH bytes ahead.\n               */\n            } while (--s.match_length !== 0);\n            s.strstart++;\n          } else\n          {\n            s.strstart += s.match_length;\n            s.match_length = 0;\n            s.ins_h = s.window[s.strstart];\n            /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);\n\n    //#if MIN_MATCH != 3\n    //                Call UPDATE_HASH() MIN_MATCH-3 more times\n    //#endif\n            /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n             * matter since it will be recomputed at next deflate call.\n             */\n          }\n        } else {\n          /* No match, output a literal byte */\n          //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n          /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n          bflush = _tr_tally(s, 0, s.window[s.strstart]);\n\n          s.lookahead--;\n          s.strstart++;\n        }\n        if (bflush) {\n          /*** FLUSH_BLOCK(s, 0); ***/\n          flush_block_only(s, false);\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n          /***/\n        }\n      }\n      s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);\n      if (flush === Z_FINISH) {\n        /*** FLUSH_BLOCK(s, 1); ***/\n        flush_block_only(s, true);\n        if (s.strm.avail_out === 0) {\n          return BS_FINISH_STARTED;\n        }\n        /***/\n        return BS_FINISH_DONE;\n      }\n      if (s.last_lit) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n      return BS_BLOCK_DONE;\n    };\n\n    /* ===========================================================================\n     * Same as above, but achieves better compression. We use a lazy\n     * evaluation for matches: a match is finally adopted only if there is\n     * no better match at the next window position.\n     */\n    const deflate_slow = (s, flush) => {\n\n      let hash_head;          /* head of hash chain */\n      let bflush;              /* set if current block must be flushed */\n\n      let max_insert;\n\n      /* Process the input block. */\n      for (;;) {\n        /* Make sure that we always have enough lookahead, except\n         * at the end of the input file. We need MAX_MATCH bytes\n         * for the next match, plus MIN_MATCH bytes to insert the\n         * string following the next match.\n         */\n        if (s.lookahead < MIN_LOOKAHEAD) {\n          fill_window(s);\n          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n            return BS_NEED_MORE;\n          }\n          if (s.lookahead === 0) { break; } /* flush the current block */\n        }\n\n        /* Insert the string window[strstart .. strstart+2] in the\n         * dictionary, and set hash_head to the head of the hash chain:\n         */\n        hash_head = 0/*NIL*/;\n        if (s.lookahead >= MIN_MATCH) {\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n\n        /* Find the longest match, discarding those <= prev_length.\n         */\n        s.prev_length = s.match_length;\n        s.prev_match = s.match_start;\n        s.match_length = MIN_MATCH - 1;\n\n        if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\n            s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\n          /* To simplify the code, we prevent matches with the string\n           * of window index 0 (in particular we have to avoid a match\n           * of the string with itself at the start of the input file).\n           */\n          s.match_length = longest_match(s, hash_head);\n          /* longest_match() sets match_start */\n\n          if (s.match_length <= 5 &&\n             (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\n\n            /* If prev_match is also MIN_MATCH, match_start is garbage\n             * but we will ignore the current match anyway.\n             */\n            s.match_length = MIN_MATCH - 1;\n          }\n        }\n        /* If there was a match at the previous step and the current\n         * match is not better, output the previous match:\n         */\n        if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n          max_insert = s.strstart + s.lookahead - MIN_MATCH;\n          /* Do not insert strings in hash table beyond this. */\n\n          //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n          /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                         s.prev_length - MIN_MATCH, bflush);***/\n          bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n          /* Insert in hash table all strings up to the end of the match.\n           * strstart-1 and strstart are already inserted. If there is not\n           * enough lookahead, the last two strings are not inserted in\n           * the hash table.\n           */\n          s.lookahead -= s.prev_length - 1;\n          s.prev_length -= 2;\n          do {\n            if (++s.strstart <= max_insert) {\n              /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n              s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n              s.head[s.ins_h] = s.strstart;\n              /***/\n            }\n          } while (--s.prev_length !== 0);\n          s.match_available = 0;\n          s.match_length = MIN_MATCH - 1;\n          s.strstart++;\n\n          if (bflush) {\n            /*** FLUSH_BLOCK(s, 0); ***/\n            flush_block_only(s, false);\n            if (s.strm.avail_out === 0) {\n              return BS_NEED_MORE;\n            }\n            /***/\n          }\n\n        } else if (s.match_available) {\n          /* If there was no match at the previous position, output a\n           * single literal. If there was a match but the current match\n           * is longer, truncate the previous match to a single literal.\n           */\n          //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n          /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n          bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);\n\n          if (bflush) {\n            /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n            flush_block_only(s, false);\n            /***/\n          }\n          s.strstart++;\n          s.lookahead--;\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n        } else {\n          /* There is no previous match to compare with, wait for\n           * the next step to decide.\n           */\n          s.match_available = 1;\n          s.strstart++;\n          s.lookahead--;\n        }\n      }\n      //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n      if (s.match_available) {\n        //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n        /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n        bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);\n\n        s.match_available = 0;\n      }\n      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n      if (flush === Z_FINISH) {\n        /*** FLUSH_BLOCK(s, 1); ***/\n        flush_block_only(s, true);\n        if (s.strm.avail_out === 0) {\n          return BS_FINISH_STARTED;\n        }\n        /***/\n        return BS_FINISH_DONE;\n      }\n      if (s.last_lit) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n\n      return BS_BLOCK_DONE;\n    };\n\n\n    /* ===========================================================================\n     * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n     * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n     * deflate switches away from Z_RLE.)\n     */\n    const deflate_rle = (s, flush) => {\n\n      let bflush;            /* set if current block must be flushed */\n      let prev;              /* byte at distance one to match */\n      let scan, strend;      /* scan goes up to strend for length of run */\n\n      const _win = s.window;\n\n      for (;;) {\n        /* Make sure that we always have enough lookahead, except\n         * at the end of the input file. We need MAX_MATCH bytes\n         * for the longest run, plus one for the unrolled loop.\n         */\n        if (s.lookahead <= MAX_MATCH) {\n          fill_window(s);\n          if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\n            return BS_NEED_MORE;\n          }\n          if (s.lookahead === 0) { break; } /* flush the current block */\n        }\n\n        /* See how many times the previous byte repeats */\n        s.match_length = 0;\n        if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n          scan = s.strstart - 1;\n          prev = _win[scan];\n          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n            strend = s.strstart + MAX_MATCH;\n            do {\n              /*jshint noempty:false*/\n            } while (prev === _win[++scan] && prev === _win[++scan] &&\n                     prev === _win[++scan] && prev === _win[++scan] &&\n                     prev === _win[++scan] && prev === _win[++scan] &&\n                     prev === _win[++scan] && prev === _win[++scan] &&\n                     scan < strend);\n            s.match_length = MAX_MATCH - (strend - scan);\n            if (s.match_length > s.lookahead) {\n              s.match_length = s.lookahead;\n            }\n          }\n          //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n        }\n\n        /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n        if (s.match_length >= MIN_MATCH) {\n          //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n          /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n          bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);\n\n          s.lookahead -= s.match_length;\n          s.strstart += s.match_length;\n          s.match_length = 0;\n        } else {\n          /* No match, output a literal byte */\n          //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n          /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n          bflush = _tr_tally(s, 0, s.window[s.strstart]);\n\n          s.lookahead--;\n          s.strstart++;\n        }\n        if (bflush) {\n          /*** FLUSH_BLOCK(s, 0); ***/\n          flush_block_only(s, false);\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n          /***/\n        }\n      }\n      s.insert = 0;\n      if (flush === Z_FINISH) {\n        /*** FLUSH_BLOCK(s, 1); ***/\n        flush_block_only(s, true);\n        if (s.strm.avail_out === 0) {\n          return BS_FINISH_STARTED;\n        }\n        /***/\n        return BS_FINISH_DONE;\n      }\n      if (s.last_lit) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n      return BS_BLOCK_DONE;\n    };\n\n    /* ===========================================================================\n     * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n     * (It will be regenerated if this run of deflate switches away from Huffman.)\n     */\n    const deflate_huff = (s, flush) => {\n\n      let bflush;             /* set if current block must be flushed */\n\n      for (;;) {\n        /* Make sure that we have a literal to write. */\n        if (s.lookahead === 0) {\n          fill_window(s);\n          if (s.lookahead === 0) {\n            if (flush === Z_NO_FLUSH) {\n              return BS_NEED_MORE;\n            }\n            break;      /* flush the current block */\n          }\n        }\n\n        /* Output a literal byte */\n        s.match_length = 0;\n        //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n        /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n        bflush = _tr_tally(s, 0, s.window[s.strstart]);\n        s.lookahead--;\n        s.strstart++;\n        if (bflush) {\n          /*** FLUSH_BLOCK(s, 0); ***/\n          flush_block_only(s, false);\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n          /***/\n        }\n      }\n      s.insert = 0;\n      if (flush === Z_FINISH) {\n        /*** FLUSH_BLOCK(s, 1); ***/\n        flush_block_only(s, true);\n        if (s.strm.avail_out === 0) {\n          return BS_FINISH_STARTED;\n        }\n        /***/\n        return BS_FINISH_DONE;\n      }\n      if (s.last_lit) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n      return BS_BLOCK_DONE;\n    };\n\n    /* Values for max_lazy_match, good_match and max_chain_length, depending on\n     * the desired pack level (0..9). The values given below have been tuned to\n     * exclude worst case performance for pathological files. Better values may be\n     * found for specific files.\n     */\n    function Config(good_length, max_lazy, nice_length, max_chain, func) {\n\n      this.good_length = good_length;\n      this.max_lazy = max_lazy;\n      this.nice_length = nice_length;\n      this.max_chain = max_chain;\n      this.func = func;\n    }\n\n    const configuration_table = [\n      /*      good lazy nice chain */\n      new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\n      new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\n      new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\n      new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\n\n      new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\n      new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\n      new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\n      new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\n      new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\n      new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\n    ];\n\n\n    /* ===========================================================================\n     * Initialize the \"longest match\" routines for a new zlib stream\n     */\n    const lm_init = (s) => {\n\n      s.window_size = 2 * s.w_size;\n\n      /*** CLEAR_HASH(s); ***/\n      zero(s.head); // Fill with NIL (= 0);\n\n      /* Set the default configuration parameters:\n       */\n      s.max_lazy_match = configuration_table[s.level].max_lazy;\n      s.good_match = configuration_table[s.level].good_length;\n      s.nice_match = configuration_table[s.level].nice_length;\n      s.max_chain_length = configuration_table[s.level].max_chain;\n\n      s.strstart = 0;\n      s.block_start = 0;\n      s.lookahead = 0;\n      s.insert = 0;\n      s.match_length = s.prev_length = MIN_MATCH - 1;\n      s.match_available = 0;\n      s.ins_h = 0;\n    };\n\n\n    function DeflateState() {\n      this.strm = null;            /* pointer back to this zlib stream */\n      this.status = 0;            /* as the name implies */\n      this.pending_buf = null;      /* output still pending */\n      this.pending_buf_size = 0;  /* size of pending_buf */\n      this.pending_out = 0;       /* next pending byte to output to the stream */\n      this.pending = 0;           /* nb of bytes in the pending buffer */\n      this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n      this.gzhead = null;         /* gzip header information to write */\n      this.gzindex = 0;           /* where in extra, name, or comment */\n      this.method = Z_DEFLATED; /* can only be DEFLATED */\n      this.last_flush = -1;   /* value of flush param for previous deflate call */\n\n      this.w_size = 0;  /* LZ77 window size (32K by default) */\n      this.w_bits = 0;  /* log2(w_size)  (8..16) */\n      this.w_mask = 0;  /* w_size - 1 */\n\n      this.window = null;\n      /* Sliding window. Input bytes are read into the second half of the window,\n       * and move to the first half later to keep a dictionary of at least wSize\n       * bytes. With this organization, matches are limited to a distance of\n       * wSize-MAX_MATCH bytes, but this ensures that IO is always\n       * performed with a length multiple of the block size.\n       */\n\n      this.window_size = 0;\n      /* Actual size of window: 2*wSize, except when the user input buffer\n       * is directly used as sliding window.\n       */\n\n      this.prev = null;\n      /* Link to older string with same hash index. To limit the size of this\n       * array to 64K, this link is maintained only for the last 32K strings.\n       * An index in this array is thus a window index modulo 32K.\n       */\n\n      this.head = null;   /* Heads of the hash chains or NIL. */\n\n      this.ins_h = 0;       /* hash index of string to be inserted */\n      this.hash_size = 0;   /* number of elements in hash table */\n      this.hash_bits = 0;   /* log2(hash_size) */\n      this.hash_mask = 0;   /* hash_size-1 */\n\n      this.hash_shift = 0;\n      /* Number of bits by which ins_h must be shifted at each input\n       * step. It must be such that after MIN_MATCH steps, the oldest\n       * byte no longer takes part in the hash key, that is:\n       *   hash_shift * MIN_MATCH >= hash_bits\n       */\n\n      this.block_start = 0;\n      /* Window position at the beginning of the current output block. Gets\n       * negative when the window is moved backwards.\n       */\n\n      this.match_length = 0;      /* length of best match */\n      this.prev_match = 0;        /* previous match */\n      this.match_available = 0;   /* set if previous match exists */\n      this.strstart = 0;          /* start of string to insert */\n      this.match_start = 0;       /* start of matching string */\n      this.lookahead = 0;         /* number of valid bytes ahead in window */\n\n      this.prev_length = 0;\n      /* Length of the best match at previous step. Matches not greater than this\n       * are discarded. This is used in the lazy match evaluation.\n       */\n\n      this.max_chain_length = 0;\n      /* To speed up deflation, hash chains are never searched beyond this\n       * length.  A higher limit improves compression ratio but degrades the\n       * speed.\n       */\n\n      this.max_lazy_match = 0;\n      /* Attempt to find a better match only when the current match is strictly\n       * smaller than this value. This mechanism is used only for compression\n       * levels >= 4.\n       */\n      // That's alias to max_lazy_match, don't use directly\n      //this.max_insert_length = 0;\n      /* Insert new strings in the hash table only if the match length is not\n       * greater than this length. This saves time but degrades compression.\n       * max_insert_length is used only for compression levels <= 3.\n       */\n\n      this.level = 0;     /* compression level (1..9) */\n      this.strategy = 0;  /* favor or force Huffman coding*/\n\n      this.good_match = 0;\n      /* Use a faster search when the previous match is longer than this */\n\n      this.nice_match = 0; /* Stop searching when current match exceeds this */\n\n                  /* used by trees.c: */\n\n      /* Didn't use ct_data typedef below to suppress compiler warning */\n\n      // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n      // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n      // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n      // Use flat array of DOUBLE size, with interleaved fata,\n      // because JS does not support effective\n      this.dyn_ltree  = new Uint16Array(HEAP_SIZE * 2);\n      this.dyn_dtree  = new Uint16Array((2 * D_CODES + 1) * 2);\n      this.bl_tree    = new Uint16Array((2 * BL_CODES + 1) * 2);\n      zero(this.dyn_ltree);\n      zero(this.dyn_dtree);\n      zero(this.bl_tree);\n\n      this.l_desc   = null;         /* desc. for literal tree */\n      this.d_desc   = null;         /* desc. for distance tree */\n      this.bl_desc  = null;         /* desc. for bit length tree */\n\n      //ush bl_count[MAX_BITS+1];\n      this.bl_count = new Uint16Array(MAX_BITS + 1);\n      /* number of codes at each bit length for an optimal tree */\n\n      //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n      this.heap = new Uint16Array(2 * L_CODES + 1);  /* heap used to build the Huffman trees */\n      zero(this.heap);\n\n      this.heap_len = 0;               /* number of elements in the heap */\n      this.heap_max = 0;               /* element of largest frequency */\n      /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n       * The same heap array is used to build all trees.\n       */\n\n      this.depth = new Uint16Array(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n      zero(this.depth);\n      /* Depth of each subtree used as tie breaker for trees of equal frequency\n       */\n\n      this.l_buf = 0;          /* buffer index for literals or lengths */\n\n      this.lit_bufsize = 0;\n      /* Size of match buffer for literals/lengths.  There are 4 reasons for\n       * limiting lit_bufsize to 64K:\n       *   - frequencies can be kept in 16 bit counters\n       *   - if compression is not successful for the first block, all input\n       *     data is still in the window so we can still emit a stored block even\n       *     when input comes from standard input.  (This can also be done for\n       *     all blocks if lit_bufsize is not greater than 32K.)\n       *   - if compression is not successful for a file smaller than 64K, we can\n       *     even emit a stored file instead of a stored block (saving 5 bytes).\n       *     This is applicable only for zip (not gzip or zlib).\n       *   - creating new Huffman trees less frequently may not provide fast\n       *     adaptation to changes in the input data statistics. (Take for\n       *     example a binary file with poorly compressible code followed by\n       *     a highly compressible string table.) Smaller buffer sizes give\n       *     fast adaptation but have of course the overhead of transmitting\n       *     trees more frequently.\n       *   - I can't count above 4\n       */\n\n      this.last_lit = 0;      /* running index in l_buf */\n\n      this.d_buf = 0;\n      /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n       * the same number of elements. To use different lengths, an extra flag\n       * array would be necessary.\n       */\n\n      this.opt_len = 0;       /* bit length of current block with optimal trees */\n      this.static_len = 0;    /* bit length of current block with static trees */\n      this.matches = 0;       /* number of string matches in current block */\n      this.insert = 0;        /* bytes at end of window left to insert */\n\n\n      this.bi_buf = 0;\n      /* Output buffer. bits are inserted starting at the bottom (least\n       * significant bits).\n       */\n      this.bi_valid = 0;\n      /* Number of valid bits in bi_buf.  All bits above the last valid bit\n       * are always zero.\n       */\n\n      // Used for window memory init. We safely ignore it for JS. That makes\n      // sense only for pointers and memory check tools.\n      //this.high_water = 0;\n      /* High water mark offset in window for initialized bytes -- bytes above\n       * this are set to zero in order to avoid memory check warnings when\n       * longest match routines access bytes past the input.  This is then\n       * updated to the new high water mark.\n       */\n    }\n\n\n    const deflateResetKeep = (strm) => {\n\n      if (!strm || !strm.state) {\n        return err(strm, Z_STREAM_ERROR);\n      }\n\n      strm.total_in = strm.total_out = 0;\n      strm.data_type = Z_UNKNOWN;\n\n      const s = strm.state;\n      s.pending = 0;\n      s.pending_out = 0;\n\n      if (s.wrap < 0) {\n        s.wrap = -s.wrap;\n        /* was made negative by deflate(..., Z_FINISH); */\n      }\n      s.status = (s.wrap ? INIT_STATE : BUSY_STATE);\n      strm.adler = (s.wrap === 2) ?\n        0  // crc32(0, Z_NULL, 0)\n      :\n        1; // adler32(0, Z_NULL, 0)\n      s.last_flush = Z_NO_FLUSH;\n      _tr_init(s);\n      return Z_OK;\n    };\n\n\n    const deflateReset = (strm) => {\n\n      const ret = deflateResetKeep(strm);\n      if (ret === Z_OK) {\n        lm_init(strm.state);\n      }\n      return ret;\n    };\n\n\n    const deflateSetHeader = (strm, head) => {\n\n      if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n      if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }\n      strm.state.gzhead = head;\n      return Z_OK;\n    };\n\n\n    const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {\n\n      if (!strm) { // === Z_NULL\n        return Z_STREAM_ERROR;\n      }\n      let wrap = 1;\n\n      if (level === Z_DEFAULT_COMPRESSION) {\n        level = 6;\n      }\n\n      if (windowBits < 0) { /* suppress zlib wrapper */\n        wrap = 0;\n        windowBits = -windowBits;\n      }\n\n      else if (windowBits > 15) {\n        wrap = 2;           /* write gzip wrapper instead */\n        windowBits -= 16;\n      }\n\n\n      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||\n        windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n        strategy < 0 || strategy > Z_FIXED) {\n        return err(strm, Z_STREAM_ERROR);\n      }\n\n\n      if (windowBits === 8) {\n        windowBits = 9;\n      }\n      /* until 256-byte window bug fixed */\n\n      const s = new DeflateState();\n\n      strm.state = s;\n      s.strm = strm;\n\n      s.wrap = wrap;\n      s.gzhead = null;\n      s.w_bits = windowBits;\n      s.w_size = 1 << s.w_bits;\n      s.w_mask = s.w_size - 1;\n\n      s.hash_bits = memLevel + 7;\n      s.hash_size = 1 << s.hash_bits;\n      s.hash_mask = s.hash_size - 1;\n      s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\n      s.window = new Uint8Array(s.w_size * 2);\n      s.head = new Uint16Array(s.hash_size);\n      s.prev = new Uint16Array(s.w_size);\n\n      // Don't need mem init magic for JS.\n      //s.high_water = 0;  /* nothing written to s->window yet */\n\n      s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\n      s.pending_buf_size = s.lit_bufsize * 4;\n\n      //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n      //s->pending_buf = (uchf *) overlay;\n      s.pending_buf = new Uint8Array(s.pending_buf_size);\n\n      // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n      //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n      s.d_buf = 1 * s.lit_bufsize;\n\n      //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n      s.l_buf = (1 + 2) * s.lit_bufsize;\n\n      s.level = level;\n      s.strategy = strategy;\n      s.method = method;\n\n      return deflateReset(strm);\n    };\n\n    const deflateInit = (strm, level) => {\n\n      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n    };\n\n\n    const deflate = (strm, flush) => {\n\n      let beg, val; // for gzip header write only\n\n      if (!strm || !strm.state ||\n        flush > Z_BLOCK || flush < 0) {\n        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n      }\n\n      const s = strm.state;\n\n      if (!strm.output ||\n          (!strm.input && strm.avail_in !== 0) ||\n          (s.status === FINISH_STATE && flush !== Z_FINISH)) {\n        return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);\n      }\n\n      s.strm = strm; /* just in case */\n      const old_flush = s.last_flush;\n      s.last_flush = flush;\n\n      /* Write the header */\n      if (s.status === INIT_STATE) {\n\n        if (s.wrap === 2) { // GZIP header\n          strm.adler = 0;  //crc32(0L, Z_NULL, 0);\n          put_byte(s, 31);\n          put_byte(s, 139);\n          put_byte(s, 8);\n          if (!s.gzhead) { // s->gzhead == Z_NULL\n            put_byte(s, 0);\n            put_byte(s, 0);\n            put_byte(s, 0);\n            put_byte(s, 0);\n            put_byte(s, 0);\n            put_byte(s, s.level === 9 ? 2 :\n                        (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                         4 : 0));\n            put_byte(s, OS_CODE);\n            s.status = BUSY_STATE;\n          }\n          else {\n            put_byte(s, (s.gzhead.text ? 1 : 0) +\n                        (s.gzhead.hcrc ? 2 : 0) +\n                        (!s.gzhead.extra ? 0 : 4) +\n                        (!s.gzhead.name ? 0 : 8) +\n                        (!s.gzhead.comment ? 0 : 16)\n            );\n            put_byte(s, s.gzhead.time & 0xff);\n            put_byte(s, (s.gzhead.time >> 8) & 0xff);\n            put_byte(s, (s.gzhead.time >> 16) & 0xff);\n            put_byte(s, (s.gzhead.time >> 24) & 0xff);\n            put_byte(s, s.level === 9 ? 2 :\n                        (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                         4 : 0));\n            put_byte(s, s.gzhead.os & 0xff);\n            if (s.gzhead.extra && s.gzhead.extra.length) {\n              put_byte(s, s.gzhead.extra.length & 0xff);\n              put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n            }\n            if (s.gzhead.hcrc) {\n              strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n            }\n            s.gzindex = 0;\n            s.status = EXTRA_STATE;\n          }\n        }\n        else // DEFLATE header\n        {\n          let header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;\n          let level_flags = -1;\n\n          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n            level_flags = 0;\n          } else if (s.level < 6) {\n            level_flags = 1;\n          } else if (s.level === 6) {\n            level_flags = 2;\n          } else {\n            level_flags = 3;\n          }\n          header |= (level_flags << 6);\n          if (s.strstart !== 0) { header |= PRESET_DICT; }\n          header += 31 - (header % 31);\n\n          s.status = BUSY_STATE;\n          putShortMSB(s, header);\n\n          /* Save the adler32 of the preset dictionary: */\n          if (s.strstart !== 0) {\n            putShortMSB(s, strm.adler >>> 16);\n            putShortMSB(s, strm.adler & 0xffff);\n          }\n          strm.adler = 1; // adler32(0L, Z_NULL, 0);\n        }\n      }\n\n    //#ifdef GZIP\n      if (s.status === EXTRA_STATE) {\n        if (s.gzhead.extra/* != Z_NULL*/) {\n          beg = s.pending;  /* start of bytes to update crc */\n\n          while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n            if (s.pending === s.pending_buf_size) {\n              if (s.gzhead.hcrc && s.pending > beg) {\n                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n              }\n              flush_pending(strm);\n              beg = s.pending;\n              if (s.pending === s.pending_buf_size) {\n                break;\n              }\n            }\n            put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n            s.gzindex++;\n          }\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          if (s.gzindex === s.gzhead.extra.length) {\n            s.gzindex = 0;\n            s.status = NAME_STATE;\n          }\n        }\n        else {\n          s.status = NAME_STATE;\n        }\n      }\n      if (s.status === NAME_STATE) {\n        if (s.gzhead.name/* != Z_NULL*/) {\n          beg = s.pending;  /* start of bytes to update crc */\n          //int val;\n\n          do {\n            if (s.pending === s.pending_buf_size) {\n              if (s.gzhead.hcrc && s.pending > beg) {\n                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n              }\n              flush_pending(strm);\n              beg = s.pending;\n              if (s.pending === s.pending_buf_size) {\n                val = 1;\n                break;\n              }\n            }\n            // JS specific: little magic to add zero terminator to end of string\n            if (s.gzindex < s.gzhead.name.length) {\n              val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n            } else {\n              val = 0;\n            }\n            put_byte(s, val);\n          } while (val !== 0);\n\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          if (val === 0) {\n            s.gzindex = 0;\n            s.status = COMMENT_STATE;\n          }\n        }\n        else {\n          s.status = COMMENT_STATE;\n        }\n      }\n      if (s.status === COMMENT_STATE) {\n        if (s.gzhead.comment/* != Z_NULL*/) {\n          beg = s.pending;  /* start of bytes to update crc */\n          //int val;\n\n          do {\n            if (s.pending === s.pending_buf_size) {\n              if (s.gzhead.hcrc && s.pending > beg) {\n                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n              }\n              flush_pending(strm);\n              beg = s.pending;\n              if (s.pending === s.pending_buf_size) {\n                val = 1;\n                break;\n              }\n            }\n            // JS specific: little magic to add zero terminator to end of string\n            if (s.gzindex < s.gzhead.comment.length) {\n              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n            } else {\n              val = 0;\n            }\n            put_byte(s, val);\n          } while (val !== 0);\n\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          if (val === 0) {\n            s.status = HCRC_STATE;\n          }\n        }\n        else {\n          s.status = HCRC_STATE;\n        }\n      }\n      if (s.status === HCRC_STATE) {\n        if (s.gzhead.hcrc) {\n          if (s.pending + 2 > s.pending_buf_size) {\n            flush_pending(strm);\n          }\n          if (s.pending + 2 <= s.pending_buf_size) {\n            put_byte(s, strm.adler & 0xff);\n            put_byte(s, (strm.adler >> 8) & 0xff);\n            strm.adler = 0; //crc32(0L, Z_NULL, 0);\n            s.status = BUSY_STATE;\n          }\n        }\n        else {\n          s.status = BUSY_STATE;\n        }\n      }\n    //#endif\n\n      /* Flush as much pending output as possible */\n      if (s.pending !== 0) {\n        flush_pending(strm);\n        if (strm.avail_out === 0) {\n          /* Since avail_out is 0, deflate will be called again with\n           * more output space, but possibly with both pending and\n           * avail_in equal to zero. There won't be anything to do,\n           * but this is not an error situation so make sure we\n           * return OK instead of BUF_ERROR at next call of deflate:\n           */\n          s.last_flush = -1;\n          return Z_OK;\n        }\n\n        /* Make sure there is something to do and avoid duplicate consecutive\n         * flushes. For repeated and useless calls with Z_FINISH, we keep\n         * returning Z_STREAM_END instead of Z_BUF_ERROR.\n         */\n      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\n        flush !== Z_FINISH) {\n        return err(strm, Z_BUF_ERROR);\n      }\n\n      /* User must not provide more input after the first FINISH: */\n      if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n        return err(strm, Z_BUF_ERROR);\n      }\n\n      /* Start a new block or continue the current one.\n       */\n      if (strm.avail_in !== 0 || s.lookahead !== 0 ||\n        (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {\n        let bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :\n          (s.strategy === Z_RLE ? deflate_rle(s, flush) :\n            configuration_table[s.level].func(s, flush));\n\n        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n          s.status = FINISH_STATE;\n        }\n        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n          if (strm.avail_out === 0) {\n            s.last_flush = -1;\n            /* avoid BUF_ERROR next call, see above */\n          }\n          return Z_OK;\n          /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n           * of deflate should use the same flush parameter to make sure\n           * that the flush is complete. So we don't have to output an\n           * empty block here, this will be done at next call. This also\n           * ensures that for a very small output buffer, we emit at most\n           * one empty block.\n           */\n        }\n        if (bstate === BS_BLOCK_DONE) {\n          if (flush === Z_PARTIAL_FLUSH) {\n            _tr_align(s);\n          }\n          else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */\n\n            _tr_stored_block(s, 0, 0, false);\n            /* For a full flush, this empty block will be recognized\n             * as a special marker by inflate_sync().\n             */\n            if (flush === Z_FULL_FLUSH) {\n              /*** CLEAR_HASH(s); ***/             /* forget history */\n              zero(s.head); // Fill with NIL (= 0);\n\n              if (s.lookahead === 0) {\n                s.strstart = 0;\n                s.block_start = 0;\n                s.insert = 0;\n              }\n            }\n          }\n          flush_pending(strm);\n          if (strm.avail_out === 0) {\n            s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n            return Z_OK;\n          }\n        }\n      }\n      //Assert(strm->avail_out > 0, \"bug2\");\n      //if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n\n      if (flush !== Z_FINISH) { return Z_OK; }\n      if (s.wrap <= 0) { return Z_STREAM_END; }\n\n      /* Write the trailer */\n      if (s.wrap === 2) {\n        put_byte(s, strm.adler & 0xff);\n        put_byte(s, (strm.adler >> 8) & 0xff);\n        put_byte(s, (strm.adler >> 16) & 0xff);\n        put_byte(s, (strm.adler >> 24) & 0xff);\n        put_byte(s, strm.total_in & 0xff);\n        put_byte(s, (strm.total_in >> 8) & 0xff);\n        put_byte(s, (strm.total_in >> 16) & 0xff);\n        put_byte(s, (strm.total_in >> 24) & 0xff);\n      }\n      else\n      {\n        putShortMSB(s, strm.adler >>> 16);\n        putShortMSB(s, strm.adler & 0xffff);\n      }\n\n      flush_pending(strm);\n      /* If avail_out is zero, the application will call deflate again\n       * to flush the rest.\n       */\n      if (s.wrap > 0) { s.wrap = -s.wrap; }\n      /* write the trailer only once! */\n      return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n    };\n\n\n    const deflateEnd = (strm) => {\n\n      if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n        return Z_STREAM_ERROR;\n      }\n\n      const status = strm.state.status;\n      if (status !== INIT_STATE &&\n        status !== EXTRA_STATE &&\n        status !== NAME_STATE &&\n        status !== COMMENT_STATE &&\n        status !== HCRC_STATE &&\n        status !== BUSY_STATE &&\n        status !== FINISH_STATE\n      ) {\n        return err(strm, Z_STREAM_ERROR);\n      }\n\n      strm.state = null;\n\n      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n    };\n\n\n    /* =========================================================================\n     * Initializes the compression dictionary from the given byte\n     * sequence without producing any compressed output.\n     */\n    const deflateSetDictionary = (strm, dictionary) => {\n\n      let dictLength = dictionary.length;\n\n      if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n        return Z_STREAM_ERROR;\n      }\n\n      const s = strm.state;\n      const wrap = s.wrap;\n\n      if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n        return Z_STREAM_ERROR;\n      }\n\n      /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n      if (wrap === 1) {\n        /* adler32(strm->adler, dictionary, dictLength); */\n        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\n      }\n\n      s.wrap = 0;   /* avoid computing Adler-32 in read_buf */\n\n      /* if dictionary would fill window, just replace the history */\n      if (dictLength >= s.w_size) {\n        if (wrap === 0) {            /* already empty otherwise */\n          /*** CLEAR_HASH(s); ***/\n          zero(s.head); // Fill with NIL (= 0);\n          s.strstart = 0;\n          s.block_start = 0;\n          s.insert = 0;\n        }\n        /* use the tail */\n        // dictionary = dictionary.slice(dictLength - s.w_size);\n        let tmpDict = new Uint8Array(s.w_size);\n        tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);\n        dictionary = tmpDict;\n        dictLength = s.w_size;\n      }\n      /* insert dictionary into window and hash */\n      const avail = strm.avail_in;\n      const next = strm.next_in;\n      const input = strm.input;\n      strm.avail_in = dictLength;\n      strm.next_in = 0;\n      strm.input = dictionary;\n      fill_window(s);\n      while (s.lookahead >= MIN_MATCH) {\n        let str = s.strstart;\n        let n = s.lookahead - (MIN_MATCH - 1);\n        do {\n          /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n          s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);\n\n          s.prev[str & s.w_mask] = s.head[s.ins_h];\n\n          s.head[s.ins_h] = str;\n          str++;\n        } while (--n);\n        s.strstart = str;\n        s.lookahead = MIN_MATCH - 1;\n        fill_window(s);\n      }\n      s.strstart += s.lookahead;\n      s.block_start = s.strstart;\n      s.insert = s.lookahead;\n      s.lookahead = 0;\n      s.match_length = s.prev_length = MIN_MATCH - 1;\n      s.match_available = 0;\n      strm.next_in = next;\n      strm.input = input;\n      strm.avail_in = avail;\n      s.wrap = wrap;\n      return Z_OK;\n    };\n\n\n    return {\n      deflateInit,\n      deflateInit2,\n      deflateReset,\n      deflateResetKeep,\n      deflateSetHeader,\n      deflate,\n      deflateEnd,\n      deflateSetDictionary,\n      deflateInfo : 'pako deflate (from Nodeca project)'\n    };\n\n});"]}