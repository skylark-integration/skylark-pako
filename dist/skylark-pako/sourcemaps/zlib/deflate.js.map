{"version":3,"sources":["zlib/deflate.js"],"names":["define","trees","adler32","crc32","msg","constants","_tr_init","_tr_stored_block","_tr_flush_block","_tr_tally","_tr_align","Z_NO_FLUSH","Z_PARTIAL_FLUSH","Z_FULL_FLUSH","Z_FINISH","Z_BLOCK","Z_OK","Z_STREAM_END","Z_STREAM_ERROR","Z_DATA_ERROR","Z_BUF_ERROR","Z_DEFAULT_COMPRESSION","Z_FILTERED","Z_HUFFMAN_ONLY","Z_RLE","Z_FIXED","Z_DEFAULT_STRATEGY","Z_UNKNOWN","Z_DEFLATED","__module__4","L_CODES","LITERALS","D_CODES","BL_CODES","HEAP_SIZE","MAX_BITS","err","strm","errorCode","rank","f","zero","buf","len","length","HASH","s","prev","data","hash_shift","hash_mask","flush_pending","state","pending","avail_out","output","set","pending_buf","subarray","pending_out","next_out","total_out","flush_block_only","last","block_start","strstart","put_byte","b","putShortMSB","read_buf","start","size","avail_in","input","next_in","wrap","adler","total_in","longest_match","cur_match","match","chain_length","max_chain_length","scan","best_len","prev_length","nice_match","limit","w_size","MAX_MATCH","_win","window","wmask","w_mask","strend","scan_end1","scan_end","good_match","lookahead","match_start","fill_window","_w_size","p","n","m","more","str","window_size","hash_size","head","insert","ins_h","deflate_fast","flush","hash_head","bflush","match_length","max_lazy_match","MIN_MATCH","last_lit","deflate_slow","max_insert","prev_match","strategy","match_available","Config","good_length","max_lazy","nice_length","max_chain","func","this","configuration_table","max_block_size","pending_buf_size","max_start","deflateResetKeep","data_type","status","last_flush","deflateReset","ret","level","deflateInit2","method","windowBits","memLevel","gzhead","gzindex","w_bits","hash_bits","dyn_ltree","Uint16Array","dyn_dtree","bl_tree","l_desc","d_desc","bl_desc","bl_count","heap","heap_len","heap_max","depth","l_buf","lit_bufsize","d_buf","opt_len","static_len","matches","bi_buf","bi_valid","Uint8Array","deflateInit","deflateSetHeader","deflate","beg","val","old_flush","text","hcrc","extra","name","comment","time","os","header","level_flags","charCodeAt","bstate","deflate_huff","deflate_rle","deflateEnd","deflateSetDictionary","dictionary","dictLength","tmpDict","avail","next","deflateInfo"],"mappings":";;;;;;;AAAAA,QACI,UACA,YACA,UACA,aACA,eACD,SAAUC,EAAOC,EAASC,EAAOC,EAAKC,GACrC,aAGA,MAAMC,SAACA,EAAQC,iBAAEA,EAAgBC,gBAAEA,EAAeC,UAAEA,EAASC,UAAEA,GAAaT,GACtEU,WAACA,EAAUC,gBAAEA,EAAeC,aAAEA,EAAYC,SAAEA,EAAQC,QAAEA,EAAOC,KAAEA,EAAIC,aAAEA,EAAYC,eAAEA,EAAcC,aAAEA,EAAYC,YAAEA,EAAWC,sBAAEA,EAAqBC,WAAEA,EAAUC,eAAEA,EAAcC,MAAEA,EAAKC,QAAEA,EAAOC,mBAAEA,EAAkBC,UAAEA,EAASC,WAAEA,GAAcC,YAO9OC,EAAUC,IACVC,EAAU,GACVC,EAAW,GACXC,EAAY,EAAIJ,EAAU,EAC1BK,EAAW,GAiBXC,EAAM,CAACC,EAAMC,KACfD,EAAKjC,IAAMA,EAAIkC,GACRA,GAELC,EAAOC,IACDA,GAAK,IAAMA,EAAI,EAAI,EAAI,GAE7BC,EAAOC,IACT,IAAIC,EAAMD,EAAIE,OACd,OAASD,GAAO,GACZD,EAAIC,GAAO,GAGnB,IACIE,EADY,CAACC,EAAGC,EAAMC,KAAUD,GAAQD,EAAEG,WAAaD,GAAQF,EAAEI,UAErE,MAAMC,EAAgBd,IAClB,MAAMS,EAAIT,EAAKe,MACf,IAAIT,EAAMG,EAAEO,QACRV,EAAMN,EAAKiB,YACXX,EAAMN,EAAKiB,WAEH,IAARX,IAGJN,EAAKkB,OAAOC,IAAIV,EAAEW,YAAYC,SAASZ,EAAEa,YAAab,EAAEa,YAAchB,GAAMN,EAAKuB,UACjFvB,EAAKuB,UAAYjB,EACjBG,EAAEa,aAAehB,EACjBN,EAAKwB,WAAalB,EAClBN,EAAKiB,WAAaX,EAClBG,EAAEO,SAAWV,EACK,IAAdG,EAAEO,UACFP,EAAEa,YAAc,KAGlBG,EAAmB,CAAChB,EAAGiB,KACzBvD,EAAgBsC,EAAGA,EAAEkB,aAAe,EAAIlB,EAAEkB,aAAe,EAAGlB,EAAEmB,SAAWnB,EAAEkB,YAAaD,GACxFjB,EAAEkB,YAAclB,EAAEmB,SAClBd,EAAcL,EAAET,OAEd6B,EAAW,CAACpB,EAAGqB,KACjBrB,EAAEW,YAAYX,EAAEO,WAAac,GAE3BC,EAAc,CAACtB,EAAGqB,KACpBrB,EAAEW,YAAYX,EAAEO,WAAac,IAAM,EAAI,IACvCrB,EAAEW,YAAYX,EAAEO,WAAiB,IAAJc,GAE3BE,EAAW,CAAChC,EAAMK,EAAK4B,EAAOC,KAChC,IAAI5B,EAAMN,EAAKmC,SAIf,OAHI7B,EAAM4B,IACN5B,EAAM4B,GAEE,IAAR5B,EACO,GAEXN,EAAKmC,UAAY7B,EACjBD,EAAIc,IAAInB,EAAKoC,MAAMf,SAASrB,EAAKqC,QAASrC,EAAKqC,QAAU/B,GAAM2B,GACvC,IAApBjC,EAAKe,MAAMuB,KACXtC,EAAKuC,MAAQ1E,EAAQmC,EAAKuC,MAAOlC,EAAKC,EAAK2B,GAChB,IAApBjC,EAAKe,MAAMuB,OAClBtC,EAAKuC,MAAQzE,EAAMkC,EAAKuC,MAAOlC,EAAKC,EAAK2B,IAE7CjC,EAAKqC,SAAW/B,EAChBN,EAAKwC,UAAYlC,EACVA,IAELmC,EAAgB,CAAChC,EAAGiC,KACtB,IAEIC,EACArC,EAHAsC,EAAenC,EAAEoC,iBACjBC,EAAOrC,EAAEmB,SAGTmB,EAAWtC,EAAEuC,YACbC,EAAaxC,EAAEwC,WACnB,MAAMC,EAAQzC,EAAEmB,SAAWnB,EAAE0C,OAtFXC,IAsFoC3C,EAAEmB,UAAYnB,EAAE0C,OAtFpDC,KAsF8E,EAC1FC,EAAO5C,EAAE6C,OACTC,EAAQ9C,EAAE+C,OACV9C,EAAOD,EAAEC,KACT+C,EAAShD,EAAEmB,SA3FH,IA4Fd,IAAI8B,EAAYL,EAAKP,EAAOC,EAAW,GACnCY,EAAWN,EAAKP,EAAOC,GACvBtC,EAAEuC,aAAevC,EAAEmD,aACnBhB,IAAiB,GAEjBK,EAAaxC,EAAEoD,YACfZ,EAAaxC,EAAEoD,WAEnB,GAEI,GAAIR,GADJV,EAAQD,GACSK,KAAcY,GAAYN,EAAKV,EAAQI,EAAW,KAAOW,GAAaL,EAAKV,KAAWU,EAAKP,IAASO,IAAOV,KAAWU,EAAKP,EAAO,GAAnJ,CAGAA,GAAQ,EACRH,IACA,UACSU,IAAOP,KAAUO,IAAOV,IAAUU,IAAOP,KAAUO,IAAOV,IAAUU,IAAOP,KAAUO,IAAOV,IAAUU,IAAOP,KAAUO,IAAOV,IAAUU,IAAOP,KAAUO,IAAOV,IAAUU,IAAOP,KAAUO,IAAOV,IAAUU,IAAOP,KAAUO,IAAOV,IAAUU,IAAOP,KAAUO,IAAOV,IAAUG,EAAOW,GAGhS,GAFAnD,EA7GU,KA6GSmD,EAASX,GAC5BA,EAAOW,EA9GG,IA+GNnD,EAAMyC,EAAU,CAGhB,GAFAtC,EAAEqD,YAAcpB,EAChBK,EAAWzC,EACPA,GAAO2C,EACP,MAEJS,EAAYL,EAAKP,EAAOC,EAAW,GACnCY,EAAWN,EAAKP,EAAOC,YAErBL,EAAYhC,EAAKgC,EAAYa,IAAUL,GAA4B,KAAjBN,GAC5D,OAAIG,GAAYtC,EAAEoD,UACPd,EAEJtC,EAAEoD,WAEPE,EAActD,IAChB,MAAMuD,EAAUvD,EAAE0C,OAClB,IAAIc,EAAGC,EAAGC,EAAGC,EAAMC,EACnB,EAAG,CAEC,GADAD,EAAO3D,EAAE6D,YAAc7D,EAAEoD,UAAYpD,EAAEmB,SACnCnB,EAAEmB,UAAYoC,GAAWA,EAlIfZ,KAkIyC,CACnD3C,EAAE6C,OAAOnC,IAAIV,EAAE6C,OAAOjC,SAAS2C,EAASA,EAAUA,GAAU,GAC5DvD,EAAEqD,aAAeE,EACjBvD,EAAEmB,UAAYoC,EACdvD,EAAEkB,aAAeqC,EAEjBC,EADAC,EAAIzD,EAAE8D,UAEN,GACIJ,EAAI1D,EAAE+D,OAAOP,GACbxD,EAAE+D,KAAKP,GAAKE,GAAKH,EAAUG,EAAIH,EAAU,UAClCE,GAEXD,EADAC,EAAIF,EAEJ,GACIG,EAAI1D,EAAEC,OAAOuD,GACbxD,EAAEC,KAAKuD,GAAKE,GAAKH,EAAUG,EAAIH,EAAU,UAClCE,GACXE,GAAQJ,EAEZ,GAAwB,IAApBvD,EAAET,KAAKmC,SACP,MAIJ,GAFA+B,EAAIlC,EAASvB,EAAET,KAAMS,EAAE6C,OAAQ7C,EAAEmB,SAAWnB,EAAEoD,UAAWO,GACzD3D,EAAEoD,WAAaK,EACXzD,EAAEoD,UAAYpD,EAAEgE,QA5JV,EAgKN,IAHAJ,EAAM5D,EAAEmB,SAAWnB,EAAEgE,OACrBhE,EAAEiE,MAAQjE,EAAE6C,OAAOe,GACnB5D,EAAEiE,MAAQlE,EAAKC,EAAGA,EAAEiE,MAAOjE,EAAE6C,OAAOe,EAAM,IACnC5D,EAAEgE,SACLhE,EAAEiE,MAAQlE,EAAKC,EAAGA,EAAEiE,MAAOjE,EAAE6C,OAAOe,EAjKlC,EAiKoD,IACtD5D,EAAEC,KAAK2D,EAAM5D,EAAE+C,QAAU/C,EAAE+D,KAAK/D,EAAEiE,OAClCjE,EAAE+D,KAAK/D,EAAEiE,OAASL,EAClBA,IACA5D,EAAEgE,WACEhE,EAAEoD,UAAYpD,EAAEgE,OAtKlB,aA2KLhE,EAAEoD,UAzKOT,KAyK0C,IAApB3C,EAAET,KAAKmC,WAmD7CwC,EAAe,CAAClE,EAAGmE,KACrB,IAAIC,EACAC,EACJ,OAAS,CACL,GAAIrE,EAAEoD,UAhOQT,IAgOmB,CAE7B,GADAW,EAAYtD,GACRA,EAAEoD,UAlOIT,KAkOyBwB,IAAUtG,EACzC,OA1NK,EA4NT,GAAoB,IAAhBmC,EAAEoD,UACF,MAYR,GATAgB,EAAY,EACRpE,EAAEoD,WA5OI,IA6ONpD,EAAEiE,MAAQlE,EAAKC,EAAGA,EAAEiE,MAAOjE,EAAE6C,OAAO7C,EAAEmB,SA7OhC,EA6OuD,IAC7DiD,EAAYpE,EAAEC,KAAKD,EAAEmB,SAAWnB,EAAE+C,QAAU/C,EAAE+D,KAAK/D,EAAEiE,OACrDjE,EAAE+D,KAAK/D,EAAEiE,OAASjE,EAAEmB,UAEN,IAAdiD,GAAmBpE,EAAEmB,SAAWiD,GAAapE,EAAE0C,OA/OrCC,MAgPV3C,EAAEsE,aAAetC,EAAchC,EAAGoE,IAElCpE,EAAEsE,cApPI,EAuPN,GAFAD,EAAS1G,EAAUqC,EAAGA,EAAEmB,SAAWnB,EAAEqD,YAAarD,EAAEsE,aArP9C,GAsPNtE,EAAEoD,WAAapD,EAAEsE,aACbtE,EAAEsE,cAAgBtE,EAAEuE,gBAAkBvE,EAAEoD,WAvPtC,EAuP8D,CAChEpD,EAAEsE,eACF,GACItE,EAAEmB,WACFnB,EAAEiE,MAAQlE,EAAKC,EAAGA,EAAEiE,MAAOjE,EAAE6C,OAAO7C,EAAEmB,SA3PxC,EA2P+D,IAC7DiD,EAAYpE,EAAEC,KAAKD,EAAEmB,SAAWnB,EAAE+C,QAAU/C,EAAE+D,KAAK/D,EAAEiE,OACrDjE,EAAE+D,KAAK/D,EAAEiE,OAASjE,EAAEmB,eACM,KAAnBnB,EAAEsE,cACbtE,EAAEmB,gBAEFnB,EAAEmB,UAAYnB,EAAEsE,aAChBtE,EAAEsE,aAAe,EACjBtE,EAAEiE,MAAQjE,EAAE6C,OAAO7C,EAAEmB,UACrBnB,EAAEiE,MAAQlE,EAAKC,EAAGA,EAAEiE,MAAOjE,EAAE6C,OAAO7C,EAAEmB,SAAW,SAGrDkD,EAAS1G,EAAUqC,EAAG,EAAGA,EAAE6C,OAAO7C,EAAEmB,WACpCnB,EAAEoD,YACFpD,EAAEmB,WAEN,GAAIkD,IACArD,EAAiBhB,GAAG,GACK,IAArBA,EAAET,KAAKiB,WACP,OAnQK,EAwQjB,OADAR,EAAEgE,OAAShE,EAAEmB,SAAWqD,EAAgBxE,EAAEmB,SAAWqD,EACjDL,IAAUnG,GACVgD,EAAiBhB,GAAG,GACK,IAArBA,EAAET,KAAKiB,UAxQO,EACH,GA4QfR,EAAEyE,WACFzD,EAAiBhB,GAAG,GACK,IAArBA,EAAET,KAAKiB,WAjRE,EACC,GAsRhBkE,EAAe,CAAC1E,EAAGmE,KACrB,IAAIC,EACAC,EACAM,EACJ,OAAS,CACL,GAAI3E,EAAEoD,UArSQT,IAqSmB,CAE7B,GADAW,EAAYtD,GACRA,EAAEoD,UAvSIT,KAuSyBwB,IAAUtG,EACzC,OA/RK,EAiST,GAAoB,IAAhBmC,EAAEoD,UACF,MAkBR,GAfAgB,EAAY,EACRpE,EAAEoD,WAjTI,IAkTNpD,EAAEiE,MAAQlE,EAAKC,EAAGA,EAAEiE,MAAOjE,EAAE6C,OAAO7C,EAAEmB,SAlThC,EAkTuD,IAC7DiD,EAAYpE,EAAEC,KAAKD,EAAEmB,SAAWnB,EAAE+C,QAAU/C,EAAE+D,KAAK/D,EAAEiE,OACrDjE,EAAE+D,KAAK/D,EAAEiE,OAASjE,EAAEmB,UAExBnB,EAAEuC,YAAcvC,EAAEsE,aAClBtE,EAAE4E,WAAa5E,EAAEqD,YACjBrD,EAAEsE,aAAeE,EACC,IAAdJ,GAAmBpE,EAAEuC,YAAcvC,EAAEuE,gBAAkBvE,EAAEmB,SAAWiD,GAAapE,EAAE0C,OAvTzEC,MAwTV3C,EAAEsE,aAAetC,EAAchC,EAAGoE,GAC9BpE,EAAEsE,cAAgB,IAAMtE,EAAE6E,WAAarG,GA3TrC,IA2TmDwB,EAAEsE,cAA8BtE,EAAEmB,SAAWnB,EAAEqD,YAAc,QAClHrD,EAAEsE,aAAeE,IAGrBxE,EAAEuC,aA/TI,GA+TwBvC,EAAEsE,cAAgBtE,EAAEuC,YAAa,CAC/DoC,EAAa3E,EAAEmB,SAAWnB,EAAEoD,UAhUtB,EAiUNiB,EAAS1G,EAAUqC,EAAGA,EAAEmB,SAAW,EAAInB,EAAE4E,WAAY5E,EAAEuC,YAjUjD,GAkUNvC,EAAEoD,WAAapD,EAAEuC,YAAc,EAC/BvC,EAAEuC,aAAe,EACjB,KACUvC,EAAEmB,UAAYwD,IAChB3E,EAAEiE,MAAQlE,EAAKC,EAAGA,EAAEiE,MAAOjE,EAAE6C,OAAO7C,EAAEmB,SAtUxC,EAsU+D,IAC7DiD,EAAYpE,EAAEC,KAAKD,EAAEmB,SAAWnB,EAAE+C,QAAU/C,EAAE+D,KAAK/D,EAAEiE,OACrDjE,EAAE+D,KAAK/D,EAAEiE,OAASjE,EAAEmB,gBAEC,KAAlBnB,EAAEuC,aAIb,GAHAvC,EAAE8E,gBAAkB,EACpB9E,EAAEsE,aAAeE,EACjBxE,EAAEmB,WACEkD,IACArD,EAAiBhB,GAAG,GACK,IAArBA,EAAET,KAAKiB,WACP,OAtUC,OAyUN,GAAIR,EAAE8E,iBAOT,IANAT,EAAS1G,EAAUqC,EAAG,EAAGA,EAAE6C,OAAO7C,EAAEmB,SAAW,MAE3CH,EAAiBhB,GAAG,GAExBA,EAAEmB,WACFnB,EAAEoD,YACuB,IAArBpD,EAAET,KAAKiB,UACP,OAjVK,OAoVTR,EAAE8E,gBAAkB,EACpB9E,EAAEmB,WACFnB,EAAEoD,YAQV,OALIpD,EAAE8E,kBACFT,EAAS1G,EAAUqC,EAAG,EAAGA,EAAE6C,OAAO7C,EAAEmB,SAAW,IAC/CnB,EAAE8E,gBAAkB,GAExB9E,EAAEgE,OAAShE,EAAEmB,SAAWqD,EAAgBxE,EAAEmB,SAAWqD,EACjDL,IAAUnG,GACVgD,EAAiBhB,GAAG,GACK,IAArBA,EAAET,KAAKiB,UA9VO,EACH,GAkWfR,EAAEyE,WACFzD,EAAiBhB,GAAG,GACK,IAArBA,EAAET,KAAKiB,WAvWE,EACC,GAidtB,SAASuE,EAAOC,EAAaC,EAAUC,EAAaC,EAAWC,GAC3DC,KAAKL,YAAcA,EACnBK,KAAKJ,SAAWA,EAChBI,KAAKH,YAAcA,EACnBG,KAAKF,UAAYA,EACjBE,KAAKD,KAAOA,EAEhB,MAAME,GACF,IAAIP,EAAO,EAAG,EAAG,EAAG,EAxTD,CAAC/E,EAAGmE,KACvB,IAAIoB,EAAiB,MAIrB,IAHIA,EAAiBvF,EAAEwF,iBAAmB,IACtCD,EAAiBvF,EAAEwF,iBAAmB,KAEjC,CACL,GAAIxF,EAAEoD,WAAa,EAAG,CAElB,GADAE,EAAYtD,GACQ,IAAhBA,EAAEoD,WAAmBe,IAAUtG,EAC/B,OA3KK,EA6KT,GAAoB,IAAhBmC,EAAEoD,UACF,MAGRpD,EAAEmB,UAAYnB,EAAEoD,UAChBpD,EAAEoD,UAAY,EACd,MAAMqC,EAAYzF,EAAEkB,YAAcqE,EAClC,IAAmB,IAAfvF,EAAEmB,UAAkBnB,EAAEmB,UAAYsE,KAClCzF,EAAEoD,UAAYpD,EAAEmB,SAAWsE,EAC3BzF,EAAEmB,SAAWsE,EACbzE,EAAiBhB,GAAG,GACK,IAArBA,EAAET,KAAKiB,WACP,OAzLK,EA4Lb,GAAIR,EAAEmB,SAAWnB,EAAEkB,aAAelB,EAAE0C,OArMtBC,MAsMV3B,EAAiBhB,GAAG,GACK,IAArBA,EAAET,KAAKiB,WACP,OA/LK,EAoMjB,OADAR,EAAEgE,OAAS,EACPG,IAAUnG,GACVgD,EAAiBhB,GAAG,GACK,IAArBA,EAAET,KAAKiB,UApMO,EACH,IAwMfR,EAAEmB,SAAWnB,EAAEkB,cACfF,EAAiBhB,GAAG,GAChBA,EAAET,KAAKiB,WA7ME,KA2djB,IAAIuE,EAAO,EAAG,EAAG,EAAG,EAAGb,GACvB,IAAIa,EAAO,EAAG,EAAG,GAAI,EAAGb,GACxB,IAAIa,EAAO,EAAG,EAAG,GAAI,GAAIb,GACzB,IAAIa,EAAO,EAAG,EAAG,GAAI,GAAIL,GACzB,IAAIK,EAAO,EAAG,GAAI,GAAI,GAAIL,GAC1B,IAAIK,EAAO,EAAG,GAAI,IAAK,IAAKL,GAC5B,IAAIK,EAAO,EAAG,GAAI,IAAK,IAAKL,GAC5B,IAAIK,EAAO,GAAI,IAAK,IAAK,KAAML,GAC/B,IAAIK,EAAO,GAAI,IAAK,IAAK,KAAML,IAkFnC,MAAMgB,EAAmBnG,IACrB,IAAKA,IAASA,EAAKe,MACf,OAAOhB,EAAIC,EAAMnB,GAErBmB,EAAKwC,SAAWxC,EAAKwB,UAAY,EACjCxB,EAAKoG,UAAY9G,EACjB,MAAMmB,EAAIT,EAAKe,MAUf,OATAN,EAAEO,QAAU,EACZP,EAAEa,YAAc,EACZb,EAAE6B,KAAO,IACT7B,EAAE6B,MAAQ7B,EAAE6B,MAEhB7B,EAAE4F,OAAS5F,EAAE6B,KAxkBE,GAKA,IAokBftC,EAAKuC,MAAmB,IAAX9B,EAAE6B,KAAa,EAAI,EAChC7B,EAAE6F,WAAahI,EACfL,EAASwC,GACF9B,GAEL4H,EAAevG,IACjB,MAAMwG,EAAML,EAAiBnG,GAI7B,OAHIwG,IAAQ7H,KApGA8B,EAqGAT,EAAKe,OApGfuD,YAAc,EAAI7D,EAAE0C,OACtB/C,EAAKK,EAAE+D,MACP/D,EAAEuE,eAAiBe,EAAoBtF,EAAEgG,OAAOf,SAChDjF,EAAEmD,WAAamC,EAAoBtF,EAAEgG,OAAOhB,YAC5ChF,EAAEwC,WAAa8C,EAAoBtF,EAAEgG,OAAOd,YAC5ClF,EAAEoC,iBAAmBkD,EAAoBtF,EAAEgG,OAAOb,UAClDnF,EAAEmB,SAAW,EACbnB,EAAEkB,YAAc,EAChBlB,EAAEoD,UAAY,EACdpD,EAAEgE,OAAS,EACXhE,EAAEsE,aAAetE,EAAEuC,YAAciC,EACjCxE,EAAE8E,gBAAkB,EACpB9E,EAAEiE,MAAQ,GA0FH8B,GAvGK/F,IAAAA,EAyGhB,MAUMiG,EAAe,CAAC1G,EAAMyG,EAAOE,EAAQC,EAAYC,EAAUvB,KAC7D,IAAKtF,EACD,OAAOnB,EAEX,IAAIyD,EAAO,EAWX,GAVImE,IAAUzH,IACVyH,EAAQ,GAERG,EAAa,GACbtE,EAAO,EACPsE,GAAcA,GACPA,EAAa,KACpBtE,EAAO,EACPsE,GAAc,IAEdC,EAAW,GAAKA,EA5nBF,GA4nB8BF,IAAWpH,GAAcqH,EAAa,GAAKA,EAAa,IAAMH,EAAQ,GAAKA,EAAQ,GAAKnB,EAAW,GAAKA,EAAWlG,EAC/J,OAAOW,EAAIC,EAAMnB,GAEF,IAAf+H,IACAA,EAAa,GAEjB,MAAMnG,EAAI,IAzHd,WACIqF,KAAK9F,KAAO,KACZ8F,KAAKO,OAAS,EACdP,KAAK1E,YAAc,KACnB0E,KAAKG,iBAAmB,EACxBH,KAAKxE,YAAc,EACnBwE,KAAK9E,QAAU,EACf8E,KAAKxD,KAAO,EACZwD,KAAKgB,OAAS,KACdhB,KAAKiB,QAAU,EACfjB,KAAKa,OAASpH,EACduG,KAAKQ,YAAc,EACnBR,KAAK3C,OAAS,EACd2C,KAAKkB,OAAS,EACdlB,KAAKtC,OAAS,EACdsC,KAAKxC,OAAS,KACdwC,KAAKxB,YAAc,EACnBwB,KAAKpF,KAAO,KACZoF,KAAKtB,KAAO,KACZsB,KAAKpB,MAAQ,EACboB,KAAKvB,UAAY,EACjBuB,KAAKmB,UAAY,EACjBnB,KAAKjF,UAAY,EACjBiF,KAAKlF,WAAa,EAClBkF,KAAKnE,YAAc,EACnBmE,KAAKf,aAAe,EACpBe,KAAKT,WAAa,EAClBS,KAAKP,gBAAkB,EACvBO,KAAKlE,SAAW,EAChBkE,KAAKhC,YAAc,EACnBgC,KAAKjC,UAAY,EACjBiC,KAAK9C,YAAc,EACnB8C,KAAKjD,iBAAmB,EACxBiD,KAAKd,eAAiB,EACtBc,KAAKW,MAAQ,EACbX,KAAKR,SAAW,EAChBQ,KAAKlC,WAAa,EAClBkC,KAAK7C,WAAa,EAClB6C,KAAKoB,UAAY,IAAIC,YAAwB,EAAZtH,GACjCiG,KAAKsB,UAAY,IAAID,YAAgC,GAAnB,EAAIxH,EAAU,IAChDmG,KAAKuB,QAAU,IAAIF,YAAiC,GAApB,EAAIvH,EAAW,IAC/CQ,EAAK0F,KAAKoB,WACV9G,EAAK0F,KAAKsB,WACVhH,EAAK0F,KAAKuB,SACVvB,KAAKwB,OAAS,KACdxB,KAAKyB,OAAS,KACdzB,KAAK0B,QAAU,KACf1B,KAAK2B,SAAW,IAAIN,YAAYrH,EAAW,GAC3CgG,KAAK4B,KAAO,IAAIP,YAAY,EAAI1H,EAAU,GAC1CW,EAAK0F,KAAK4B,MACV5B,KAAK6B,SAAW,EAChB7B,KAAK8B,SAAW,EAChB9B,KAAK+B,MAAQ,IAAIV,YAAY,EAAI1H,EAAU,GAC3CW,EAAK0F,KAAK+B,OACV/B,KAAKgC,MAAQ,EACbhC,KAAKiC,YAAc,EACnBjC,KAAKZ,SAAW,EAChBY,KAAKkC,MAAQ,EACblC,KAAKmC,QAAU,EACfnC,KAAKoC,WAAa,EAClBpC,KAAKqC,QAAU,EACfrC,KAAKrB,OAAS,EACdqB,KAAKsC,OAAS,EACdtC,KAAKuC,SAAW,GAiFhB,OAtBArI,EAAKe,MAAQN,EACbA,EAAET,KAAOA,EACTS,EAAE6B,KAAOA,EACT7B,EAAEqG,OAAS,KACXrG,EAAEuG,OAASJ,EACXnG,EAAE0C,OAAS,GAAK1C,EAAEuG,OAClBvG,EAAE+C,OAAS/C,EAAE0C,OAAS,EACtB1C,EAAEwG,UAAYJ,EAAW,EACzBpG,EAAE8D,UAAY,GAAK9D,EAAEwG,UACrBxG,EAAEI,UAAYJ,EAAE8D,UAAY,EAC5B9D,EAAEG,eAAiBH,EAAEwG,UAnoBP,EAmoB+B,GAnoB/B,GAooBdxG,EAAE6C,OAAS,IAAIgF,WAAsB,EAAX7H,EAAE0C,QAC5B1C,EAAE+D,KAAO,IAAI2C,YAAY1G,EAAE8D,WAC3B9D,EAAEC,KAAO,IAAIyG,YAAY1G,EAAE0C,QAC3B1C,EAAEsH,YAAc,GAAKlB,EAAW,EAChCpG,EAAEwF,iBAAmC,EAAhBxF,EAAEsH,YACvBtH,EAAEW,YAAc,IAAIkH,WAAW7H,EAAEwF,kBACjCxF,EAAEuH,MAAQ,EAAIvH,EAAEsH,YAChBtH,EAAEqH,MAAQ,EAAUrH,EAAEsH,YACtBtH,EAAEgG,MAAQA,EACVhG,EAAE6E,SAAWA,EACb7E,EAAEkG,OAASA,EACJJ,EAAavG,IAmUxB,OACEuI,YAlUkB,CAACvI,EAAMyG,IAChBC,EAAa1G,EAAMyG,EAAOlH,EA3pBnB,GACI,EA0pBqDF,GAkUzEqH,aAAAA,EACAH,aAAAA,EACAJ,iBAAAA,EACAqC,iBA9XuB,CAACxI,EAAMwE,IACvBxE,GAASA,EAAKe,MAGK,IAApBf,EAAKe,MAAMuB,KACJzD,GAEXmB,EAAKe,MAAM+F,OAAStC,EACb7F,GANIE,EA6Xb4J,QApUc,CAACzI,EAAM4E,KACnB,IAAI8D,EAAKC,EACT,IAAK3I,IAASA,EAAKe,OAAS6D,EAAQlG,GAAWkG,EAAQ,EACnD,OAAO5E,EAAOD,EAAIC,EAAMnB,GAAkBA,EAE9C,MAAM4B,EAAIT,EAAKe,MACf,IAAKf,EAAKkB,SAAWlB,EAAKoC,OAA2B,IAAlBpC,EAAKmC,UAhpBvB,MAgpByC1B,EAAE4F,QAA2BzB,IAAUnG,EAC7F,OAAOsB,EAAIC,EAAyB,IAAnBA,EAAKiB,UAAkBlC,EAAcF,GAE1D4B,EAAET,KAAOA,EACT,MAAM4I,EAAYnI,EAAE6F,WAEpB,GADA7F,EAAE6F,WAAa1B,EA3pBA,KA4pBXnE,EAAE4F,OACF,GAAe,IAAX5F,EAAE6B,KACFtC,EAAKuC,MAAQ,EACbV,EAASpB,EAAG,IACZoB,EAASpB,EAAG,KACZoB,EAASpB,EAAG,GACPA,EAAEqG,QAUHjF,EAASpB,GAAIA,EAAEqG,OAAO+B,KAAO,EAAI,IAAMpI,EAAEqG,OAAOgC,KAAO,EAAI,IAAOrI,EAAEqG,OAAOiC,MAAY,EAAJ,IAAWtI,EAAEqG,OAAOkC,KAAW,EAAJ,IAAWvI,EAAEqG,OAAOmC,QAAc,GAAJ,IAC5IpH,EAASpB,EAAmB,IAAhBA,EAAEqG,OAAOoC,MACrBrH,EAASpB,EAAGA,EAAEqG,OAAOoC,MAAQ,EAAI,KACjCrH,EAASpB,EAAGA,EAAEqG,OAAOoC,MAAQ,GAAK,KAClCrH,EAASpB,EAAGA,EAAEqG,OAAOoC,MAAQ,GAAK,KAClCrH,EAASpB,EAAe,IAAZA,EAAEgG,MAAc,EAAIhG,EAAE6E,UAAYpG,GAAkBuB,EAAEgG,MAAQ,EAAI,EAAI,GAClF5E,EAASpB,EAAiB,IAAdA,EAAEqG,OAAOqC,IACjB1I,EAAEqG,OAAOiC,OAAStI,EAAEqG,OAAOiC,MAAMxI,SACjCsB,EAASpB,EAA2B,IAAxBA,EAAEqG,OAAOiC,MAAMxI,QAC3BsB,EAASpB,EAAGA,EAAEqG,OAAOiC,MAAMxI,QAAU,EAAI,MAEzCE,EAAEqG,OAAOgC,OACT9I,EAAKuC,MAAQzE,EAAMkC,EAAKuC,MAAO9B,EAAEW,YAAaX,EAAEO,QAAS,IAE7DP,EAAEsG,QAAU,EACZtG,EAAE4F,OA1rBE,KAkqBJxE,EAASpB,EAAG,GACZoB,EAASpB,EAAG,GACZoB,EAASpB,EAAG,GACZoB,EAASpB,EAAG,GACZoB,EAASpB,EAAG,GACZoB,EAASpB,EAAe,IAAZA,EAAEgG,MAAc,EAAIhG,EAAE6E,UAAYpG,GAAkBuB,EAAEgG,MAAQ,EAAI,EAAI,GAClF5E,EAASpB,EA9pBT,GA+pBAA,EAAE4F,OArqBC,SAwrBJ,CACH,IAAI+C,EAAS7J,GAAckB,EAAEuG,OAAS,GAAK,IAAM,EAC7CqC,GAAe,EAUnBD,IARIC,EADA5I,EAAE6E,UAAYpG,GAAkBuB,EAAEgG,MAAQ,EAC5B,EACPhG,EAAEgG,MAAQ,EACH,EACK,IAAZhG,EAAEgG,MACK,EAEA,IAEO,EACN,IAAfhG,EAAEmB,WACFwH,GA5sBI,IA8sBRA,GAAU,GAAKA,EAAS,GACxB3I,EAAE4F,OAzsBK,IA0sBPtE,EAAYtB,EAAG2I,GACI,IAAf3I,EAAEmB,WACFG,EAAYtB,EAAGT,EAAKuC,QAAU,IAC9BR,EAAYtB,EAAgB,MAAbT,EAAKuC,QAExBvC,EAAKuC,MAAQ,EAGrB,GAttBgB,KAstBZ9B,EAAE4F,OACF,GAAI5F,EAAEqG,OAAOiC,MAAO,CAEhB,IADAL,EAAMjI,EAAEO,QACDP,EAAEsG,SAAmC,MAAxBtG,EAAEqG,OAAOiC,MAAMxI,UAC3BE,EAAEO,UAAYP,EAAEwF,mBACZxF,EAAEqG,OAAOgC,MAAQrI,EAAEO,QAAU0H,IAC7B1I,EAAKuC,MAAQzE,EAAMkC,EAAKuC,MAAO9B,EAAEW,YAAaX,EAAEO,QAAU0H,EAAKA,IAEnE5H,EAAcd,GACd0I,EAAMjI,EAAEO,QACJP,EAAEO,UAAYP,EAAEwF,oBAIxBpE,EAASpB,EAA+B,IAA5BA,EAAEqG,OAAOiC,MAAMtI,EAAEsG,UAC7BtG,EAAEsG,UAEFtG,EAAEqG,OAAOgC,MAAQrI,EAAEO,QAAU0H,IAC7B1I,EAAKuC,MAAQzE,EAAMkC,EAAKuC,MAAO9B,EAAEW,YAAaX,EAAEO,QAAU0H,EAAKA,IAE/DjI,EAAEsG,UAAYtG,EAAEqG,OAAOiC,MAAMxI,SAC7BE,EAAEsG,QAAU,EACZtG,EAAE4F,OA3uBC,SA8uBP5F,EAAE4F,OA9uBK,GAivBf,GAjvBe,KAivBX5F,EAAE4F,OACF,GAAI5F,EAAEqG,OAAOkC,KAAM,CACfN,EAAMjI,EAAEO,QACR,EAAG,CACC,GAAIP,EAAEO,UAAYP,EAAEwF,mBACZxF,EAAEqG,OAAOgC,MAAQrI,EAAEO,QAAU0H,IAC7B1I,EAAKuC,MAAQzE,EAAMkC,EAAKuC,MAAO9B,EAAEW,YAAaX,EAAEO,QAAU0H,EAAKA,IAEnE5H,EAAcd,GACd0I,EAAMjI,EAAEO,QACJP,EAAEO,UAAYP,EAAEwF,kBAAkB,CAClC0C,EAAM,EACN,MAIJA,EADAlI,EAAEsG,QAAUtG,EAAEqG,OAAOkC,KAAKzI,OACoB,IAAxCE,EAAEqG,OAAOkC,KAAKM,WAAW7I,EAAEsG,WAE3B,EAEVlF,EAASpB,EAAGkI,SACC,IAARA,GACLlI,EAAEqG,OAAOgC,MAAQrI,EAAEO,QAAU0H,IAC7B1I,EAAKuC,MAAQzE,EAAMkC,EAAKuC,MAAO9B,EAAEW,YAAaX,EAAEO,QAAU0H,EAAKA,IAEvD,IAARC,IACAlI,EAAEsG,QAAU,EACZtG,EAAE4F,OA3wBI,SA8wBV5F,EAAE4F,OA9wBQ,GAixBlB,GAjxBkB,KAixBd5F,EAAE4F,OACF,GAAI5F,EAAEqG,OAAOmC,QAAS,CAClBP,EAAMjI,EAAEO,QACR,EAAG,CACC,GAAIP,EAAEO,UAAYP,EAAEwF,mBACZxF,EAAEqG,OAAOgC,MAAQrI,EAAEO,QAAU0H,IAC7B1I,EAAKuC,MAAQzE,EAAMkC,EAAKuC,MAAO9B,EAAEW,YAAaX,EAAEO,QAAU0H,EAAKA,IAEnE5H,EAAcd,GACd0I,EAAMjI,EAAEO,QACJP,EAAEO,UAAYP,EAAEwF,kBAAkB,CAClC0C,EAAM,EACN,MAIJA,EADAlI,EAAEsG,QAAUtG,EAAEqG,OAAOmC,QAAQ1I,OACoB,IAA3CE,EAAEqG,OAAOmC,QAAQK,WAAW7I,EAAEsG,WAE9B,EAEVlF,EAASpB,EAAGkI,SACC,IAARA,GACLlI,EAAEqG,OAAOgC,MAAQrI,EAAEO,QAAU0H,IAC7B1I,EAAKuC,MAAQzE,EAAMkC,EAAKuC,MAAO9B,EAAEW,YAAaX,EAAEO,QAAU0H,EAAKA,IAEvD,IAARC,IACAlI,EAAE4F,OA1yBC,UA6yBP5F,EAAE4F,OA7yBK,IA+zBf,GA/zBe,MAgzBX5F,EAAE4F,SACE5F,EAAEqG,OAAOgC,MACLrI,EAAEO,QAAU,EAAIP,EAAEwF,kBAClBnF,EAAcd,GAEdS,EAAEO,QAAU,GAAKP,EAAEwF,mBACnBpE,EAASpB,EAAgB,IAAbT,EAAKuC,OACjBV,EAASpB,EAAGT,EAAKuC,OAAS,EAAI,KAC9BvC,EAAKuC,MAAQ,EACb9B,EAAE4F,OAxzBC,MA2zBP5F,EAAE4F,OA3zBK,KA8zBG,IAAd5F,EAAEO,SAEF,GADAF,EAAcd,GACS,IAAnBA,EAAKiB,UAEL,OADAR,EAAE6F,YAAc,EACT3H,OAER,GAAsB,IAAlBqB,EAAKmC,UAAkBjC,EAAK0E,IAAU1E,EAAK0I,IAAchE,IAAUnG,EAC1E,OAAOsB,EAAIC,EAAMjB,GAErB,GAt0BiB,MAs0Bb0B,EAAE4F,QAA6C,IAAlBrG,EAAKmC,SAClC,OAAOpC,EAAIC,EAAMjB,GAErB,GAAsB,IAAlBiB,EAAKmC,UAAkC,IAAhB1B,EAAEoD,WAAmBe,IAAUtG,GAz0BzC,MAy0BuDmC,EAAE4F,OAAyB,CAC/F,IAAIkD,EAAS9I,EAAE6E,WAAapG,EA9Zf,EAACuB,EAAGmE,KACrB,IAAIE,EACJ,OAAS,CACL,GAAoB,IAAhBrE,EAAEoD,YACFE,EAAYtD,GACQ,IAAhBA,EAAEoD,WAAiB,CACnB,GAAIe,IAAUtG,EACV,OAlbC,EAobL,MAOR,GAJAmC,EAAEsE,aAAe,EACjBD,EAAS1G,EAAUqC,EAAG,EAAGA,EAAE6C,OAAO7C,EAAEmB,WACpCnB,EAAEoD,YACFpD,EAAEmB,WACEkD,IACArD,EAAiBhB,GAAG,GACK,IAArBA,EAAET,KAAKiB,WACP,OA9bK,EAmcjB,OADAR,EAAEgE,OAAS,EACPG,IAAUnG,GACVgD,EAAiBhB,GAAG,GACK,IAArBA,EAAET,KAAKiB,UAncO,EACH,GAucfR,EAAEyE,WACFzD,EAAiBhB,GAAG,GACK,IAArBA,EAAET,KAAKiB,WA5cE,EACC,GAw0B+BuI,CAAa/I,EAAGmE,GAASnE,EAAE6E,WAAanG,EA5dzE,EAACsB,EAAGmE,KACpB,IAAIE,EACApE,EACAoC,EAAMW,EACV,MAAMJ,EAAO5C,EAAE6C,OACf,OAAS,CACL,GAAI7C,EAAEoD,WA7XI,IA6XoB,CAE1B,GADAE,EAAYtD,GACRA,EAAEoD,WA/XA,KA+X0Be,IAAUtG,EACtC,OAtXK,EAwXT,GAAoB,IAAhBmC,EAAEoD,UACF,MAIR,GADApD,EAAEsE,aAAe,EACbtE,EAAEoD,WAxYI,GAwYsBpD,EAAEmB,SAAW,IAEzClB,EAAO2C,EADPP,EAAOrC,EAAEmB,SAAW,MAEPyB,IAAOP,IAASpC,IAAS2C,IAAOP,IAASpC,IAAS2C,IAAOP,GAAO,CACzEW,EAAShD,EAAEmB,SA3YT,IA4YF,UACSlB,IAAS2C,IAAOP,IAASpC,IAAS2C,IAAOP,IAASpC,IAAS2C,IAAOP,IAASpC,IAAS2C,IAAOP,IAASpC,IAAS2C,IAAOP,IAASpC,IAAS2C,IAAOP,IAASpC,IAAS2C,IAAOP,IAASpC,IAAS2C,IAAOP,IAASA,EAAOW,GACxNhD,EAAEsE,aA9YA,KA8Y4BtB,EAASX,GACnCrC,EAAEsE,aAAetE,EAAEoD,YACnBpD,EAAEsE,aAAetE,EAAEoD,WAc/B,GAVIpD,EAAEsE,cArZI,GAsZND,EAAS1G,EAAUqC,EAAG,EAAGA,EAAEsE,aAtZrB,GAuZNtE,EAAEoD,WAAapD,EAAEsE,aACjBtE,EAAEmB,UAAYnB,EAAEsE,aAChBtE,EAAEsE,aAAe,IAEjBD,EAAS1G,EAAUqC,EAAG,EAAGA,EAAE6C,OAAO7C,EAAEmB,WACpCnB,EAAEoD,YACFpD,EAAEmB,YAEFkD,IACArD,EAAiBhB,GAAG,GACK,IAArBA,EAAET,KAAKiB,WACP,OAvZK,EA4ZjB,OADAR,EAAEgE,OAAS,EACPG,IAAUnG,GACVgD,EAAiBhB,GAAG,GACK,IAArBA,EAAET,KAAKiB,UA5ZO,EACH,GAgafR,EAAEyE,WACFzD,EAAiBhB,GAAG,GACK,IAArBA,EAAET,KAAKiB,WAraE,EACC,GAw0B+EwI,CAAYhJ,EAAGmE,GAASmB,EAAoBtF,EAAEgG,OAAOZ,KAAKpF,EAAGmE,GAI1J,GA30BkB,IAw0Bd2E,GAv0BW,IAu0BqBA,IAChC9I,EAAE4F,OA50BO,KACA,IA60BTkD,GA30Bc,IA20BaA,EAI3B,OAHuB,IAAnBvJ,EAAKiB,YACLR,EAAE6F,YAAc,GAEb3H,EAEX,GAl1Bc,IAk1BV4K,IACI3E,IAAUrG,EACVF,EAAUoC,GACHmE,IAAUlG,IACjBR,EAAiBuC,EAAG,EAAG,GAAG,GACtBmE,IAAUpG,IACV4B,EAAKK,EAAE+D,MACa,IAAhB/D,EAAEoD,YACFpD,EAAEmB,SAAW,EACbnB,EAAEkB,YAAc,EAChBlB,EAAEgE,OAAS,KAIvB3D,EAAcd,GACS,IAAnBA,EAAKiB,WAEL,OADAR,EAAE6F,YAAc,EACT3H,EAInB,OAAIiG,IAAUnG,EACHE,EAEP8B,EAAE6B,MAAQ,EACH1D,GAEI,IAAX6B,EAAE6B,MACFT,EAASpB,EAAgB,IAAbT,EAAKuC,OACjBV,EAASpB,EAAGT,EAAKuC,OAAS,EAAI,KAC9BV,EAASpB,EAAGT,EAAKuC,OAAS,GAAK,KAC/BV,EAASpB,EAAGT,EAAKuC,OAAS,GAAK,KAC/BV,EAASpB,EAAmB,IAAhBT,EAAKwC,UACjBX,EAASpB,EAAGT,EAAKwC,UAAY,EAAI,KACjCX,EAASpB,EAAGT,EAAKwC,UAAY,GAAK,KAClCX,EAASpB,EAAGT,EAAKwC,UAAY,GAAK,OAElCT,EAAYtB,EAAGT,EAAKuC,QAAU,IAC9BR,EAAYtB,EAAgB,MAAbT,EAAKuC,QAExBzB,EAAcd,GACVS,EAAE6B,KAAO,IACT7B,EAAE6B,MAAQ7B,EAAE6B,MAEK,IAAd7B,EAAEO,QAAgBrC,EAAOC,IA+ElC8K,WA7EiB1J,IACf,IAAKA,IAASA,EAAKe,MACf,OAAOlC,EAEX,MAAMwH,EAASrG,EAAKe,MAAMsF,OAC1B,OA74Be,KA64BXA,GA54BY,KA44BaA,GA34Bd,KA24BwCA,GA14BrC,KA04B8DA,GAz4BjE,MAy4B6FA,GAx4B7F,MAw4BsHA,GAv4BpH,MAu4B6IA,EACnJtG,EAAIC,EAAMnB,IAErBmB,EAAKe,MAAQ,KA34BE,MA44BRsF,EAAwBtG,EAAIC,EAAMlB,GAAgBH,IAqE3DgL,qBAnE2B,CAAC3J,EAAM4J,KAChC,IAAIC,EAAaD,EAAWrJ,OAC5B,IAAKP,IAASA,EAAKe,MACf,OAAOlC,EAEX,MAAM4B,EAAIT,EAAKe,MACTuB,EAAO7B,EAAE6B,KACf,GAAa,IAATA,GAAuB,IAATA,GA15BH,KA05BiB7B,EAAE4F,QAAyB5F,EAAEoD,UACzD,OAAOhF,EAMX,GAJa,IAATyD,IACAtC,EAAKuC,MAAQ1E,EAAQmC,EAAKuC,MAAOqH,EAAYC,EAAY,IAE7DpJ,EAAE6B,KAAO,EACLuH,GAAcpJ,EAAE0C,OAAQ,CACX,IAATb,IACAlC,EAAKK,EAAE+D,MACP/D,EAAEmB,SAAW,EACbnB,EAAEkB,YAAc,EAChBlB,EAAEgE,OAAS,GAEf,IAAIqF,EAAU,IAAIxB,WAAW7H,EAAE0C,QAC/B2G,EAAQ3I,IAAIyI,EAAWvI,SAASwI,EAAapJ,EAAE0C,OAAQ0G,GAAa,GACpED,EAAaE,EACbD,EAAapJ,EAAE0C,OAEnB,MAAM4G,EAAQ/J,EAAKmC,SACb6H,EAAOhK,EAAKqC,QACZD,EAAQpC,EAAKoC,MAKnB,IAJApC,EAAKmC,SAAW0H,EAChB7J,EAAKqC,QAAU,EACfrC,EAAKoC,MAAQwH,EACb7F,EAAYtD,GACLA,EAAEoD,WAx7BK,GAw7BmB,CAC7B,IAAIQ,EAAM5D,EAAEmB,SACRsC,EAAIzD,EAAEoD,UAAY,EACtB,GACIpD,EAAEiE,MAAQlE,EAAKC,EAAGA,EAAEiE,MAAOjE,EAAE6C,OAAOe,EA57B9B,EA47BgD,IACtD5D,EAAEC,KAAK2D,EAAM5D,EAAE+C,QAAU/C,EAAE+D,KAAK/D,EAAEiE,OAClCjE,EAAE+D,KAAK/D,EAAEiE,OAASL,EAClBA,YACOH,GACXzD,EAAEmB,SAAWyC,EACb5D,EAAEoD,UAAYoB,EACdlB,EAAYtD,GAYhB,OAVAA,EAAEmB,UAAYnB,EAAEoD,UAChBpD,EAAEkB,YAAclB,EAAEmB,SAClBnB,EAAEgE,OAAShE,EAAEoD,UACbpD,EAAEoD,UAAY,EACdpD,EAAEsE,aAAetE,EAAEuC,YAAciC,EACjCxE,EAAE8E,gBAAkB,EACpBvF,EAAKqC,QAAU2H,EACfhK,EAAKoC,MAAQA,EACbpC,EAAKmC,SAAW4H,EAChBtJ,EAAE6B,KAAOA,EACF3D,GAYTsL,YAAc","file":"../../zlib/deflate.js","sourcesContent":["define([\n    './trees',\n    './adler32',\n    './crc32',\n    './messages',\n    './constants'\n], function (trees, adler32, crc32, msg, constants) {\n    'use strict';\n\n\n    const {_tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align} = trees;\n    const {Z_NO_FLUSH, Z_PARTIAL_FLUSH, Z_FULL_FLUSH, Z_FINISH, Z_BLOCK, Z_OK, Z_STREAM_END, Z_STREAM_ERROR, Z_DATA_ERROR, Z_BUF_ERROR, Z_DEFAULT_COMPRESSION, Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY, Z_UNKNOWN, Z_DEFLATED} = __module__4;\n\n    const MAX_MEM_LEVEL = 9;\n    const MAX_WBITS = 15;\n    const DEF_MEM_LEVEL = 8;\n    const LENGTH_CODES = 29;\n    const LITERALS = 256;\n    const L_CODES = LITERALS + 1 + LENGTH_CODES;\n    const D_CODES = 30;\n    const BL_CODES = 19;\n    const HEAP_SIZE = 2 * L_CODES + 1;\n    const MAX_BITS = 15;\n    const MIN_MATCH = 3;\n    const MAX_MATCH = 258;\n    const MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;\n    const PRESET_DICT = 32;\n    const INIT_STATE = 42;\n    const EXTRA_STATE = 69;\n    const NAME_STATE = 73;\n    const COMMENT_STATE = 91;\n    const HCRC_STATE = 103;\n    const BUSY_STATE = 113;\n    const FINISH_STATE = 666;\n    const BS_NEED_MORE = 1;\n    const BS_BLOCK_DONE = 2;\n    const BS_FINISH_STARTED = 3;\n    const BS_FINISH_DONE = 4;\n    const OS_CODE = 3;\n    const err = (strm, errorCode) => {\n        strm.msg = msg[errorCode];\n        return errorCode;\n    };\n    const rank = f => {\n        return (f << 1) - (f > 4 ? 9 : 0);\n    };\n    const zero = buf => {\n        let len = buf.length;\n        while (--len >= 0) {\n            buf[len] = 0;\n        }\n    };\n    let HASH_ZLIB = (s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask;\n    let HASH = HASH_ZLIB;\n    const flush_pending = strm => {\n        const s = strm.state;\n        let len = s.pending;\n        if (len > strm.avail_out) {\n            len = strm.avail_out;\n        }\n        if (len === 0) {\n            return;\n        }\n        strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);\n        strm.next_out += len;\n        s.pending_out += len;\n        strm.total_out += len;\n        strm.avail_out -= len;\n        s.pending -= len;\n        if (s.pending === 0) {\n            s.pending_out = 0;\n        }\n    };\n    const flush_block_only = (s, last) => {\n        _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);\n        s.block_start = s.strstart;\n        flush_pending(s.strm);\n    };\n    const put_byte = (s, b) => {\n        s.pending_buf[s.pending++] = b;\n    };\n    const putShortMSB = (s, b) => {\n        s.pending_buf[s.pending++] = b >>> 8 & 255;\n        s.pending_buf[s.pending++] = b & 255;\n    };\n    const read_buf = (strm, buf, start, size) => {\n        let len = strm.avail_in;\n        if (len > size) {\n            len = size;\n        }\n        if (len === 0) {\n            return 0;\n        }\n        strm.avail_in -= len;\n        buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);\n        if (strm.state.wrap === 1) {\n            strm.adler = adler32(strm.adler, buf, len, start);\n        } else if (strm.state.wrap === 2) {\n            strm.adler = crc32(strm.adler, buf, len, start);\n        }\n        strm.next_in += len;\n        strm.total_in += len;\n        return len;\n    };\n    const longest_match = (s, cur_match) => {\n        let chain_length = s.max_chain_length;\n        let scan = s.strstart;\n        let match;\n        let len;\n        let best_len = s.prev_length;\n        let nice_match = s.nice_match;\n        const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;\n        const _win = s.window;\n        const wmask = s.w_mask;\n        const prev = s.prev;\n        const strend = s.strstart + MAX_MATCH;\n        let scan_end1 = _win[scan + best_len - 1];\n        let scan_end = _win[scan + best_len];\n        if (s.prev_length >= s.good_match) {\n            chain_length >>= 2;\n        }\n        if (nice_match > s.lookahead) {\n            nice_match = s.lookahead;\n        }\n        do {\n            match = cur_match;\n            if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {\n                continue;\n            }\n            scan += 2;\n            match++;\n            do {\n            } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);\n            len = MAX_MATCH - (strend - scan);\n            scan = strend - MAX_MATCH;\n            if (len > best_len) {\n                s.match_start = cur_match;\n                best_len = len;\n                if (len >= nice_match) {\n                    break;\n                }\n                scan_end1 = _win[scan + best_len - 1];\n                scan_end = _win[scan + best_len];\n            }\n        } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n        if (best_len <= s.lookahead) {\n            return best_len;\n        }\n        return s.lookahead;\n    };\n    const fill_window = s => {\n        const _w_size = s.w_size;\n        let p, n, m, more, str;\n        do {\n            more = s.window_size - s.lookahead - s.strstart;\n            if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n                s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);\n                s.match_start -= _w_size;\n                s.strstart -= _w_size;\n                s.block_start -= _w_size;\n                n = s.hash_size;\n                p = n;\n                do {\n                    m = s.head[--p];\n                    s.head[p] = m >= _w_size ? m - _w_size : 0;\n                } while (--n);\n                n = _w_size;\n                p = n;\n                do {\n                    m = s.prev[--p];\n                    s.prev[p] = m >= _w_size ? m - _w_size : 0;\n                } while (--n);\n                more += _w_size;\n            }\n            if (s.strm.avail_in === 0) {\n                break;\n            }\n            n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n            s.lookahead += n;\n            if (s.lookahead + s.insert >= MIN_MATCH) {\n                str = s.strstart - s.insert;\n                s.ins_h = s.window[str];\n                s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);\n                while (s.insert) {\n                    s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);\n                    s.prev[str & s.w_mask] = s.head[s.ins_h];\n                    s.head[s.ins_h] = str;\n                    str++;\n                    s.insert--;\n                    if (s.lookahead + s.insert < MIN_MATCH) {\n                        break;\n                    }\n                }\n            }\n        } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n    };\n    const deflate_stored = (s, flush) => {\n        let max_block_size = 65535;\n        if (max_block_size > s.pending_buf_size - 5) {\n            max_block_size = s.pending_buf_size - 5;\n        }\n        for (;;) {\n            if (s.lookahead <= 1) {\n                fill_window(s);\n                if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n                    return BS_NEED_MORE;\n                }\n                if (s.lookahead === 0) {\n                    break;\n                }\n            }\n            s.strstart += s.lookahead;\n            s.lookahead = 0;\n            const max_start = s.block_start + max_block_size;\n            if (s.strstart === 0 || s.strstart >= max_start) {\n                s.lookahead = s.strstart - max_start;\n                s.strstart = max_start;\n                flush_block_only(s, false);\n                if (s.strm.avail_out === 0) {\n                    return BS_NEED_MORE;\n                }\n            }\n            if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {\n                flush_block_only(s, false);\n                if (s.strm.avail_out === 0) {\n                    return BS_NEED_MORE;\n                }\n            }\n        }\n        s.insert = 0;\n        if (flush === Z_FINISH) {\n            flush_block_only(s, true);\n            if (s.strm.avail_out === 0) {\n                return BS_FINISH_STARTED;\n            }\n            return BS_FINISH_DONE;\n        }\n        if (s.strstart > s.block_start) {\n            flush_block_only(s, false);\n            if (s.strm.avail_out === 0) {\n                return BS_NEED_MORE;\n            }\n        }\n        return BS_NEED_MORE;\n    };\n    const deflate_fast = (s, flush) => {\n        let hash_head;\n        let bflush;\n        for (;;) {\n            if (s.lookahead < MIN_LOOKAHEAD) {\n                fill_window(s);\n                if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n                    return BS_NEED_MORE;\n                }\n                if (s.lookahead === 0) {\n                    break;\n                }\n            }\n            hash_head = 0;\n            if (s.lookahead >= MIN_MATCH) {\n                s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n                s.head[s.ins_h] = s.strstart;\n            }\n            if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {\n                s.match_length = longest_match(s, hash_head);\n            }\n            if (s.match_length >= MIN_MATCH) {\n                bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n                s.lookahead -= s.match_length;\n                if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {\n                    s.match_length--;\n                    do {\n                        s.strstart++;\n                        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n                        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n                        s.head[s.ins_h] = s.strstart;\n                    } while (--s.match_length !== 0);\n                    s.strstart++;\n                } else {\n                    s.strstart += s.match_length;\n                    s.match_length = 0;\n                    s.ins_h = s.window[s.strstart];\n                    s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);\n                }\n            } else {\n                bflush = _tr_tally(s, 0, s.window[s.strstart]);\n                s.lookahead--;\n                s.strstart++;\n            }\n            if (bflush) {\n                flush_block_only(s, false);\n                if (s.strm.avail_out === 0) {\n                    return BS_NEED_MORE;\n                }\n            }\n        }\n        s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n        if (flush === Z_FINISH) {\n            flush_block_only(s, true);\n            if (s.strm.avail_out === 0) {\n                return BS_FINISH_STARTED;\n            }\n            return BS_FINISH_DONE;\n        }\n        if (s.last_lit) {\n            flush_block_only(s, false);\n            if (s.strm.avail_out === 0) {\n                return BS_NEED_MORE;\n            }\n        }\n        return BS_BLOCK_DONE;\n    };\n    const deflate_slow = (s, flush) => {\n        let hash_head;\n        let bflush;\n        let max_insert;\n        for (;;) {\n            if (s.lookahead < MIN_LOOKAHEAD) {\n                fill_window(s);\n                if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n                    return BS_NEED_MORE;\n                }\n                if (s.lookahead === 0) {\n                    break;\n                }\n            }\n            hash_head = 0;\n            if (s.lookahead >= MIN_MATCH) {\n                s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n                s.head[s.ins_h] = s.strstart;\n            }\n            s.prev_length = s.match_length;\n            s.prev_match = s.match_start;\n            s.match_length = MIN_MATCH - 1;\n            if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {\n                s.match_length = longest_match(s, hash_head);\n                if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {\n                    s.match_length = MIN_MATCH - 1;\n                }\n            }\n            if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n                max_insert = s.strstart + s.lookahead - MIN_MATCH;\n                bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n                s.lookahead -= s.prev_length - 1;\n                s.prev_length -= 2;\n                do {\n                    if (++s.strstart <= max_insert) {\n                        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n                        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n                        s.head[s.ins_h] = s.strstart;\n                    }\n                } while (--s.prev_length !== 0);\n                s.match_available = 0;\n                s.match_length = MIN_MATCH - 1;\n                s.strstart++;\n                if (bflush) {\n                    flush_block_only(s, false);\n                    if (s.strm.avail_out === 0) {\n                        return BS_NEED_MORE;\n                    }\n                }\n            } else if (s.match_available) {\n                bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);\n                if (bflush) {\n                    flush_block_only(s, false);\n                }\n                s.strstart++;\n                s.lookahead--;\n                if (s.strm.avail_out === 0) {\n                    return BS_NEED_MORE;\n                }\n            } else {\n                s.match_available = 1;\n                s.strstart++;\n                s.lookahead--;\n            }\n        }\n        if (s.match_available) {\n            bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);\n            s.match_available = 0;\n        }\n        s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n        if (flush === Z_FINISH) {\n            flush_block_only(s, true);\n            if (s.strm.avail_out === 0) {\n                return BS_FINISH_STARTED;\n            }\n            return BS_FINISH_DONE;\n        }\n        if (s.last_lit) {\n            flush_block_only(s, false);\n            if (s.strm.avail_out === 0) {\n                return BS_NEED_MORE;\n            }\n        }\n        return BS_BLOCK_DONE;\n    };\n    const deflate_rle = (s, flush) => {\n        let bflush;\n        let prev;\n        let scan, strend;\n        const _win = s.window;\n        for (;;) {\n            if (s.lookahead <= MAX_MATCH) {\n                fill_window(s);\n                if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\n                    return BS_NEED_MORE;\n                }\n                if (s.lookahead === 0) {\n                    break;\n                }\n            }\n            s.match_length = 0;\n            if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n                scan = s.strstart - 1;\n                prev = _win[scan];\n                if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n                    strend = s.strstart + MAX_MATCH;\n                    do {\n                    } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);\n                    s.match_length = MAX_MATCH - (strend - scan);\n                    if (s.match_length > s.lookahead) {\n                        s.match_length = s.lookahead;\n                    }\n                }\n            }\n            if (s.match_length >= MIN_MATCH) {\n                bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);\n                s.lookahead -= s.match_length;\n                s.strstart += s.match_length;\n                s.match_length = 0;\n            } else {\n                bflush = _tr_tally(s, 0, s.window[s.strstart]);\n                s.lookahead--;\n                s.strstart++;\n            }\n            if (bflush) {\n                flush_block_only(s, false);\n                if (s.strm.avail_out === 0) {\n                    return BS_NEED_MORE;\n                }\n            }\n        }\n        s.insert = 0;\n        if (flush === Z_FINISH) {\n            flush_block_only(s, true);\n            if (s.strm.avail_out === 0) {\n                return BS_FINISH_STARTED;\n            }\n            return BS_FINISH_DONE;\n        }\n        if (s.last_lit) {\n            flush_block_only(s, false);\n            if (s.strm.avail_out === 0) {\n                return BS_NEED_MORE;\n            }\n        }\n        return BS_BLOCK_DONE;\n    };\n    const deflate_huff = (s, flush) => {\n        let bflush;\n        for (;;) {\n            if (s.lookahead === 0) {\n                fill_window(s);\n                if (s.lookahead === 0) {\n                    if (flush === Z_NO_FLUSH) {\n                        return BS_NEED_MORE;\n                    }\n                    break;\n                }\n            }\n            s.match_length = 0;\n            bflush = _tr_tally(s, 0, s.window[s.strstart]);\n            s.lookahead--;\n            s.strstart++;\n            if (bflush) {\n                flush_block_only(s, false);\n                if (s.strm.avail_out === 0) {\n                    return BS_NEED_MORE;\n                }\n            }\n        }\n        s.insert = 0;\n        if (flush === Z_FINISH) {\n            flush_block_only(s, true);\n            if (s.strm.avail_out === 0) {\n                return BS_FINISH_STARTED;\n            }\n            return BS_FINISH_DONE;\n        }\n        if (s.last_lit) {\n            flush_block_only(s, false);\n            if (s.strm.avail_out === 0) {\n                return BS_NEED_MORE;\n            }\n        }\n        return BS_BLOCK_DONE;\n    };\n    function Config(good_length, max_lazy, nice_length, max_chain, func) {\n        this.good_length = good_length;\n        this.max_lazy = max_lazy;\n        this.nice_length = nice_length;\n        this.max_chain = max_chain;\n        this.func = func;\n    }\n    const configuration_table = [\n        new Config(0, 0, 0, 0, deflate_stored),\n        new Config(4, 4, 8, 4, deflate_fast),\n        new Config(4, 5, 16, 8, deflate_fast),\n        new Config(4, 6, 32, 32, deflate_fast),\n        new Config(4, 4, 16, 16, deflate_slow),\n        new Config(8, 16, 32, 32, deflate_slow),\n        new Config(8, 16, 128, 128, deflate_slow),\n        new Config(8, 32, 128, 256, deflate_slow),\n        new Config(32, 128, 258, 1024, deflate_slow),\n        new Config(32, 258, 258, 4096, deflate_slow)\n    ];\n    const lm_init = s => {\n        s.window_size = 2 * s.w_size;\n        zero(s.head);\n        s.max_lazy_match = configuration_table[s.level].max_lazy;\n        s.good_match = configuration_table[s.level].good_length;\n        s.nice_match = configuration_table[s.level].nice_length;\n        s.max_chain_length = configuration_table[s.level].max_chain;\n        s.strstart = 0;\n        s.block_start = 0;\n        s.lookahead = 0;\n        s.insert = 0;\n        s.match_length = s.prev_length = MIN_MATCH - 1;\n        s.match_available = 0;\n        s.ins_h = 0;\n    };\n    function DeflateState() {\n        this.strm = null;\n        this.status = 0;\n        this.pending_buf = null;\n        this.pending_buf_size = 0;\n        this.pending_out = 0;\n        this.pending = 0;\n        this.wrap = 0;\n        this.gzhead = null;\n        this.gzindex = 0;\n        this.method = Z_DEFLATED;\n        this.last_flush = -1;\n        this.w_size = 0;\n        this.w_bits = 0;\n        this.w_mask = 0;\n        this.window = null;\n        this.window_size = 0;\n        this.prev = null;\n        this.head = null;\n        this.ins_h = 0;\n        this.hash_size = 0;\n        this.hash_bits = 0;\n        this.hash_mask = 0;\n        this.hash_shift = 0;\n        this.block_start = 0;\n        this.match_length = 0;\n        this.prev_match = 0;\n        this.match_available = 0;\n        this.strstart = 0;\n        this.match_start = 0;\n        this.lookahead = 0;\n        this.prev_length = 0;\n        this.max_chain_length = 0;\n        this.max_lazy_match = 0;\n        this.level = 0;\n        this.strategy = 0;\n        this.good_match = 0;\n        this.nice_match = 0;\n        this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);\n        this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);\n        this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);\n        zero(this.dyn_ltree);\n        zero(this.dyn_dtree);\n        zero(this.bl_tree);\n        this.l_desc = null;\n        this.d_desc = null;\n        this.bl_desc = null;\n        this.bl_count = new Uint16Array(MAX_BITS + 1);\n        this.heap = new Uint16Array(2 * L_CODES + 1);\n        zero(this.heap);\n        this.heap_len = 0;\n        this.heap_max = 0;\n        this.depth = new Uint16Array(2 * L_CODES + 1);\n        zero(this.depth);\n        this.l_buf = 0;\n        this.lit_bufsize = 0;\n        this.last_lit = 0;\n        this.d_buf = 0;\n        this.opt_len = 0;\n        this.static_len = 0;\n        this.matches = 0;\n        this.insert = 0;\n        this.bi_buf = 0;\n        this.bi_valid = 0;\n    }\n    const deflateResetKeep = strm => {\n        if (!strm || !strm.state) {\n            return err(strm, Z_STREAM_ERROR);\n        }\n        strm.total_in = strm.total_out = 0;\n        strm.data_type = Z_UNKNOWN;\n        const s = strm.state;\n        s.pending = 0;\n        s.pending_out = 0;\n        if (s.wrap < 0) {\n            s.wrap = -s.wrap;\n        }\n        s.status = s.wrap ? INIT_STATE : BUSY_STATE;\n        strm.adler = s.wrap === 2 ? 0 : 1;\n        s.last_flush = Z_NO_FLUSH;\n        _tr_init(s);\n        return Z_OK;\n    };\n    const deflateReset = strm => {\n        const ret = deflateResetKeep(strm);\n        if (ret === Z_OK) {\n            lm_init(strm.state);\n        }\n        return ret;\n    };\n    const deflateSetHeader = (strm, head) => {\n        if (!strm || !strm.state) {\n            return Z_STREAM_ERROR;\n        }\n        if (strm.state.wrap !== 2) {\n            return Z_STREAM_ERROR;\n        }\n        strm.state.gzhead = head;\n        return Z_OK;\n    };\n    const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {\n        if (!strm) {\n            return Z_STREAM_ERROR;\n        }\n        let wrap = 1;\n        if (level === Z_DEFAULT_COMPRESSION) {\n            level = 6;\n        }\n        if (windowBits < 0) {\n            wrap = 0;\n            windowBits = -windowBits;\n        } else if (windowBits > 15) {\n            wrap = 2;\n            windowBits -= 16;\n        }\n        if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {\n            return err(strm, Z_STREAM_ERROR);\n        }\n        if (windowBits === 8) {\n            windowBits = 9;\n        }\n        const s = new DeflateState();\n        strm.state = s;\n        s.strm = strm;\n        s.wrap = wrap;\n        s.gzhead = null;\n        s.w_bits = windowBits;\n        s.w_size = 1 << s.w_bits;\n        s.w_mask = s.w_size - 1;\n        s.hash_bits = memLevel + 7;\n        s.hash_size = 1 << s.hash_bits;\n        s.hash_mask = s.hash_size - 1;\n        s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n        s.window = new Uint8Array(s.w_size * 2);\n        s.head = new Uint16Array(s.hash_size);\n        s.prev = new Uint16Array(s.w_size);\n        s.lit_bufsize = 1 << memLevel + 6;\n        s.pending_buf_size = s.lit_bufsize * 4;\n        s.pending_buf = new Uint8Array(s.pending_buf_size);\n        s.d_buf = 1 * s.lit_bufsize;\n        s.l_buf = (1 + 2) * s.lit_bufsize;\n        s.level = level;\n        s.strategy = strategy;\n        s.method = method;\n        return deflateReset(strm);\n    };\n    const deflateInit = (strm, level) => {\n        return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n    };\n    const deflate = (strm, flush) => {\n        let beg, val;\n        if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {\n            return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n        }\n        const s = strm.state;\n        if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {\n            return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);\n        }\n        s.strm = strm;\n        const old_flush = s.last_flush;\n        s.last_flush = flush;\n        if (s.status === INIT_STATE) {\n            if (s.wrap === 2) {\n                strm.adler = 0;\n                put_byte(s, 31);\n                put_byte(s, 139);\n                put_byte(s, 8);\n                if (!s.gzhead) {\n                    put_byte(s, 0);\n                    put_byte(s, 0);\n                    put_byte(s, 0);\n                    put_byte(s, 0);\n                    put_byte(s, 0);\n                    put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);\n                    put_byte(s, OS_CODE);\n                    s.status = BUSY_STATE;\n                } else {\n                    put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));\n                    put_byte(s, s.gzhead.time & 255);\n                    put_byte(s, s.gzhead.time >> 8 & 255);\n                    put_byte(s, s.gzhead.time >> 16 & 255);\n                    put_byte(s, s.gzhead.time >> 24 & 255);\n                    put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);\n                    put_byte(s, s.gzhead.os & 255);\n                    if (s.gzhead.extra && s.gzhead.extra.length) {\n                        put_byte(s, s.gzhead.extra.length & 255);\n                        put_byte(s, s.gzhead.extra.length >> 8 & 255);\n                    }\n                    if (s.gzhead.hcrc) {\n                        strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n                    }\n                    s.gzindex = 0;\n                    s.status = EXTRA_STATE;\n                }\n            } else {\n                let header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;\n                let level_flags = -1;\n                if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n                    level_flags = 0;\n                } else if (s.level < 6) {\n                    level_flags = 1;\n                } else if (s.level === 6) {\n                    level_flags = 2;\n                } else {\n                    level_flags = 3;\n                }\n                header |= level_flags << 6;\n                if (s.strstart !== 0) {\n                    header |= PRESET_DICT;\n                }\n                header += 31 - header % 31;\n                s.status = BUSY_STATE;\n                putShortMSB(s, header);\n                if (s.strstart !== 0) {\n                    putShortMSB(s, strm.adler >>> 16);\n                    putShortMSB(s, strm.adler & 65535);\n                }\n                strm.adler = 1;\n            }\n        }\n        if (s.status === EXTRA_STATE) {\n            if (s.gzhead.extra) {\n                beg = s.pending;\n                while (s.gzindex < (s.gzhead.extra.length & 65535)) {\n                    if (s.pending === s.pending_buf_size) {\n                        if (s.gzhead.hcrc && s.pending > beg) {\n                            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n                        }\n                        flush_pending(strm);\n                        beg = s.pending;\n                        if (s.pending === s.pending_buf_size) {\n                            break;\n                        }\n                    }\n                    put_byte(s, s.gzhead.extra[s.gzindex] & 255);\n                    s.gzindex++;\n                }\n                if (s.gzhead.hcrc && s.pending > beg) {\n                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n                }\n                if (s.gzindex === s.gzhead.extra.length) {\n                    s.gzindex = 0;\n                    s.status = NAME_STATE;\n                }\n            } else {\n                s.status = NAME_STATE;\n            }\n        }\n        if (s.status === NAME_STATE) {\n            if (s.gzhead.name) {\n                beg = s.pending;\n                do {\n                    if (s.pending === s.pending_buf_size) {\n                        if (s.gzhead.hcrc && s.pending > beg) {\n                            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n                        }\n                        flush_pending(strm);\n                        beg = s.pending;\n                        if (s.pending === s.pending_buf_size) {\n                            val = 1;\n                            break;\n                        }\n                    }\n                    if (s.gzindex < s.gzhead.name.length) {\n                        val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;\n                    } else {\n                        val = 0;\n                    }\n                    put_byte(s, val);\n                } while (val !== 0);\n                if (s.gzhead.hcrc && s.pending > beg) {\n                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n                }\n                if (val === 0) {\n                    s.gzindex = 0;\n                    s.status = COMMENT_STATE;\n                }\n            } else {\n                s.status = COMMENT_STATE;\n            }\n        }\n        if (s.status === COMMENT_STATE) {\n            if (s.gzhead.comment) {\n                beg = s.pending;\n                do {\n                    if (s.pending === s.pending_buf_size) {\n                        if (s.gzhead.hcrc && s.pending > beg) {\n                            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n                        }\n                        flush_pending(strm);\n                        beg = s.pending;\n                        if (s.pending === s.pending_buf_size) {\n                            val = 1;\n                            break;\n                        }\n                    }\n                    if (s.gzindex < s.gzhead.comment.length) {\n                        val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;\n                    } else {\n                        val = 0;\n                    }\n                    put_byte(s, val);\n                } while (val !== 0);\n                if (s.gzhead.hcrc && s.pending > beg) {\n                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n                }\n                if (val === 0) {\n                    s.status = HCRC_STATE;\n                }\n            } else {\n                s.status = HCRC_STATE;\n            }\n        }\n        if (s.status === HCRC_STATE) {\n            if (s.gzhead.hcrc) {\n                if (s.pending + 2 > s.pending_buf_size) {\n                    flush_pending(strm);\n                }\n                if (s.pending + 2 <= s.pending_buf_size) {\n                    put_byte(s, strm.adler & 255);\n                    put_byte(s, strm.adler >> 8 & 255);\n                    strm.adler = 0;\n                    s.status = BUSY_STATE;\n                }\n            } else {\n                s.status = BUSY_STATE;\n            }\n        }\n        if (s.pending !== 0) {\n            flush_pending(strm);\n            if (strm.avail_out === 0) {\n                s.last_flush = -1;\n                return Z_OK;\n            }\n        } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {\n            return err(strm, Z_BUF_ERROR);\n        }\n        if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n            return err(strm, Z_BUF_ERROR);\n        }\n        if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {\n            let bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);\n            if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n                s.status = FINISH_STATE;\n            }\n            if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n                if (strm.avail_out === 0) {\n                    s.last_flush = -1;\n                }\n                return Z_OK;\n            }\n            if (bstate === BS_BLOCK_DONE) {\n                if (flush === Z_PARTIAL_FLUSH) {\n                    _tr_align(s);\n                } else if (flush !== Z_BLOCK) {\n                    _tr_stored_block(s, 0, 0, false);\n                    if (flush === Z_FULL_FLUSH) {\n                        zero(s.head);\n                        if (s.lookahead === 0) {\n                            s.strstart = 0;\n                            s.block_start = 0;\n                            s.insert = 0;\n                        }\n                    }\n                }\n                flush_pending(strm);\n                if (strm.avail_out === 0) {\n                    s.last_flush = -1;\n                    return Z_OK;\n                }\n            }\n        }\n        if (flush !== Z_FINISH) {\n            return Z_OK;\n        }\n        if (s.wrap <= 0) {\n            return Z_STREAM_END;\n        }\n        if (s.wrap === 2) {\n            put_byte(s, strm.adler & 255);\n            put_byte(s, strm.adler >> 8 & 255);\n            put_byte(s, strm.adler >> 16 & 255);\n            put_byte(s, strm.adler >> 24 & 255);\n            put_byte(s, strm.total_in & 255);\n            put_byte(s, strm.total_in >> 8 & 255);\n            put_byte(s, strm.total_in >> 16 & 255);\n            put_byte(s, strm.total_in >> 24 & 255);\n        } else {\n            putShortMSB(s, strm.adler >>> 16);\n            putShortMSB(s, strm.adler & 65535);\n        }\n        flush_pending(strm);\n        if (s.wrap > 0) {\n            s.wrap = -s.wrap;\n        }\n        return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n    };\n    const deflateEnd = strm => {\n        if (!strm || !strm.state) {\n            return Z_STREAM_ERROR;\n        }\n        const status = strm.state.status;\n        if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {\n            return err(strm, Z_STREAM_ERROR);\n        }\n        strm.state = null;\n        return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n    };\n    const deflateSetDictionary = (strm, dictionary) => {\n        let dictLength = dictionary.length;\n        if (!strm || !strm.state) {\n            return Z_STREAM_ERROR;\n        }\n        const s = strm.state;\n        const wrap = s.wrap;\n        if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {\n            return Z_STREAM_ERROR;\n        }\n        if (wrap === 1) {\n            strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\n        }\n        s.wrap = 0;\n        if (dictLength >= s.w_size) {\n            if (wrap === 0) {\n                zero(s.head);\n                s.strstart = 0;\n                s.block_start = 0;\n                s.insert = 0;\n            }\n            let tmpDict = new Uint8Array(s.w_size);\n            tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);\n            dictionary = tmpDict;\n            dictLength = s.w_size;\n        }\n        const avail = strm.avail_in;\n        const next = strm.next_in;\n        const input = strm.input;\n        strm.avail_in = dictLength;\n        strm.next_in = 0;\n        strm.input = dictionary;\n        fill_window(s);\n        while (s.lookahead >= MIN_MATCH) {\n            let str = s.strstart;\n            let n = s.lookahead - (MIN_MATCH - 1);\n            do {\n                s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);\n                s.prev[str & s.w_mask] = s.head[s.ins_h];\n                s.head[s.ins_h] = str;\n                str++;\n            } while (--n);\n            s.strstart = str;\n            s.lookahead = MIN_MATCH - 1;\n            fill_window(s);\n        }\n        s.strstart += s.lookahead;\n        s.block_start = s.strstart;\n        s.insert = s.lookahead;\n        s.lookahead = 0;\n        s.match_length = s.prev_length = MIN_MATCH - 1;\n        s.match_available = 0;\n        strm.next_in = next;\n        strm.input = input;\n        strm.avail_in = avail;\n        s.wrap = wrap;\n        return Z_OK;\n    };\n\n    return {\n      deflateInit,\n      deflateInit2,\n      deflateReset,\n      deflateResetKeep,\n      deflateSetHeader,\n      deflate,\n      deflateEnd,\n      deflateSetDictionary,\n      deflateInfo : 'pako deflate (from Nodeca project)'\n    };\n\n});"]}