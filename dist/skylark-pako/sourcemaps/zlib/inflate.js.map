{"version":3,"sources":["zlib/inflate.js"],"names":["define","adler32","crc32","inflate_fast","inflate_table","constants","Z_FINISH","Z_BLOCK","Z_TREES","Z_OK","Z_STREAM_END","Z_NEED_DICT","Z_STREAM_ERROR","Z_DATA_ERROR","Z_MEM_ERROR","Z_BUF_ERROR","Z_DEFLATED","__module__4","zswap32","q","inflateResetKeep","strm","state","total_in","total_out","total","msg","wrap","adler","mode","last","havedict","dmax","head","hold","bits","lencode","lendyn","Int32Array","distcode","distdyn","sane","back","inflateReset","wsize","whave","wnext","inflateReset2","windowBits","window","wbits","inflateInit2","this","flags","check","length","offset","extra","lenbits","distbits","ncode","nlen","ndist","have","next","lens","Uint16Array","work","was","ret","lenfix","distfix","virgin","fixedtables","sym","updatewindow","src","end","copy","dist","Uint8Array","set","subarray","inflateInit","inflate","flush","input","output","put","left","_in","_out","from","from_source","here_bits","here_op","here_val","last_bits","last_op","last_val","len","here","hbuf","opts","n","order","avail_in","next_out","avail_out","next_in","inf_leave","done","text","time","xflags","os","extra_len","name","String","fromCharCode","comment","hcrc","data_type","inflateEnd","inflateGetHeader","inflateSetDictionary","dictionary","dictLength","dictid","inflateInfo"],"mappings":"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","file":"../../zlib/inflate.js","sourcesContent":["define([\n    './adler32',\n    './crc32',\n    './inffast',\n    './inftrees',\n    './constants'\n], function (adler32, crc32, inflate_fast, inflate_table, constants) {\n    'use strict';\n\n    const CODES = 0;\n    const LENS = 1;\n    const DISTS = 2;\n    const {Z_FINISH, Z_BLOCK, Z_TREES, Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR, Z_BUF_ERROR, Z_DEFLATED} = __module__4;\n    const HEAD = 1;\n    const FLAGS = 2;\n    const TIME = 3;\n    const OS = 4;\n    const EXLEN = 5;\n    const EXTRA = 6;\n    const NAME = 7;\n    const COMMENT = 8;\n    const HCRC = 9;\n    const DICTID = 10;\n    const DICT = 11;\n    const TYPE = 12;\n    const TYPEDO = 13;\n    const STORED = 14;\n    const COPY_ = 15;\n    const COPY = 16;\n    const TABLE = 17;\n    const LENLENS = 18;\n    const CODELENS = 19;\n    const LEN_ = 20;\n    const LEN = 21;\n    const LENEXT = 22;\n    const DIST = 23;\n    const DISTEXT = 24;\n    const MATCH = 25;\n    const LIT = 26;\n    const CHECK = 27;\n    const LENGTH = 28;\n    const DONE = 29;\n    const BAD = 30;\n    const MEM = 31;\n    const SYNC = 32;\n    const ENOUGH_LENS = 852;\n    const ENOUGH_DISTS = 592;\n    const MAX_WBITS = 15;\n    const DEF_WBITS = MAX_WBITS;\n    const zswap32 = q => {\n        return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);\n    };\n    function InflateState() {\n        this.mode = 0;\n        this.last = false;\n        this.wrap = 0;\n        this.havedict = false;\n        this.flags = 0;\n        this.dmax = 0;\n        this.check = 0;\n        this.total = 0;\n        this.head = null;\n        this.wbits = 0;\n        this.wsize = 0;\n        this.whave = 0;\n        this.wnext = 0;\n        this.window = null;\n        this.hold = 0;\n        this.bits = 0;\n        this.length = 0;\n        this.offset = 0;\n        this.extra = 0;\n        this.lencode = null;\n        this.distcode = null;\n        this.lenbits = 0;\n        this.distbits = 0;\n        this.ncode = 0;\n        this.nlen = 0;\n        this.ndist = 0;\n        this.have = 0;\n        this.next = null;\n        this.lens = new Uint16Array(320);\n        this.work = new Uint16Array(288);\n        this.lendyn = null;\n        this.distdyn = null;\n        this.sane = 0;\n        this.back = 0;\n        this.was = 0;\n    }\n    const inflateResetKeep = strm => {\n        if (!strm || !strm.state) {\n            return Z_STREAM_ERROR;\n        }\n        const state = strm.state;\n        strm.total_in = strm.total_out = state.total = 0;\n        strm.msg = '';\n        if (state.wrap) {\n            strm.adler = state.wrap & 1;\n        }\n        state.mode = HEAD;\n        state.last = 0;\n        state.havedict = 0;\n        state.dmax = 32768;\n        state.head = null;\n        state.hold = 0;\n        state.bits = 0;\n        state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);\n        state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);\n        state.sane = 1;\n        state.back = -1;\n        return Z_OK;\n    };\n    const inflateReset = strm => {\n        if (!strm || !strm.state) {\n            return Z_STREAM_ERROR;\n        }\n        const state = strm.state;\n        state.wsize = 0;\n        state.whave = 0;\n        state.wnext = 0;\n        return inflateResetKeep(strm);\n    };\n    const inflateReset2 = (strm, windowBits) => {\n        let wrap;\n        if (!strm || !strm.state) {\n            return Z_STREAM_ERROR;\n        }\n        const state = strm.state;\n        if (windowBits < 0) {\n            wrap = 0;\n            windowBits = -windowBits;\n        } else {\n            wrap = (windowBits >> 4) + 1;\n            if (windowBits < 48) {\n                windowBits &= 15;\n            }\n        }\n        if (windowBits && (windowBits < 8 || windowBits > 15)) {\n            return Z_STREAM_ERROR;\n        }\n        if (state.window !== null && state.wbits !== windowBits) {\n            state.window = null;\n        }\n        state.wrap = wrap;\n        state.wbits = windowBits;\n        return inflateReset(strm);\n    };\n    const inflateInit2 = (strm, windowBits) => {\n        if (!strm) {\n            return Z_STREAM_ERROR;\n        }\n        const state = new InflateState();\n        strm.state = state;\n        state.window = null;\n        const ret = inflateReset2(strm, windowBits);\n        if (ret !== Z_OK) {\n            strm.state = null;\n        }\n        return ret;\n    };\n    const inflateInit = strm => {\n        return inflateInit2(strm, DEF_WBITS);\n    };\n    let virgin = true;\n    let lenfix, distfix;\n    const fixedtables = state => {\n        if (virgin) {\n            lenfix = new Int32Array(512);\n            distfix = new Int32Array(32);\n            let sym = 0;\n            while (sym < 144) {\n                state.lens[sym++] = 8;\n            }\n            while (sym < 256) {\n                state.lens[sym++] = 9;\n            }\n            while (sym < 280) {\n                state.lens[sym++] = 7;\n            }\n            while (sym < 288) {\n                state.lens[sym++] = 8;\n            }\n            inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });\n            sym = 0;\n            while (sym < 32) {\n                state.lens[sym++] = 5;\n            }\n            inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });\n            virgin = false;\n        }\n        state.lencode = lenfix;\n        state.lenbits = 9;\n        state.distcode = distfix;\n        state.distbits = 5;\n    };\n    const updatewindow = (strm, src, end, copy) => {\n        let dist;\n        const state = strm.state;\n        if (state.window === null) {\n            state.wsize = 1 << state.wbits;\n            state.wnext = 0;\n            state.whave = 0;\n            state.window = new Uint8Array(state.wsize);\n        }\n        if (copy >= state.wsize) {\n            state.window.set(src.subarray(end - state.wsize, end), 0);\n            state.wnext = 0;\n            state.whave = state.wsize;\n        } else {\n            dist = state.wsize - state.wnext;\n            if (dist > copy) {\n                dist = copy;\n            }\n            state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);\n            copy -= dist;\n            if (copy) {\n                state.window.set(src.subarray(end - copy, end), 0);\n                state.wnext = copy;\n                state.whave = state.wsize;\n            } else {\n                state.wnext += dist;\n                if (state.wnext === state.wsize) {\n                    state.wnext = 0;\n                }\n                if (state.whave < state.wsize) {\n                    state.whave += dist;\n                }\n            }\n        }\n        return 0;\n    };\n    const inflate = (strm, flush) => {\n        let state;\n        let input, output;\n        let next;\n        let put;\n        let have, left;\n        let hold;\n        let bits;\n        let _in, _out;\n        let copy;\n        let from;\n        let from_source;\n        let here = 0;\n        let here_bits, here_op, here_val;\n        let last_bits, last_op, last_val;\n        let len;\n        let ret;\n        const hbuf = new Uint8Array(4);\n        let opts;\n        let n;\n        const order = new Uint8Array([\n            16,\n            17,\n            18,\n            0,\n            8,\n            7,\n            9,\n            6,\n            10,\n            5,\n            11,\n            4,\n            12,\n            3,\n            13,\n            2,\n            14,\n            1,\n            15\n        ]);\n        if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {\n            return Z_STREAM_ERROR;\n        }\n        state = strm.state;\n        if (state.mode === TYPE) {\n            state.mode = TYPEDO;\n        }\n        put = strm.next_out;\n        output = strm.output;\n        left = strm.avail_out;\n        next = strm.next_in;\n        input = strm.input;\n        have = strm.avail_in;\n        hold = state.hold;\n        bits = state.bits;\n        _in = have;\n        _out = left;\n        ret = Z_OK;\n        inf_leave:\n            for (;;) {\n                switch (state.mode) {\n                case HEAD:\n                    if (state.wrap === 0) {\n                        state.mode = TYPEDO;\n                        break;\n                    }\n                    while (bits < 16) {\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        hold += input[next++] << bits;\n                        bits += 8;\n                    }\n                    if (state.wrap & 2 && hold === 35615) {\n                        state.check = 0;\n                        hbuf[0] = hold & 255;\n                        hbuf[1] = hold >>> 8 & 255;\n                        state.check = crc32(state.check, hbuf, 2, 0);\n                        hold = 0;\n                        bits = 0;\n                        state.mode = FLAGS;\n                        break;\n                    }\n                    state.flags = 0;\n                    if (state.head) {\n                        state.head.done = false;\n                    }\n                    if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {\n                        strm.msg = 'incorrect header check';\n                        state.mode = BAD;\n                        break;\n                    }\n                    if ((hold & 15) !== Z_DEFLATED) {\n                        strm.msg = 'unknown compression method';\n                        state.mode = BAD;\n                        break;\n                    }\n                    hold >>>= 4;\n                    bits -= 4;\n                    len = (hold & 15) + 8;\n                    if (state.wbits === 0) {\n                        state.wbits = len;\n                    } else if (len > state.wbits) {\n                        strm.msg = 'invalid window size';\n                        state.mode = BAD;\n                        break;\n                    }\n                    state.dmax = 1 << state.wbits;\n                    strm.adler = state.check = 1;\n                    state.mode = hold & 512 ? DICTID : TYPE;\n                    hold = 0;\n                    bits = 0;\n                    break;\n                case FLAGS:\n                    while (bits < 16) {\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        hold += input[next++] << bits;\n                        bits += 8;\n                    }\n                    state.flags = hold;\n                    if ((state.flags & 255) !== Z_DEFLATED) {\n                        strm.msg = 'unknown compression method';\n                        state.mode = BAD;\n                        break;\n                    }\n                    if (state.flags & 57344) {\n                        strm.msg = 'unknown header flags set';\n                        state.mode = BAD;\n                        break;\n                    }\n                    if (state.head) {\n                        state.head.text = hold >> 8 & 1;\n                    }\n                    if (state.flags & 512) {\n                        hbuf[0] = hold & 255;\n                        hbuf[1] = hold >>> 8 & 255;\n                        state.check = crc32(state.check, hbuf, 2, 0);\n                    }\n                    hold = 0;\n                    bits = 0;\n                    state.mode = TIME;\n                case TIME:\n                    while (bits < 32) {\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        hold += input[next++] << bits;\n                        bits += 8;\n                    }\n                    if (state.head) {\n                        state.head.time = hold;\n                    }\n                    if (state.flags & 512) {\n                        hbuf[0] = hold & 255;\n                        hbuf[1] = hold >>> 8 & 255;\n                        hbuf[2] = hold >>> 16 & 255;\n                        hbuf[3] = hold >>> 24 & 255;\n                        state.check = crc32(state.check, hbuf, 4, 0);\n                    }\n                    hold = 0;\n                    bits = 0;\n                    state.mode = OS;\n                case OS:\n                    while (bits < 16) {\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        hold += input[next++] << bits;\n                        bits += 8;\n                    }\n                    if (state.head) {\n                        state.head.xflags = hold & 255;\n                        state.head.os = hold >> 8;\n                    }\n                    if (state.flags & 512) {\n                        hbuf[0] = hold & 255;\n                        hbuf[1] = hold >>> 8 & 255;\n                        state.check = crc32(state.check, hbuf, 2, 0);\n                    }\n                    hold = 0;\n                    bits = 0;\n                    state.mode = EXLEN;\n                case EXLEN:\n                    if (state.flags & 1024) {\n                        while (bits < 16) {\n                            if (have === 0) {\n                                break inf_leave;\n                            }\n                            have--;\n                            hold += input[next++] << bits;\n                            bits += 8;\n                        }\n                        state.length = hold;\n                        if (state.head) {\n                            state.head.extra_len = hold;\n                        }\n                        if (state.flags & 512) {\n                            hbuf[0] = hold & 255;\n                            hbuf[1] = hold >>> 8 & 255;\n                            state.check = crc32(state.check, hbuf, 2, 0);\n                        }\n                        hold = 0;\n                        bits = 0;\n                    } else if (state.head) {\n                        state.head.extra = null;\n                    }\n                    state.mode = EXTRA;\n                case EXTRA:\n                    if (state.flags & 1024) {\n                        copy = state.length;\n                        if (copy > have) {\n                            copy = have;\n                        }\n                        if (copy) {\n                            if (state.head) {\n                                len = state.head.extra_len - state.length;\n                                if (!state.head.extra) {\n                                    state.head.extra = new Uint8Array(state.head.extra_len);\n                                }\n                                state.head.extra.set(input.subarray(next, next + copy), len);\n                            }\n                            if (state.flags & 512) {\n                                state.check = crc32(state.check, input, copy, next);\n                            }\n                            have -= copy;\n                            next += copy;\n                            state.length -= copy;\n                        }\n                        if (state.length) {\n                            break inf_leave;\n                        }\n                    }\n                    state.length = 0;\n                    state.mode = NAME;\n                case NAME:\n                    if (state.flags & 2048) {\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        copy = 0;\n                        do {\n                            len = input[next + copy++];\n                            if (state.head && len && state.length < 65536) {\n                                state.head.name += String.fromCharCode(len);\n                            }\n                        } while (len && copy < have);\n                        if (state.flags & 512) {\n                            state.check = crc32(state.check, input, copy, next);\n                        }\n                        have -= copy;\n                        next += copy;\n                        if (len) {\n                            break inf_leave;\n                        }\n                    } else if (state.head) {\n                        state.head.name = null;\n                    }\n                    state.length = 0;\n                    state.mode = COMMENT;\n                case COMMENT:\n                    if (state.flags & 4096) {\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        copy = 0;\n                        do {\n                            len = input[next + copy++];\n                            if (state.head && len && state.length < 65536) {\n                                state.head.comment += String.fromCharCode(len);\n                            }\n                        } while (len && copy < have);\n                        if (state.flags & 512) {\n                            state.check = crc32(state.check, input, copy, next);\n                        }\n                        have -= copy;\n                        next += copy;\n                        if (len) {\n                            break inf_leave;\n                        }\n                    } else if (state.head) {\n                        state.head.comment = null;\n                    }\n                    state.mode = HCRC;\n                case HCRC:\n                    if (state.flags & 512) {\n                        while (bits < 16) {\n                            if (have === 0) {\n                                break inf_leave;\n                            }\n                            have--;\n                            hold += input[next++] << bits;\n                            bits += 8;\n                        }\n                        if (hold !== (state.check & 65535)) {\n                            strm.msg = 'header crc mismatch';\n                            state.mode = BAD;\n                            break;\n                        }\n                        hold = 0;\n                        bits = 0;\n                    }\n                    if (state.head) {\n                        state.head.hcrc = state.flags >> 9 & 1;\n                        state.head.done = true;\n                    }\n                    strm.adler = state.check = 0;\n                    state.mode = TYPE;\n                    break;\n                case DICTID:\n                    while (bits < 32) {\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        hold += input[next++] << bits;\n                        bits += 8;\n                    }\n                    strm.adler = state.check = zswap32(hold);\n                    hold = 0;\n                    bits = 0;\n                    state.mode = DICT;\n                case DICT:\n                    if (state.havedict === 0) {\n                        strm.next_out = put;\n                        strm.avail_out = left;\n                        strm.next_in = next;\n                        strm.avail_in = have;\n                        state.hold = hold;\n                        state.bits = bits;\n                        return Z_NEED_DICT;\n                    }\n                    strm.adler = state.check = 1;\n                    state.mode = TYPE;\n                case TYPE:\n                    if (flush === Z_BLOCK || flush === Z_TREES) {\n                        break inf_leave;\n                    }\n                case TYPEDO:\n                    if (state.last) {\n                        hold >>>= bits & 7;\n                        bits -= bits & 7;\n                        state.mode = CHECK;\n                        break;\n                    }\n                    while (bits < 3) {\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        hold += input[next++] << bits;\n                        bits += 8;\n                    }\n                    state.last = hold & 1;\n                    hold >>>= 1;\n                    bits -= 1;\n                    switch (hold & 3) {\n                    case 0:\n                        state.mode = STORED;\n                        break;\n                    case 1:\n                        fixedtables(state);\n                        state.mode = LEN_;\n                        if (flush === Z_TREES) {\n                            hold >>>= 2;\n                            bits -= 2;\n                            break inf_leave;\n                        }\n                        break;\n                    case 2:\n                        state.mode = TABLE;\n                        break;\n                    case 3:\n                        strm.msg = 'invalid block type';\n                        state.mode = BAD;\n                    }\n                    hold >>>= 2;\n                    bits -= 2;\n                    break;\n                case STORED:\n                    hold >>>= bits & 7;\n                    bits -= bits & 7;\n                    while (bits < 32) {\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        hold += input[next++] << bits;\n                        bits += 8;\n                    }\n                    if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {\n                        strm.msg = 'invalid stored block lengths';\n                        state.mode = BAD;\n                        break;\n                    }\n                    state.length = hold & 65535;\n                    hold = 0;\n                    bits = 0;\n                    state.mode = COPY_;\n                    if (flush === Z_TREES) {\n                        break inf_leave;\n                    }\n                case COPY_:\n                    state.mode = COPY;\n                case COPY:\n                    copy = state.length;\n                    if (copy) {\n                        if (copy > have) {\n                            copy = have;\n                        }\n                        if (copy > left) {\n                            copy = left;\n                        }\n                        if (copy === 0) {\n                            break inf_leave;\n                        }\n                        output.set(input.subarray(next, next + copy), put);\n                        have -= copy;\n                        next += copy;\n                        left -= copy;\n                        put += copy;\n                        state.length -= copy;\n                        break;\n                    }\n                    state.mode = TYPE;\n                    break;\n                case TABLE:\n                    while (bits < 14) {\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        hold += input[next++] << bits;\n                        bits += 8;\n                    }\n                    state.nlen = (hold & 31) + 257;\n                    hold >>>= 5;\n                    bits -= 5;\n                    state.ndist = (hold & 31) + 1;\n                    hold >>>= 5;\n                    bits -= 5;\n                    state.ncode = (hold & 15) + 4;\n                    hold >>>= 4;\n                    bits -= 4;\n                    if (state.nlen > 286 || state.ndist > 30) {\n                        strm.msg = 'too many length or distance symbols';\n                        state.mode = BAD;\n                        break;\n                    }\n                    state.have = 0;\n                    state.mode = LENLENS;\n                case LENLENS:\n                    while (state.have < state.ncode) {\n                        while (bits < 3) {\n                            if (have === 0) {\n                                break inf_leave;\n                            }\n                            have--;\n                            hold += input[next++] << bits;\n                            bits += 8;\n                        }\n                        state.lens[order[state.have++]] = hold & 7;\n                        hold >>>= 3;\n                        bits -= 3;\n                    }\n                    while (state.have < 19) {\n                        state.lens[order[state.have++]] = 0;\n                    }\n                    state.lencode = state.lendyn;\n                    state.lenbits = 7;\n                    opts = { bits: state.lenbits };\n                    ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);\n                    state.lenbits = opts.bits;\n                    if (ret) {\n                        strm.msg = 'invalid code lengths set';\n                        state.mode = BAD;\n                        break;\n                    }\n                    state.have = 0;\n                    state.mode = CODELENS;\n                case CODELENS:\n                    while (state.have < state.nlen + state.ndist) {\n                        for (;;) {\n                            here = state.lencode[hold & (1 << state.lenbits) - 1];\n                            here_bits = here >>> 24;\n                            here_op = here >>> 16 & 255;\n                            here_val = here & 65535;\n                            if (here_bits <= bits) {\n                                break;\n                            }\n                            if (have === 0) {\n                                break inf_leave;\n                            }\n                            have--;\n                            hold += input[next++] << bits;\n                            bits += 8;\n                        }\n                        if (here_val < 16) {\n                            hold >>>= here_bits;\n                            bits -= here_bits;\n                            state.lens[state.have++] = here_val;\n                        } else {\n                            if (here_val === 16) {\n                                n = here_bits + 2;\n                                while (bits < n) {\n                                    if (have === 0) {\n                                        break inf_leave;\n                                    }\n                                    have--;\n                                    hold += input[next++] << bits;\n                                    bits += 8;\n                                }\n                                hold >>>= here_bits;\n                                bits -= here_bits;\n                                if (state.have === 0) {\n                                    strm.msg = 'invalid bit length repeat';\n                                    state.mode = BAD;\n                                    break;\n                                }\n                                len = state.lens[state.have - 1];\n                                copy = 3 + (hold & 3);\n                                hold >>>= 2;\n                                bits -= 2;\n                            } else if (here_val === 17) {\n                                n = here_bits + 3;\n                                while (bits < n) {\n                                    if (have === 0) {\n                                        break inf_leave;\n                                    }\n                                    have--;\n                                    hold += input[next++] << bits;\n                                    bits += 8;\n                                }\n                                hold >>>= here_bits;\n                                bits -= here_bits;\n                                len = 0;\n                                copy = 3 + (hold & 7);\n                                hold >>>= 3;\n                                bits -= 3;\n                            } else {\n                                n = here_bits + 7;\n                                while (bits < n) {\n                                    if (have === 0) {\n                                        break inf_leave;\n                                    }\n                                    have--;\n                                    hold += input[next++] << bits;\n                                    bits += 8;\n                                }\n                                hold >>>= here_bits;\n                                bits -= here_bits;\n                                len = 0;\n                                copy = 11 + (hold & 127);\n                                hold >>>= 7;\n                                bits -= 7;\n                            }\n                            if (state.have + copy > state.nlen + state.ndist) {\n                                strm.msg = 'invalid bit length repeat';\n                                state.mode = BAD;\n                                break;\n                            }\n                            while (copy--) {\n                                state.lens[state.have++] = len;\n                            }\n                        }\n                    }\n                    if (state.mode === BAD) {\n                        break;\n                    }\n                    if (state.lens[256] === 0) {\n                        strm.msg = 'invalid code -- missing end-of-block';\n                        state.mode = BAD;\n                        break;\n                    }\n                    state.lenbits = 9;\n                    opts = { bits: state.lenbits };\n                    ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);\n                    state.lenbits = opts.bits;\n                    if (ret) {\n                        strm.msg = 'invalid literal/lengths set';\n                        state.mode = BAD;\n                        break;\n                    }\n                    state.distbits = 6;\n                    state.distcode = state.distdyn;\n                    opts = { bits: state.distbits };\n                    ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);\n                    state.distbits = opts.bits;\n                    if (ret) {\n                        strm.msg = 'invalid distances set';\n                        state.mode = BAD;\n                        break;\n                    }\n                    state.mode = LEN_;\n                    if (flush === Z_TREES) {\n                        break inf_leave;\n                    }\n                case LEN_:\n                    state.mode = LEN;\n                case LEN:\n                    if (have >= 6 && left >= 258) {\n                        strm.next_out = put;\n                        strm.avail_out = left;\n                        strm.next_in = next;\n                        strm.avail_in = have;\n                        state.hold = hold;\n                        state.bits = bits;\n                        inflate_fast(strm, _out);\n                        put = strm.next_out;\n                        output = strm.output;\n                        left = strm.avail_out;\n                        next = strm.next_in;\n                        input = strm.input;\n                        have = strm.avail_in;\n                        hold = state.hold;\n                        bits = state.bits;\n                        if (state.mode === TYPE) {\n                            state.back = -1;\n                        }\n                        break;\n                    }\n                    state.back = 0;\n                    for (;;) {\n                        here = state.lencode[hold & (1 << state.lenbits) - 1];\n                        here_bits = here >>> 24;\n                        here_op = here >>> 16 & 255;\n                        here_val = here & 65535;\n                        if (here_bits <= bits) {\n                            break;\n                        }\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        hold += input[next++] << bits;\n                        bits += 8;\n                    }\n                    if (here_op && (here_op & 240) === 0) {\n                        last_bits = here_bits;\n                        last_op = here_op;\n                        last_val = here_val;\n                        for (;;) {\n                            here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];\n                            here_bits = here >>> 24;\n                            here_op = here >>> 16 & 255;\n                            here_val = here & 65535;\n                            if (last_bits + here_bits <= bits) {\n                                break;\n                            }\n                            if (have === 0) {\n                                break inf_leave;\n                            }\n                            have--;\n                            hold += input[next++] << bits;\n                            bits += 8;\n                        }\n                        hold >>>= last_bits;\n                        bits -= last_bits;\n                        state.back += last_bits;\n                    }\n                    hold >>>= here_bits;\n                    bits -= here_bits;\n                    state.back += here_bits;\n                    state.length = here_val;\n                    if (here_op === 0) {\n                        state.mode = LIT;\n                        break;\n                    }\n                    if (here_op & 32) {\n                        state.back = -1;\n                        state.mode = TYPE;\n                        break;\n                    }\n                    if (here_op & 64) {\n                        strm.msg = 'invalid literal/length code';\n                        state.mode = BAD;\n                        break;\n                    }\n                    state.extra = here_op & 15;\n                    state.mode = LENEXT;\n                case LENEXT:\n                    if (state.extra) {\n                        n = state.extra;\n                        while (bits < n) {\n                            if (have === 0) {\n                                break inf_leave;\n                            }\n                            have--;\n                            hold += input[next++] << bits;\n                            bits += 8;\n                        }\n                        state.length += hold & (1 << state.extra) - 1;\n                        hold >>>= state.extra;\n                        bits -= state.extra;\n                        state.back += state.extra;\n                    }\n                    state.was = state.length;\n                    state.mode = DIST;\n                case DIST:\n                    for (;;) {\n                        here = state.distcode[hold & (1 << state.distbits) - 1];\n                        here_bits = here >>> 24;\n                        here_op = here >>> 16 & 255;\n                        here_val = here & 65535;\n                        if (here_bits <= bits) {\n                            break;\n                        }\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        hold += input[next++] << bits;\n                        bits += 8;\n                    }\n                    if ((here_op & 240) === 0) {\n                        last_bits = here_bits;\n                        last_op = here_op;\n                        last_val = here_val;\n                        for (;;) {\n                            here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];\n                            here_bits = here >>> 24;\n                            here_op = here >>> 16 & 255;\n                            here_val = here & 65535;\n                            if (last_bits + here_bits <= bits) {\n                                break;\n                            }\n                            if (have === 0) {\n                                break inf_leave;\n                            }\n                            have--;\n                            hold += input[next++] << bits;\n                            bits += 8;\n                        }\n                        hold >>>= last_bits;\n                        bits -= last_bits;\n                        state.back += last_bits;\n                    }\n                    hold >>>= here_bits;\n                    bits -= here_bits;\n                    state.back += here_bits;\n                    if (here_op & 64) {\n                        strm.msg = 'invalid distance code';\n                        state.mode = BAD;\n                        break;\n                    }\n                    state.offset = here_val;\n                    state.extra = here_op & 15;\n                    state.mode = DISTEXT;\n                case DISTEXT:\n                    if (state.extra) {\n                        n = state.extra;\n                        while (bits < n) {\n                            if (have === 0) {\n                                break inf_leave;\n                            }\n                            have--;\n                            hold += input[next++] << bits;\n                            bits += 8;\n                        }\n                        state.offset += hold & (1 << state.extra) - 1;\n                        hold >>>= state.extra;\n                        bits -= state.extra;\n                        state.back += state.extra;\n                    }\n                    if (state.offset > state.dmax) {\n                        strm.msg = 'invalid distance too far back';\n                        state.mode = BAD;\n                        break;\n                    }\n                    state.mode = MATCH;\n                case MATCH:\n                    if (left === 0) {\n                        break inf_leave;\n                    }\n                    copy = _out - left;\n                    if (state.offset > copy) {\n                        copy = state.offset - copy;\n                        if (copy > state.whave) {\n                            if (state.sane) {\n                                strm.msg = 'invalid distance too far back';\n                                state.mode = BAD;\n                                break;\n                            }\n                        }\n                        if (copy > state.wnext) {\n                            copy -= state.wnext;\n                            from = state.wsize - copy;\n                        } else {\n                            from = state.wnext - copy;\n                        }\n                        if (copy > state.length) {\n                            copy = state.length;\n                        }\n                        from_source = state.window;\n                    } else {\n                        from_source = output;\n                        from = put - state.offset;\n                        copy = state.length;\n                    }\n                    if (copy > left) {\n                        copy = left;\n                    }\n                    left -= copy;\n                    state.length -= copy;\n                    do {\n                        output[put++] = from_source[from++];\n                    } while (--copy);\n                    if (state.length === 0) {\n                        state.mode = LEN;\n                    }\n                    break;\n                case LIT:\n                    if (left === 0) {\n                        break inf_leave;\n                    }\n                    output[put++] = state.length;\n                    left--;\n                    state.mode = LEN;\n                    break;\n                case CHECK:\n                    if (state.wrap) {\n                        while (bits < 32) {\n                            if (have === 0) {\n                                break inf_leave;\n                            }\n                            have--;\n                            hold |= input[next++] << bits;\n                            bits += 8;\n                        }\n                        _out -= left;\n                        strm.total_out += _out;\n                        state.total += _out;\n                        if (_out) {\n                            strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);\n                        }\n                        _out = left;\n                        if ((state.flags ? hold : zswap32(hold)) !== state.check) {\n                            strm.msg = 'incorrect data check';\n                            state.mode = BAD;\n                            break;\n                        }\n                        hold = 0;\n                        bits = 0;\n                    }\n                    state.mode = LENGTH;\n                case LENGTH:\n                    if (state.wrap && state.flags) {\n                        while (bits < 32) {\n                            if (have === 0) {\n                                break inf_leave;\n                            }\n                            have--;\n                            hold += input[next++] << bits;\n                            bits += 8;\n                        }\n                        if (hold !== (state.total & 4294967295)) {\n                            strm.msg = 'incorrect length check';\n                            state.mode = BAD;\n                            break;\n                        }\n                        hold = 0;\n                        bits = 0;\n                    }\n                    state.mode = DONE;\n                case DONE:\n                    ret = Z_STREAM_END;\n                    break inf_leave;\n                case BAD:\n                    ret = Z_DATA_ERROR;\n                    break inf_leave;\n                case MEM:\n                    return Z_MEM_ERROR;\n                case SYNC:\n                default:\n                    return Z_STREAM_ERROR;\n                }\n            }\n        strm.next_out = put;\n        strm.avail_out = left;\n        strm.next_in = next;\n        strm.avail_in = have;\n        state.hold = hold;\n        state.bits = bits;\n        if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {\n            if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {\n                state.mode = MEM;\n                return Z_MEM_ERROR;\n            }\n        }\n        _in -= strm.avail_in;\n        _out -= strm.avail_out;\n        strm.total_in += _in;\n        strm.total_out += _out;\n        state.total += _out;\n        if (state.wrap && _out) {\n            strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);\n        }\n        strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);\n        if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {\n            ret = Z_BUF_ERROR;\n        }\n        return ret;\n    };\n    const inflateEnd = strm => {\n        if (!strm || !strm.state) {\n            return Z_STREAM_ERROR;\n        }\n        let state = strm.state;\n        if (state.window) {\n            state.window = null;\n        }\n        strm.state = null;\n        return Z_OK;\n    };\n    const inflateGetHeader = (strm, head) => {\n        if (!strm || !strm.state) {\n            return Z_STREAM_ERROR;\n        }\n        const state = strm.state;\n        if ((state.wrap & 2) === 0) {\n            return Z_STREAM_ERROR;\n        }\n        state.head = head;\n        head.done = false;\n        return Z_OK;\n    };\n    const inflateSetDictionary = (strm, dictionary) => {\n        const dictLength = dictionary.length;\n        let state;\n        let dictid;\n        let ret;\n        if (!strm || !strm.state) {\n            return Z_STREAM_ERROR;\n        }\n        state = strm.state;\n        if (state.wrap !== 0 && state.mode !== DICT) {\n            return Z_STREAM_ERROR;\n        }\n        if (state.mode === DICT) {\n            dictid = 1;\n            dictid = adler32(dictid, dictionary, dictLength, 0);\n            if (dictid !== state.check) {\n                return Z_DATA_ERROR;\n            }\n        }\n        ret = updatewindow(strm, dictionary, dictLength, dictLength);\n        if (ret) {\n            state.mode = MEM;\n            return Z_MEM_ERROR;\n        }\n        state.havedict = 1;\n        return Z_OK;\n    };\n\n\n    return {\n        inflateReset,\n        inflateReset2,\n        inflateResetKeep,\n        inflateInit,\n        inflateInit2,\n        inflate,\n        inflateEnd,\n        inflateGetHeader,\n        inflateSetDictionary,\n        inflateInfo : 'pako inflate (from Nodeca project)'\n    };\n});"]}