{"version":3,"sources":["zlib/adler32.js"],"names":["define","adler","buf","len","pos","s1","s2","n"],"mappings":";;;;;;;AAAAA,UAAW,WACP,aA2BA,OAlBA,SAAkBC,EAAOC,EAAKC,EAAKC,GAC/B,IAAIC,EAAa,MAARJ,EAAgB,EAAGK,EAAKL,IAAU,GAAK,MAAQ,EAAGM,EAAI,EAC/D,KAAe,IAARJ,GAAW,CAKdA,GADAI,EAAIJ,EAAM,IAAO,IAAOA,EAExB,GAEIG,EAAKA,GADLD,EAAKA,EAAKH,EAAIE,KAAS,GACR,UACRG,GACXF,GAAM,MACNC,GAAM,MAEV,OAAOD,EAAKC,GAAM,GAAK","file":"../../zlib/adler32.js","sourcesContent":["define([], function () {\n    'use strict';\n    // Original version : zlib 1.2.8\n    // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n\n\n    // Note: adler32 takes 12% for level 0 and 2% for level 6.\n    // It isn't worth it to make additional optimizations as in original.\n    // Small size is preferable.\n    function adler32 (adler, buf, len, pos)  {\n        let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;\n        while (len !== 0) {\n            // Set limit ~ twice less than 5552, to keep\n            // s2 in 31-bits, because we force signed ints.\n            // in other case %= will fail.\n            n = len > 2000 ? 2000 : len;\n            len -= n;\n            do {\n                s1 = s1 + buf[pos++] | 0;\n                s2 = s2 + s1 | 0;\n            } while (--n);\n            s1 %= 65521;\n            s2 %= 65521;\n        }\n        return s1 | s2 << 16 | 0;\n    };\n\n    return  adler32;\n\n});"]}