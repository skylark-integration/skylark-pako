{"version":3,"sources":["zlib/inffast.js"],"names":["define","BAD","TYPE","strm","start","_in","last","_out","beg","end","dmax","wsize","whave","wnext","s_window","hold","bits","lcode","dcode","lmask","dmask","here","op","len","dist","from","from_source","input","output","state","next_in","avail_in","next_out","avail_out","window","lencode","distcode","lenbits","distbits","top","dolen","mode","msg","dodist","sane"],"mappings":"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","file":"../../zlib/inffast.js","sourcesContent":["define([], function () {\n    'use strict';\n\n    const BAD = 30;\n    const TYPE = 12;\n    function inflate_fast(strm, start) {\n        let _in;\n        let last;\n        let _out;\n        let beg;\n        let end;\n        let dmax;\n        let wsize;\n        let whave;\n        let wnext;\n        let s_window;\n        let hold;\n        let bits;\n        let lcode;\n        let dcode;\n        let lmask;\n        let dmask;\n        let here;\n        let op;\n        let len;\n        let dist;\n        let from;\n        let from_source;\n        let input, output;\n        const state = strm.state;\n        _in = strm.next_in;\n        input = strm.input;\n        last = _in + (strm.avail_in - 5);\n        _out = strm.next_out;\n        output = strm.output;\n        beg = _out - (start - strm.avail_out);\n        end = _out + (strm.avail_out - 257);\n        dmax = state.dmax;\n        wsize = state.wsize;\n        whave = state.whave;\n        wnext = state.wnext;\n        s_window = state.window;\n        hold = state.hold;\n        bits = state.bits;\n        lcode = state.lencode;\n        dcode = state.distcode;\n        lmask = (1 << state.lenbits) - 1;\n        dmask = (1 << state.distbits) - 1;\n        top:\n            do {\n                if (bits < 15) {\n                    hold += input[_in++] << bits;\n                    bits += 8;\n                    hold += input[_in++] << bits;\n                    bits += 8;\n                }\n                here = lcode[hold & lmask];\n                dolen:\n                    for (;;) {\n                        op = here >>> 24;\n                        hold >>>= op;\n                        bits -= op;\n                        op = here >>> 16 & 255;\n                        if (op === 0) {\n                            output[_out++] = here & 65535;\n                        } else if (op & 16) {\n                            len = here & 65535;\n                            op &= 15;\n                            if (op) {\n                                if (bits < op) {\n                                    hold += input[_in++] << bits;\n                                    bits += 8;\n                                }\n                                len += hold & (1 << op) - 1;\n                                hold >>>= op;\n                                bits -= op;\n                            }\n                            if (bits < 15) {\n                                hold += input[_in++] << bits;\n                                bits += 8;\n                                hold += input[_in++] << bits;\n                                bits += 8;\n                            }\n                            here = dcode[hold & dmask];\n                            dodist:\n                                for (;;) {\n                                    op = here >>> 24;\n                                    hold >>>= op;\n                                    bits -= op;\n                                    op = here >>> 16 & 255;\n                                    if (op & 16) {\n                                        dist = here & 65535;\n                                        op &= 15;\n                                        if (bits < op) {\n                                            hold += input[_in++] << bits;\n                                            bits += 8;\n                                            if (bits < op) {\n                                                hold += input[_in++] << bits;\n                                                bits += 8;\n                                            }\n                                        }\n                                        dist += hold & (1 << op) - 1;\n                                        if (dist > dmax) {\n                                            strm.msg = 'invalid distance too far back';\n                                            state.mode = BAD;\n                                            break top;\n                                        }\n                                        hold >>>= op;\n                                        bits -= op;\n                                        op = _out - beg;\n                                        if (dist > op) {\n                                            op = dist - op;\n                                            if (op > whave) {\n                                                if (state.sane) {\n                                                    strm.msg = 'invalid distance too far back';\n                                                    state.mode = BAD;\n                                                    break top;\n                                                }\n                                            }\n                                            from = 0;\n                                            from_source = s_window;\n                                            if (wnext === 0) {\n                                                from += wsize - op;\n                                                if (op < len) {\n                                                    len -= op;\n                                                    do {\n                                                        output[_out++] = s_window[from++];\n                                                    } while (--op);\n                                                    from = _out - dist;\n                                                    from_source = output;\n                                                }\n                                            } else if (wnext < op) {\n                                                from += wsize + wnext - op;\n                                                op -= wnext;\n                                                if (op < len) {\n                                                    len -= op;\n                                                    do {\n                                                        output[_out++] = s_window[from++];\n                                                    } while (--op);\n                                                    from = 0;\n                                                    if (wnext < len) {\n                                                        op = wnext;\n                                                        len -= op;\n                                                        do {\n                                                            output[_out++] = s_window[from++];\n                                                        } while (--op);\n                                                        from = _out - dist;\n                                                        from_source = output;\n                                                    }\n                                                }\n                                            } else {\n                                                from += wnext - op;\n                                                if (op < len) {\n                                                    len -= op;\n                                                    do {\n                                                        output[_out++] = s_window[from++];\n                                                    } while (--op);\n                                                    from = _out - dist;\n                                                    from_source = output;\n                                                }\n                                            }\n                                            while (len > 2) {\n                                                output[_out++] = from_source[from++];\n                                                output[_out++] = from_source[from++];\n                                                output[_out++] = from_source[from++];\n                                                len -= 3;\n                                            }\n                                            if (len) {\n                                                output[_out++] = from_source[from++];\n                                                if (len > 1) {\n                                                    output[_out++] = from_source[from++];\n                                                }\n                                            }\n                                        } else {\n                                            from = _out - dist;\n                                            do {\n                                                output[_out++] = output[from++];\n                                                output[_out++] = output[from++];\n                                                output[_out++] = output[from++];\n                                                len -= 3;\n                                            } while (len > 2);\n                                            if (len) {\n                                                output[_out++] = output[from++];\n                                                if (len > 1) {\n                                                    output[_out++] = output[from++];\n                                                }\n                                            }\n                                        }\n                                    } else if ((op & 64) === 0) {\n                                        here = dcode[(here & 65535) + (hold & (1 << op) - 1)];\n                                        continue dodist;\n                                    } else {\n                                        strm.msg = 'invalid distance code';\n                                        state.mode = BAD;\n                                        break top;\n                                    }\n                                    break;\n                                }\n                        } else if ((op & 64) === 0) {\n                            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];\n                            continue dolen;\n                        } else if (op & 32) {\n                            state.mode = TYPE;\n                            break top;\n                        } else {\n                            strm.msg = 'invalid literal/length code';\n                            state.mode = BAD;\n                            break top;\n                        }\n                        break;\n                    }\n            } while (_in < last && _out < end);\n        len = bits >> 3;\n        _in -= len;\n        bits -= len << 3;\n        hold &= (1 << bits) - 1;\n        strm.next_in = _in;\n        strm.next_out = _out;\n        strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);\n        strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);\n        state.hold = hold;\n        state.bits = bits;\n        return;\n    };\n\n    return inflate_fast;\n});"]}