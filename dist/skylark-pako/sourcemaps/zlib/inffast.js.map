{"version":3,"sources":["zlib/inffast.js"],"names":["define","BAD","TYPE","strm","start","_in","last","_out","beg","end","dmax","wsize","whave","wnext","s_window","hold","bits","lcode","dcode","lmask","dmask","here","op","len","dist","from","from_source","input","output","state","next_in","avail_in","next_out","avail_out","window","lencode","distcode","lenbits","distbits","top","dolen","mode","msg","dodist","sane"],"mappings":"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","file":"../../zlib/inffast.js","sourcesContent":["define([], function () {\n    'use strict';\n    // Original version : zlib 1.2.8\n    // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n\n    // See state defs from inflate.js\n    const BAD = 30;       /* got a data error -- remain here until reset */\n    const TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\n\n    /*\n       Decode literal, length, and distance codes and write out the resulting\n       literal and match bytes until either not enough input or output is\n       available, an end-of-block is encountered, or a data error is encountered.\n       When large enough input and output buffers are supplied to inflate(), for\n       example, a 16K input buffer and a 64K output buffer, more than 95% of the\n       inflate execution time is spent in this routine.\n\n       Entry assumptions:\n\n            state.mode === LEN\n            strm.avail_in >= 6\n            strm.avail_out >= 258\n            start >= strm.avail_out\n            state.bits < 8\n\n       On return, state.mode is one of:\n\n            LEN -- ran out of enough output space or enough available input\n            TYPE -- reached end of block code, inflate() to interpret next block\n            BAD -- error in block data\n\n       Notes:\n\n        - The maximum input bits used by a length/distance pair is 15 bits for the\n          length code, 5 bits for the length extra, 15 bits for the distance code,\n          and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n          Therefore if strm.avail_in >= 6, then there is enough input to avoid\n          checking for available input while decoding.\n\n        - The maximum bytes that a single length/distance pair can output is 258\n          bytes, which is the maximum length that can be coded.  inflate_fast()\n          requires strm.avail_out >= 258 for each loop to avoid checking for\n          output space.\n     */\n    function inflate_fast(strm, start) {\n      let _in;                    /* local strm.input */\n      let last;                   /* have enough input while in < last */\n      let _out;                   /* local strm.output */\n      let beg;                    /* inflate()'s initial strm.output */\n      let end;                    /* while out < end, enough space available */\n    //#ifdef INFLATE_STRICT\n      let dmax;                   /* maximum distance from zlib header */\n    //#endif\n      let wsize;                  /* window size or zero if not using window */\n      let whave;                  /* valid bytes in the window */\n      let wnext;                  /* window write index */\n      // Use `s_window` instead `window`, avoid conflict with instrumentation tools\n      let s_window;               /* allocated sliding window, if wsize != 0 */\n      let hold;                   /* local strm.hold */\n      let bits;                   /* local strm.bits */\n      let lcode;                  /* local strm.lencode */\n      let dcode;                  /* local strm.distcode */\n      let lmask;                  /* mask for first level of length codes */\n      let dmask;                  /* mask for first level of distance codes */\n      let here;                   /* retrieved table entry */\n      let op;                     /* code bits, operation, extra bits, or */\n                                  /*  window position, window bytes to copy */\n      let len;                    /* match length, unused bytes */\n      let dist;                   /* match distance */\n      let from;                   /* where to copy match from */\n      let from_source;\n\n\n      let input, output; // JS specific, because we have no pointers\n\n      /* copy state to local variables */\n      const state = strm.state;\n      //here = state.here;\n      _in = strm.next_in;\n      input = strm.input;\n      last = _in + (strm.avail_in - 5);\n      _out = strm.next_out;\n      output = strm.output;\n      beg = _out - (start - strm.avail_out);\n      end = _out + (strm.avail_out - 257);\n    //#ifdef INFLATE_STRICT\n      dmax = state.dmax;\n    //#endif\n      wsize = state.wsize;\n      whave = state.whave;\n      wnext = state.wnext;\n      s_window = state.window;\n      hold = state.hold;\n      bits = state.bits;\n      lcode = state.lencode;\n      dcode = state.distcode;\n      lmask = (1 << state.lenbits) - 1;\n      dmask = (1 << state.distbits) - 1;\n\n\n      /* decode literals and length/distances until end-of-block or not enough\n         input data or output space */\n\n      top:\n      do {\n        if (bits < 15) {\n          hold += input[_in++] << bits;\n          bits += 8;\n          hold += input[_in++] << bits;\n          bits += 8;\n        }\n\n        here = lcode[hold & lmask];\n\n        dolen:\n        for (;;) { // Goto emulation\n          op = here >>> 24/*here.bits*/;\n          hold >>>= op;\n          bits -= op;\n          op = (here >>> 16) & 0xff/*here.op*/;\n          if (op === 0) {                          /* literal */\n            //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n            //        \"inflate:         literal '%c'\\n\" :\n            //        \"inflate:         literal 0x%02x\\n\", here.val));\n            output[_out++] = here & 0xffff/*here.val*/;\n          }\n          else if (op & 16) {                     /* length base */\n            len = here & 0xffff/*here.val*/;\n            op &= 15;                           /* number of extra bits */\n            if (op) {\n              if (bits < op) {\n                hold += input[_in++] << bits;\n                bits += 8;\n              }\n              len += hold & ((1 << op) - 1);\n              hold >>>= op;\n              bits -= op;\n            }\n            //Tracevv((stderr, \"inflate:         length %u\\n\", len));\n            if (bits < 15) {\n              hold += input[_in++] << bits;\n              bits += 8;\n              hold += input[_in++] << bits;\n              bits += 8;\n            }\n            here = dcode[hold & dmask];\n\n            dodist:\n            for (;;) { // goto emulation\n              op = here >>> 24/*here.bits*/;\n              hold >>>= op;\n              bits -= op;\n              op = (here >>> 16) & 0xff/*here.op*/;\n\n              if (op & 16) {                      /* distance base */\n                dist = here & 0xffff/*here.val*/;\n                op &= 15;                       /* number of extra bits */\n                if (bits < op) {\n                  hold += input[_in++] << bits;\n                  bits += 8;\n                  if (bits < op) {\n                    hold += input[_in++] << bits;\n                    bits += 8;\n                  }\n                }\n                dist += hold & ((1 << op) - 1);\n    //#ifdef INFLATE_STRICT\n                if (dist > dmax) {\n                  strm.msg = 'invalid distance too far back';\n                  state.mode = BAD;\n                  break top;\n                }\n    //#endif\n                hold >>>= op;\n                bits -= op;\n                //Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n                op = _out - beg;                /* max distance in output */\n                if (dist > op) {                /* see if copy from window */\n                  op = dist - op;               /* distance back in window */\n                  if (op > whave) {\n                    if (state.sane) {\n                      strm.msg = 'invalid distance too far back';\n                      state.mode = BAD;\n                      break top;\n                    }\n\n    // (!) This block is disabled in zlib defaults,\n    // don't enable it for binary compatibility\n    //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n    //                if (len <= op - whave) {\n    //                  do {\n    //                    output[_out++] = 0;\n    //                  } while (--len);\n    //                  continue top;\n    //                }\n    //                len -= op - whave;\n    //                do {\n    //                  output[_out++] = 0;\n    //                } while (--op > whave);\n    //                if (op === 0) {\n    //                  from = _out - dist;\n    //                  do {\n    //                    output[_out++] = output[from++];\n    //                  } while (--len);\n    //                  continue top;\n    //                }\n    //#endif\n                  }\n                  from = 0; // window index\n                  from_source = s_window;\n                  if (wnext === 0) {           /* very common case */\n                    from += wsize - op;\n                    if (op < len) {         /* some from window */\n                      len -= op;\n                      do {\n                        output[_out++] = s_window[from++];\n                      } while (--op);\n                      from = _out - dist;  /* rest from output */\n                      from_source = output;\n                    }\n                  }\n                  else if (wnext < op) {      /* wrap around window */\n                    from += wsize + wnext - op;\n                    op -= wnext;\n                    if (op < len) {         /* some from end of window */\n                      len -= op;\n                      do {\n                        output[_out++] = s_window[from++];\n                      } while (--op);\n                      from = 0;\n                      if (wnext < len) {  /* some from start of window */\n                        op = wnext;\n                        len -= op;\n                        do {\n                          output[_out++] = s_window[from++];\n                        } while (--op);\n                        from = _out - dist;      /* rest from output */\n                        from_source = output;\n                      }\n                    }\n                  }\n                  else {                      /* contiguous in window */\n                    from += wnext - op;\n                    if (op < len) {         /* some from window */\n                      len -= op;\n                      do {\n                        output[_out++] = s_window[from++];\n                      } while (--op);\n                      from = _out - dist;  /* rest from output */\n                      from_source = output;\n                    }\n                  }\n                  while (len > 2) {\n                    output[_out++] = from_source[from++];\n                    output[_out++] = from_source[from++];\n                    output[_out++] = from_source[from++];\n                    len -= 3;\n                  }\n                  if (len) {\n                    output[_out++] = from_source[from++];\n                    if (len > 1) {\n                      output[_out++] = from_source[from++];\n                    }\n                  }\n                }\n                else {\n                  from = _out - dist;          /* copy direct from output */\n                  do {                        /* minimum length is three */\n                    output[_out++] = output[from++];\n                    output[_out++] = output[from++];\n                    output[_out++] = output[from++];\n                    len -= 3;\n                  } while (len > 2);\n                  if (len) {\n                    output[_out++] = output[from++];\n                    if (len > 1) {\n                      output[_out++] = output[from++];\n                    }\n                  }\n                }\n              }\n              else if ((op & 64) === 0) {          /* 2nd level distance code */\n                here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n                continue dodist;\n              }\n              else {\n                strm.msg = 'invalid distance code';\n                state.mode = BAD;\n                break top;\n              }\n\n              break; // need to emulate goto via \"continue\"\n            }\n          }\n          else if ((op & 64) === 0) {              /* 2nd level length code */\n            here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n            continue dolen;\n          }\n          else if (op & 32) {                     /* end-of-block */\n            //Tracevv((stderr, \"inflate:         end of block\\n\"));\n            state.mode = TYPE;\n            break top;\n          }\n          else {\n            strm.msg = 'invalid literal/length code';\n            state.mode = BAD;\n            break top;\n          }\n\n          break; // need to emulate goto via \"continue\"\n        }\n      } while (_in < last && _out < end);\n\n      /* return unused bytes (on entry, bits < 8, so in won't go too far back) */\n      len = bits >> 3;\n      _in -= len;\n      bits -= len << 3;\n      hold &= (1 << bits) - 1;\n\n      /* update state and return */\n      strm.next_in = _in;\n      strm.next_out = _out;\n      strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));\n      strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));\n      state.hold = hold;\n      state.bits = bits;\n      return;\n    };\n\n\n    return inflate_fast;\n});"]}