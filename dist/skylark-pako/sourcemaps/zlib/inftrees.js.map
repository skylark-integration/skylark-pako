{"version":3,"sources":["zlib/inftrees.js"],"names":["define","lbase","Uint16Array","lext","Uint8Array","dbase","dext","type","lens","lens_index","codes","table","table_index","work","opts","bits","incr","fill","low","mask","next","end","len","sym","min","max","root","curr","drop","left","used","huff","base","base_index","count","MAXBITS","offs","here_bits","here_op","here_val","extra","extra_index"],"mappings":";;;;;;;AAAAA,UAAW,WACP,aAEA,MAMMC,EAAQ,IAAIC,aACd,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,EACA,IAEEC,EAAO,IAAIC,YACb,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,KAEEC,EAAQ,IAAIH,aACd,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,MACA,MACA,MACA,EACA,IAEEI,EAAO,IAAIF,YACb,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,KAuKL,MArKuB,CAACG,EAAMC,EAAMC,EAAYC,EAAOC,EAAOC,EAAaC,EAAMC,KAC5E,MAAMC,EAAOD,EAAKC,KAClB,IASIC,EACAC,EACAC,EACAC,EACAC,EAGAC,EAhBAC,EAAM,EACNC,EAAM,EACNC,EAAM,EAAGC,EAAM,EACfC,EAAO,EACPC,EAAO,EACPC,EAAO,EACPC,EAAO,EACPC,EAAO,EACPC,EAAO,EAMPC,EAAO,KACPC,EAAa,EAEjB,MAAMC,EAAQ,IAAIhC,YAAYiC,IACxBC,EAAO,IAAIlC,YAAYiC,IAC7B,IAEIE,EAAWC,EAASC,EAFpBC,EAAQ,KACRC,EAAc,EAElB,IAAKnB,EAAM,EAAGA,GApKF,GAoKkBA,IAC1BY,EAAMZ,GAAO,EAEjB,IAAKC,EAAM,EAAGA,EAAMb,EAAOa,IACvBW,EAAM1B,EAAKC,EAAac,MAG5B,IADAG,EAAOX,EACFU,EA3KO,GA2KQA,GAAO,GACJ,IAAfS,EAAMT,GADgBA,KAQ9B,GAHIC,EAAOD,IACPC,EAAOD,GAEC,IAARA,EAIA,OAHAd,EAAMC,KAAiB,SACvBD,EAAMC,KAAiB,SACvBE,EAAKC,KAAO,EACL,EAEX,IAAKS,EAAM,EAAGA,EAAMC,GACG,IAAfS,EAAMV,GADWA,KASzB,IAJIE,EAAOF,IACPE,EAAOF,GAEXK,EAAO,EACFP,EAAM,EAAGA,GAlMF,GAkMkBA,IAG1B,GAFAO,IAAS,GACTA,GAAQK,EAAMZ,IACH,EACP,OAAQ,EAGhB,GAAIO,EAAO,IAtMD,IAsMOtB,GAA0B,IAARkB,GAC/B,OAAQ,EAGZ,IADAW,EAAK,GAAK,EACLd,EAAM,EAAGA,EA7MF,GA6MiBA,IACzBc,EAAKd,EAAM,GAAKc,EAAKd,GAAOY,EAAMZ,GAEtC,IAAKC,EAAM,EAAGA,EAAMb,EAAOa,IACQ,IAA3Bf,EAAKC,EAAac,KAClBV,EAAKuB,EAAK5B,EAAKC,EAAac,OAAWA,GA0B/C,GAzOU,IAkNNhB,GACAyB,EAAOQ,EAAQ3B,EACfQ,EAAM,IAnND,IAoNEd,GACPyB,EAAO/B,EACPgC,GAAc,IACdO,EAAQrC,EACRsC,GAAe,IACfpB,EAAM,MAENW,EAAO3B,EACPmC,EAAQlC,EACRe,GAAO,GAEXU,EAAO,EACPR,EAAM,EACND,EAAME,EACNJ,EAAOR,EACPe,EAAOD,EACPE,EAAO,EACPV,GAAO,EAEPC,GADAW,EAAO,GAAKJ,GACE,EAvOL,IAwOLnB,GAAiBuB,EA3OL,KAIN,IAuOiCvB,GAAkBuB,EA1O5C,IA2Ob,OAAO,EAEX,OAAS,CACLO,EAAYf,EAAMM,EACdf,EAAKU,GAAOF,GACZiB,EAAU,EACVC,EAAW1B,EAAKU,IACTV,EAAKU,GAAOF,GACnBiB,EAAUE,EAAMC,EAAc5B,EAAKU,IACnCgB,EAAWP,EAAKC,EAAapB,EAAKU,MAElCe,EAAU,GACVC,EAAW,GAEfvB,EAAO,GAAKM,EAAMM,EAElBJ,EADAP,EAAO,GAAKU,EAEZ,GAEIhB,EAAMS,GAAQW,GAAQH,IADtBX,GAAQD,IAC8BqB,GAAa,GAAKC,GAAW,GAAKC,EAAW,QACrE,IAATtB,GAET,IADAD,EAAO,GAAKM,EAAM,EACXS,EAAOf,GACVA,IAAS,EASb,GAPa,IAATA,GACAe,GAAQf,EAAO,EACfe,GAAQf,GAERe,EAAO,EAEXR,IACqB,KAAfW,EAAMZ,GAAY,CACpB,GAAIA,IAAQG,EACR,MAEJH,EAAMd,EAAKC,EAAaI,EAAKU,IAEjC,GAAID,EAAMI,IAASK,EAAOZ,KAAUD,EAAK,CAOrC,IANa,IAATU,IACAA,EAAOF,GAEXN,GAAQI,EAERK,EAAO,IADPF,EAAOL,EAAMM,GAEND,EAAOC,EAAOH,MACjBI,GAAQK,EAAMP,EAAOC,KACT,IAGZD,IACAE,IAAS,EAGb,GADAC,GAAQ,GAAKH,EA9RZ,IA+RGpB,GAAiBuB,EAlSb,KAIN,IA8RyCvB,GAAkBuB,EAjSpD,IAkSL,OAAO,EAGXnB,EADAO,EAAMa,EAAOZ,GACAO,GAAQ,GAAKC,GAAQ,GAAKP,EAAOR,EAAc,GAOpE,OAJa,IAATmB,IACApB,EAAMS,EAAOW,GAAQT,EAAMM,GAAQ,GAAK,IAAM,GAAK,GAEvDd,EAAKC,KAAOW,EACL","file":"../../zlib/inftrees.js","sourcesContent":["define([], function () {\n    'use strict';\n\n    const MAXBITS = 15;\n    const ENOUGH_LENS = 852;\n    const ENOUGH_DISTS = 592;\n    const CODES = 0;\n    const LENS = 1;\n    const DISTS = 2;\n    const lbase = new Uint16Array([\n        3,\n        4,\n        5,\n        6,\n        7,\n        8,\n        9,\n        10,\n        11,\n        13,\n        15,\n        17,\n        19,\n        23,\n        27,\n        31,\n        35,\n        43,\n        51,\n        59,\n        67,\n        83,\n        99,\n        115,\n        131,\n        163,\n        195,\n        227,\n        258,\n        0,\n        0\n    ]);\n    const lext = new Uint8Array([\n        16,\n        16,\n        16,\n        16,\n        16,\n        16,\n        16,\n        16,\n        17,\n        17,\n        17,\n        17,\n        18,\n        18,\n        18,\n        18,\n        19,\n        19,\n        19,\n        19,\n        20,\n        20,\n        20,\n        20,\n        21,\n        21,\n        21,\n        21,\n        16,\n        72,\n        78\n    ]);\n    const dbase = new Uint16Array([\n        1,\n        2,\n        3,\n        4,\n        5,\n        7,\n        9,\n        13,\n        17,\n        25,\n        33,\n        49,\n        65,\n        97,\n        129,\n        193,\n        257,\n        385,\n        513,\n        769,\n        1025,\n        1537,\n        2049,\n        3073,\n        4097,\n        6145,\n        8193,\n        12289,\n        16385,\n        24577,\n        0,\n        0\n    ]);\n    const dext = new Uint8Array([\n        16,\n        16,\n        16,\n        16,\n        17,\n        17,\n        18,\n        18,\n        19,\n        19,\n        20,\n        20,\n        21,\n        21,\n        22,\n        22,\n        23,\n        23,\n        24,\n        24,\n        25,\n        25,\n        26,\n        26,\n        27,\n        27,\n        28,\n        28,\n        29,\n        29,\n        64,\n        64\n    ]);\n    const inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) => {\n        const bits = opts.bits;\n        let len = 0;\n        let sym = 0;\n        let min = 0, max = 0;\n        let root = 0;\n        let curr = 0;\n        let drop = 0;\n        let left = 0;\n        let used = 0;\n        let huff = 0;\n        let incr;\n        let fill;\n        let low;\n        let mask;\n        let next;\n        let base = null;\n        let base_index = 0;\n        let end;\n        const count = new Uint16Array(MAXBITS + 1);\n        const offs = new Uint16Array(MAXBITS + 1);\n        let extra = null;\n        let extra_index = 0;\n        let here_bits, here_op, here_val;\n        for (len = 0; len <= MAXBITS; len++) {\n            count[len] = 0;\n        }\n        for (sym = 0; sym < codes; sym++) {\n            count[lens[lens_index + sym]]++;\n        }\n        root = bits;\n        for (max = MAXBITS; max >= 1; max--) {\n            if (count[max] !== 0) {\n                break;\n            }\n        }\n        if (root > max) {\n            root = max;\n        }\n        if (max === 0) {\n            table[table_index++] = 1 << 24 | 64 << 16 | 0;\n            table[table_index++] = 1 << 24 | 64 << 16 | 0;\n            opts.bits = 1;\n            return 0;\n        }\n        for (min = 1; min < max; min++) {\n            if (count[min] !== 0) {\n                break;\n            }\n        }\n        if (root < min) {\n            root = min;\n        }\n        left = 1;\n        for (len = 1; len <= MAXBITS; len++) {\n            left <<= 1;\n            left -= count[len];\n            if (left < 0) {\n                return -1;\n            }\n        }\n        if (left > 0 && (type === CODES || max !== 1)) {\n            return -1;\n        }\n        offs[1] = 0;\n        for (len = 1; len < MAXBITS; len++) {\n            offs[len + 1] = offs[len] + count[len];\n        }\n        for (sym = 0; sym < codes; sym++) {\n            if (lens[lens_index + sym] !== 0) {\n                work[offs[lens[lens_index + sym]]++] = sym;\n            }\n        }\n        if (type === CODES) {\n            base = extra = work;\n            end = 19;\n        } else if (type === LENS) {\n            base = lbase;\n            base_index -= 257;\n            extra = lext;\n            extra_index -= 257;\n            end = 256;\n        } else {\n            base = dbase;\n            extra = dext;\n            end = -1;\n        }\n        huff = 0;\n        sym = 0;\n        len = min;\n        next = table_index;\n        curr = root;\n        drop = 0;\n        low = -1;\n        used = 1 << root;\n        mask = used - 1;\n        if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {\n            return 1;\n        }\n        for (;;) {\n            here_bits = len - drop;\n            if (work[sym] < end) {\n                here_op = 0;\n                here_val = work[sym];\n            } else if (work[sym] > end) {\n                here_op = extra[extra_index + work[sym]];\n                here_val = base[base_index + work[sym]];\n            } else {\n                here_op = 32 + 64;\n                here_val = 0;\n            }\n            incr = 1 << len - drop;\n            fill = 1 << curr;\n            min = fill;\n            do {\n                fill -= incr;\n                table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;\n            } while (fill !== 0);\n            incr = 1 << len - 1;\n            while (huff & incr) {\n                incr >>= 1;\n            }\n            if (incr !== 0) {\n                huff &= incr - 1;\n                huff += incr;\n            } else {\n                huff = 0;\n            }\n            sym++;\n            if (--count[len] === 0) {\n                if (len === max) {\n                    break;\n                }\n                len = lens[lens_index + work[sym]];\n            }\n            if (len > root && (huff & mask) !== low) {\n                if (drop === 0) {\n                    drop = root;\n                }\n                next += min;\n                curr = len - drop;\n                left = 1 << curr;\n                while (curr + drop < max) {\n                    left -= count[curr + drop];\n                    if (left <= 0) {\n                        break;\n                    }\n                    curr++;\n                    left <<= 1;\n                }\n                used += 1 << curr;\n                if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {\n                    return 1;\n                }\n                low = huff & mask;\n                table[low] = root << 24 | curr << 16 | next - table_index | 0;\n            }\n        }\n        if (huff !== 0) {\n            table[next + huff] = len - drop << 24 | 64 << 16 | 0;\n        }\n        opts.bits = root;\n        return 0;\n    };\n\n   return inflate_table;\n\n});"]}